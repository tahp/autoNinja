<bigarchive>
<archive relative="****phantomglobalvars****">
</archive>
<archive relative = "globals.xml" vhdlpkg="chip_cfg_pkg">

  
  <var name="NB_BITS_ADDR" value="26" ><comment>AHB Address bus size</comment></var>

  

  <var name="SYS_SRAM_ADDR_WIDTH" value="13" ><comment>The System SRam size</comment></var>
  <var name="SYS_SRAM_SIZE" value="exp2(SYS_SRAM_ADDR_WIDTH+2)" />

  <var name="SYS_NB_BITS_MASTER" value="4" ><comment>System Ahb Bus Configuration</comment></var>
  
  <enum name="Sys_Master_Id">
    <entry name="SYS_MID_DUMMY"/>
    <entry name="SYS_MID_BIST"/>
    <bound name="SYS_MID_RR_Start"><comment>After this starts the Round Robib Pool</comment></bound>
    <entry name="SYS_MID_DMA"/>
    <entry name="SYS_MID_XCPU"/>
    <entry name="SYS_MID_AHB2AHB"/>
    <entry name="SYS_MID_IFC"/>
    <entry name="SYS_MID_USB"/>
    <entry name="SYS_MID_GOUDA"/>
    <entry name="SYS_MID_VOC"/>
    <entry name="SYS_MID_IFC2"/>
    <bound name="SYS_MID_RR_End"/>
  </enum>
  <var name="SYS_NB_STATIC_MASTER" value="SYS_MID_RR_Start-1"/>
  <var name="SYS_NB_MASTERS" value="SYS_MID_RR_End-1"/>

  <var name="SYS_NB_BITS_SLAVE" value="4"/>
  
  <enum name="Sys_slave_Id">
    <entry name="SYS_SID_DUMMY"/>
    <entry name="SYS_SID_MEM_BRIDGE"/>
    <entry name="SYS_SID_AHB2AHB"/>
    <entry name="SYS_SID_IFC"/>
    <entry name="SYS_SID_USB"/>
    <entry name="SYS_SID_GOUDA"/>
    <entry name="SYS_SID_XCPU_RAM"/>
    <entry name="SYS_SID_SPI_FLASH"/>
    <entry name="SYS_SID_VOC"/>
    <entry name="SYS_SID_MPMC"/>
    <entry name="SYS_SID_MPMCREG"/>
    <entry name="SYS_SID_MAILBOX"/>
    <entry name="SYS_SID_IFC2"/>
    <bound name="SYS_SID_End"/>
  </enum>
  <var name="SYS_NB_SLAVES" value="SYS_SID_End-1" />

  <var name="SYS_NB_BITS_PSEL" value="6" ><comment>System Apb Bus Configuration</comment></var>
  <var name="SYS_NB_BITS_PADDR" value="12"></var>

  <var name="SYS_APB_STEP" value="exp2(SYS_NB_BITS_PADDR)"/>

  
  <enum name="Sys_Module_Id">
    <entry name="SYS_ID_SYS_CTRL"/>
    <entry name="SYS_ID_IRQ"/>
    <entry name="SYS_ID_TIMER"/>
    <entry name="SYS_ID_GPIO"/>
    <entry name="SYS_ID_EBC"/>
    <entry name="SYS_ID_KEYPAD"/>
    <entry name="SYS_ID_PWM"/>
    <entry name="SYS_ID_I2C"/>
    <entry name="SYS_ID_DMA"/>
    <entry name="SYS_ID_IFC"/>
    <entry name="SYS_ID_CALENDAR"/>
    <entry name="SYS_ID_COMREGS"/>
    <entry name="SYS_ID_PAGE_SPY"/>
    <entry name="SYS_ID_SEG_SCAN"/>
    <bound name="FIRST_SYS_ID_DATA"/> 
    <entry name="SYS_ID_RF_SPI"/>
    <entry name="SYS_ID_TCU"/>
    
    <entry name="SYS_ID_SCI"><comment>The following modules are linked to ifc dma req with 2 requests per module</comment></entry>
    <entry name="SYS_ID_SPI1"/>
    <entry name="SYS_ID_SPI2"/>
    <entry name="SYS_ID_SPI3"/>
    <entry name="SYS_ID_DEBUG_UART"/>
    <entry name="SYS_ID_UART"/>
    <entry name="SYS_ID_UART2"/>
    <entry name="SYS_ID_SDMMC"/>
    <entry name="SYS_ID_CAMERA"/>
    <bound name="LAST_SYS_ID_DATA"/>
    <entry name="SYS_ID_SDMMC2"/>
    <entry name="SYS_ID_XCPU_TAG"/>
    <entry name="SYS_ID_XCPU_IDATA"/>
    <entry name="SYS_ID_XCPU_DDATA"/>
    <entry name="SYS_ID_SYS_AHBC_MON"/>
    <entry name="SYS_ID_BB_AHBC_MON"/>
    <entry name="SYS_ID_BIST"/>
    <entry name="SYS_ID_IFC2"/>
    <entry name="SYS_ID_GOUDA"/>
    <entry name="SYS_ID_I2C2"/>
    <entry name="SYS_ID_I2C3"/>
    <entry name="SYS_ID_EXT_APB"/>
    <entry name="SYS_ID_SPIFLASH"/>
    <entry name="SYS_ID_NF"/>
    <entry name="SYS_ID_NF1"/>
    <entry name="SYS_ID_NF2"/>
    <entry name="SYS_ID_NF3"/>
    <entry name="SYS_ID_IOMUX"/>
    <entry name="SYS_ID_XCPU_REG"/>
    <bound name="SYS_NB_PSEL"></bound>
  </enum>
    <var name="SYS_ID_DEBUG_HOST" value="exp2(SYS_NB_BITS_PSEL)-1"><comment>The debug host is placed at last PSEL63 in the IFC</comment></var>
  
  
  <enum name="Sys_Ifc_Request_IDs">
    <entry name="SYS_ID_TX_SCI"/>       
    <entry name="SYS_ID_RX_SCI"/>       
    <entry name="SYS_ID_TX_SPI1"/>      
    <entry name="SYS_ID_RX_SPI1"/>      
    <entry name="SYS_ID_TX_SPI2"/>      
    <entry name="SYS_ID_RX_SPI2"/>      
    <entry name="SYS_ID_TX_SPI3"/>      
    <entry name="SYS_ID_RX_SPI3"/>      
    <entry name="SYS_ID_TX_DEBUG_UART"/>
    <entry name="SYS_ID_RX_DEBUG_UART"/>
    <entry name="SYS_ID_TX_UART"/>      
    <entry name="SYS_ID_RX_UART"/>      
    <entry name="SYS_ID_TX_UART2"/>     
    <entry name="SYS_ID_RX_UART2"/>     
    <entry name="SYS_ID_TX_SDMMC"/>     
    <entry name="SYS_ID_RX_SDMMC"/>     
    <entry name="SYS_ID_TX_FREE"/>      
    <entry name="SYS_ID_RX_CAMERA"/>    
    <entry name="SYS_ID_TX_SDMMC2"/>    
    <entry name="SYS_ID_RX_SDMMC2"/>    
  </enum>
  
  <var name="SYS_NB_DMA_REQ" value="20"></var>
  <var name="SYS_NB_DMA_REQ_WIDTH" value="5"></var>

    
    <enum name="Sys_Irq_Id">
        <entry name="SYS_IRQ_TCU0"><comment>System IRQ IDs<br/>Pulse IRQ</comment></entry>
        <entry name="SYS_IRQ_TCU1"/>
        <entry name="SYS_IRQ_FRAME"/>
        <bound name="SYS_NB_IRQ_PULSE"><comment>Number of Pulse IRQ</comment></bound>
        <entry name="SYS_IRQ_COM0"><comment>Level IRQ</comment></entry>
        <entry name="SYS_IRQ_COM1"/>
        <entry name="SYS_IRQ_VOC"/>
        <entry name="SYS_IRQ_DMA"/>
        <entry name="SYS_IRQ_GPIO"/>
        <entry name="SYS_IRQ_KEYPAD"/>
        <entry name="SYS_IRQ_TIMERS"/>
        <entry name="SYS_IRQ_OS_TIMER"/>
        <entry name="SYS_IRQ_CALENDAR"/>
        <entry name="SYS_IRQ_SPI1"/>
        <entry name="SYS_IRQ_SPI2"/>
        <entry name="SYS_IRQ_SPI3"/>
        <entry name="SYS_IRQ_DEBUG_UART"/>
        <entry name="SYS_IRQ_UART"/>
        <entry name="SYS_IRQ_UART2"/>
        <entry name="SYS_IRQ_I2C"/>
        <entry name="SYS_IRQ_I2C2"/>
        <entry name="SYS_IRQ_I2C3"/>
        <entry name="SYS_IRQ_SCI"/>
        <entry name="SYS_IRQ_RF_SPI"/>
        <entry name="SYS_IRQ_LPS"/>
        <entry name="SYS_IRQ_BBIFC0"/>
        <entry name="SYS_IRQ_BBIFC1"/>
        <entry name="SYS_IRQ_USBC"/>
        <entry name="SYS_IRQ_GOUDA"/>
        <entry name="SYS_IRQ_SDMMC"/>
        <entry name="SYS_IRQ_CAMERA"/>
        <entry name="SYS_IRQ_PMU"/>
        <entry name="SYS_IRQ_SDMMC2"/>
        <bound name="SYS_IRQ_QTY"><comment>Number of IRQ handled by the production driver</comment></bound>
        <bound name="SYS_NB_IRQ"><comment>Number of IRQ</comment></bound>
    </enum>
    <var name="SYS_NB_IRQ_LEVEL" value="SYS_NB_IRQ - SYS_NB_IRQ_PULSE"><comment>Number of Level IRQ</comment></var>
    
    <range name="SYS_IRQ_TCU" left="SYS_IRQ_TCU1" right="SYS_IRQ_TCU0" />
    <range name="SYS_IRQ_COMREG" left="SYS_IRQ_COM1" right="SYS_IRQ_COM0" />
    
  

  <var name="BB_SRAM_ADDR_WIDTH" value="13" ><comment>The Baseband SRam size</comment></var>
  <var name="BB_SRAM_SIZE" value="24*1024" />

  <var name="BB_NB_BITS_MASTER" value="3" ><comment>Baseband Ahb Bus Configuration</comment></var>
  
  <enum name="BB_Master_Id">
    <entry name="BB_MID_DUMMY"/>
    <entry name="BB_MID_BIST"/>
    <entry name="BB_MID_IFC"/>
    <bound name="BB_MID_RR_Start"><comment>After this starts the Round Robib Pool</comment></bound>
    <entry name="BB_MID_VOC"/>
    <entry name="BB_MID_BCPU"/>
    <entry name="BB_MID_AHB2AHB"/>
    <bound name="BB_MID_RR_End"/>
  </enum>
  <var name="BB_NB_STATIC_MASTER" value="BB_MID_RR_Start-1"/>
  <var name="BB_NB_MASTERS" value="BB_MID_RR_End-1"/>
  <var name="BB_MAX_BURST_SIZE" value="4"/>
  <var name="BB_MAX_BURST_BITS" value="2"/>
  <var name="BB_NB_BITS_SLAVE" value="3"/>
  
  <enum name="BB_slave_Id">
    <entry name="BB_SID_DUMMY"/>
    <entry name="BB_SID_MEM_BRIDGE"/>
    <entry name="BB_SID_AHB2AHB"/>
    <entry name="BB_SID_IFC"/>
    <entry name="BB_SID_ROM"/>
    <entry name="BB_SID_SRAM"/>
    <entry name="BB_SID_MAILBOX"/>
    <bound name="BB_SID_End"/>
  </enum>
  <var name="BB_NB_SLAVES" value="BB_SID_End-1" />  

  <var name="BB_NB_BITS_PSEL" value="5"><comment>BaseBand Apb Bus Configuration</comment></var>
  <var name="BB_NB_BITS_PADDR" value="12"></var>

  <var name="BB_APB_STEP" value="exp2(BB_NB_BITS_PADDR)"/>

  
  <enum name="BB_Module_Id">
    <entry name="BB_ID_XCOR"/>
    <entry name="BB_ID_IFC"/>
    <entry name="BB_ID_IRQ"/>
    <entry name="BB_ID_ITLV"/>
    <entry name="BB_ID_VITERBI"/>
    <entry name="BB_ID_A5"/>
    <entry name="BB_ID_RF"/>
    <entry name="BB_ID_AIF"/>
    <entry name="BB_ID_CP2"/>
    <entry name="BB_ID_BIST"/>
    <entry name="BB_ID_BCPU_REG"/>
    <entry name="BB_ID_BCPU_TAG"/>
    <entry name="BB_ID_BCPU_IDATA"/>
    <entry name="BB_ID_BCPU_DDATA"/>
    <entry name="BB_ID_COMREGS"/>
    <entry name="BB_ID_EXCOR"/>
    <entry name="BB_ID_CHOLK"/>
    <entry name="BB_ID_CORDIC"/>
    <entry name="BB_ID_MEMBRIDGE"/>
    <bound name="BB_NB_PSEL"><comment>The maximum number of slaves is currently 32.</comment></bound>
  </enum>

    
    <enum name="BB_Irq_Id">
        <entry name="BB_IRQ_TCU0"><comment>Baseband IRQ IDs<br/>Pulse IRQ</comment></entry>
        <entry name="BB_IRQ_TCU1"/>
        <entry name="BB_IRQ_FRAME"/>
        <bound name="BB_NB_IRQ_PULSE"><comment>Number of Pulse IRQ</comment></bound>
        <entry name="BB_IRQ_COM0"><comment>Level IRQ</comment></entry>
        <entry name="BB_IRQ_COM1"/>
        <entry name="BB_IRQ_VOC"/>
        <entry name="BB_IRQ_IFC0"/>
        <entry name="BB_IRQ_IFC1"/>
        <entry name="BB_IRQ_IFC2"/>
        <entry name="BB_IRQ_IFC3"/>
        <entry name="BB_IRQ_RF_IF"/>
        <entry name="BB_IRQ_ITLV"/>
        <entry name="BB_IRQ_VITAC"/>
        <entry name="BB_IRQ_XCOR"/>
        <bound name="BB_NB_IRQ"><comment>Number of IRQ</comment></bound>
    </enum>
    <var name="BB_NB_IRQ_LEVEL" value="BB_NB_IRQ - BB_NB_IRQ_PULSE"><comment>Number of Level IRQ</comment></var>

    
    <range name="BB_IRQ_TCU" left="BB_IRQ_TCU1" right="BB_IRQ_TCU0" />
    <range name="BB_IRQ_COMREG" left="BB_IRQ_COM1" right="BB_IRQ_COM0" />
    <range name="BB_IRQ_IFC" left="BB_IRQ_IFC3" right="BB_IRQ_IFC0" />
    


  
  <var name="BB_SYMBOL_SIZE" value="13" ><comment>RF Input samples size (signed)</comment></var>
  <var name="VITAC_MULT_SIZE" value="14" ><comment>Vitac Multipliers size</comment></var>
  <var name="NB_DBG_SYS_SPY" value="11" ><comment>Total bits numbers of signals to spy on the SYS side</comment></var>  
  <var name="NB_DBG_BB_SPY" value="28" ><comment>Total bits numbers of signals to spy on the BB side</comment></var>  

  <cjoker>
    /// XHALT macro will send the event 0x4a17 to the debug host and
    /// will stall the XCPU.  The XCPU can be released from Coolwatcher
    /// by issuing a xrbp command.
    #define XHALT { \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
        while (hwp_debugHost->event != DEBUG_HOST_EVENT0_SEMA); \
        hwp_debugHost->event = 0x4a17; \
        hwp_sysCtrl->XCpu_Dbg_BKP |= SYS_CTRL_STALLED; \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
    }
  </cjoker>


</archive>

<archive relative = "global_macros.xml" asm="no">

<cjoker>

#define KSEG0(addr)     ( (addr) | 0x80000000 )
#define KSEG1(addr)     ( (addr) | 0xa0000000 )
#define KSEG01_PHY_ADDR(addr)       ((UINT32)(addr) &amp; 0x0FFFFFFF)
#define REG_ACCESS_ADDRESS(addr)    KSEG1(addr)

/* Define access cached or uncached */
#define MEM_ACCESS_CACHED(addr)     ((UINT32*)((UINT32)(addr)&amp;0xdfffffff))
#define MEM_ACCESS_UNCACHED(addr)   ((UINT32*)((UINT32)(addr)|0x20000000))

/* Register access for assembly */
#define BASE_HI(val) (((0xa0000000 | val) &amp; 0xffff8000) + (val &amp; 0x8000))
#define BASE_LO(val) (((val) &amp; 0x7fff) - (val &amp; 0x8000))

/* to extract bitfield from register value */
#define GET_BITFIELD(dword, bitfield) (((dword) &amp; (bitfield ## _MASK)) &gt;&gt; (bitfield ## _SHIFT))

#define EXP2(n) (1&lt;&lt;(n))

#define IS_IN_RANGE(value, base, size) (((value) &gt;= (base)) &amp;&amp; ((value) &lt; (base) + (size)))
#define ADDRESS_IN_HWP(address, hwp)   IS_IN_RANGE((UINT32)(address) &amp; 0x0FFFFFFF, (UINT32)(hwp) &amp; 0x0FFFFFFF, sizeof(*(hwp)))

</cjoker>

</archive>
<archive relative = "gallite_generic_config.xml">
  

    <var name="FPGA_OPTION" value="0" >
        <comment>0= chip option; 1= FPGA option
        </comment>
    </var>

    <var name="BB_OPTION" value="1" >
        <comment>0= no baseband; 1= baseband included
        </comment>
    </var>

    <var name="USE_TEST_MASTER" value="0" >
        <comment>0= Nothing; 1= BIST; 2= TEST MASTER
        </comment>
    </var>

    <var name="USE_SYS_AHBC_MON" value="0" >
        <comment>0= no monitor; 1=monitor included
        </comment>
    </var>
    
    <var name="HAVE_DEBUG_HOST_SEL" value="0" >
        <comment>0= no debug host sel register as on test chip; 1=debug host sel register included
        </comment>
    </var>

    <var name="VOC_OPTION" value="1" >
        <comment>0= No VOC ; 1= VOC included
        </comment>
    </var>

    <var name="AIF_OPTION" value="1" >
        <comment>0= No aif channels (0,1) ; 1= All 3 channels
        </comment>
    </var>

    <var name="MMI_OPTION" value="1" >
        <comment>0= No MMI ; 1= MMI included : keypad, PWL/PWT, calendar
        </comment>
    </var>

    <var name="NB_GPIO" value="37" >
        <comment>GPIO/GPO OPTIONS: numbers
        </comment>
    </var>
    <var name="NB_GPIO_INT" value="37" />
    <var name="NB_GPO" value="10" />

    <var name="DMA_OPTION" value="1" >
        <comment>0= No DMA ; 1= DMA included
        </comment>
    </var>

    <var name="SYS_PERIPH_OPTION" value="1" >
        <comment>0 = no SPI, no GPADC, no UART1; 1 = SPI, GPADC, UART1 included 
        </comment>
    </var>

    <var name="USB_OPTION" value="1" >
        <comment>0 = no USB; 1 = USB included 
        </comment>
    </var>

    <var name="SYS_IFC_NB_STD_CHANNEL" value="7" >
        <comment>System Ifc Number of generic channel (range 2 to 7)
        </comment>
    </var>

    <var name="UART2_OPTION" value="1" >
        <comment>0 = no UART2; 1 = UART2 included 
        </comment>
    </var>

    <var name="SPI1_NB_CS" value="2" >
        <comment>number of SPI1 CS
        </comment>
    </var>

    <var name="SPI1_NB_DI" value="2" >
        <comment>number of SPI1 DI
        </comment>
    </var>

    <var name="SPI1_DATA_SIZE" value="8" >
        <comment>size of SPI1 DATA
        </comment>
    </var>

    <var name="SPI2_OPTION" value="1" >
        <comment>0 = no SPI2; 1 = SPI2 included 
        </comment>
    </var>

    <var name="SPI2_NB_CS" value="2" >
        <comment>number of SPI2 CS
        </comment>
    </var>

    <var name="SPI2_NB_DI" value="2" >
        <comment>number of SPI DI
        </comment>
    </var>    

    <var name="SPI2_DATA_SIZE" value="8" >
        <comment>size of SPI2 DATA
        </comment>
    </var>
    
    <var name="SPI3_OPTION" value="1" >
        <comment>0 = no SPI3; 1 = SPI3 included 
        </comment>
    </var>

    <var name="SPI3_NB_CS" value="2" >
        <comment>number of SPI3 CS
        </comment>
    </var>
    
    <var name="SPI3_NB_DI" value="2" >
        <comment>number of SPI DI
        </comment>
    </var>    

    <var name="SPI3_DATA_SIZE" value="32" >
        <comment>size of SPI3 DATA
        </comment>
    </var>

    <var name="SDMMC_OPTION" value="1" >
        <comment>0 = no SDMMC; 1 = SDMMC controller included 
        </comment>
    </var>

    <var name="CAMERA_OPTION" value="1" >
        <comment>0 = no Camera; 1 = Camera controller included 
        </comment>
    </var>

    <var name="GOUDA_OPTION" value="1" >
        <comment>0 = no Gouda; 1 = Gouda included 
        </comment>
    </var>

    <var name="MEMBRIDGE_OPTION" value="0" >
        <comment>0 = EBC, 1 = AHBM
        </comment>
    </var>
    <var name="MEMBRIDGE_RAM_NB_BLOCK" value="2" >
        <comment>for membridge internal ram: number of 32k blocks
        </comment>
    </var>
    <var name="EBC_NB_BITS_ADDR" value="27" >
        <comment>for EBC option only
        </comment>
    </var>
    <var name="AHBM_NB_BITS_ADDR" value="28" >
        <comment>for AHBM option only: address bus size
        </comment>
    </var>
    <var name="AHBM_INIT_SB_0" value="0" />
    <var name="AHBM_INIT_SB_1" value="0" />
    <var name="AHBM_INIT_SB_2" value="0" />
    <var name="AHBM_INIT_SB_3" value="0" />
    <var name="AHBM_INIT_SB_4" value="0" />


</archive>
<archive relative = "voc_global.xml">
  
  <var name="AHB_NB_BITS_ADDR" value="28" ><comment>AHB Address bus size</comment></var>
</archive>


<archive relative = "abb.xml">

<include file='globals.xml'/>

<module name="abb" category="Analog">
    <reg name="chip_id_00H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="chipid" pos="15:4" access="rw" rst="0">
            <comment>chipid [11:0]
            </comment>
        </bits>
        <bits name="revid" pos="3:0" access="rw" rst="0">
            <comment>revid [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="gpadc_settings_01H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="sim_select" pos="15:14" access="rw" rst="0">
            <comment>sim_select [1:0]
            </comment>
        </bits>
        <bits name="reserved" pos="13:12" access="rw" rst="0">
        </bits>
        <bits name="pullup_enable_1" pos="11" access="rw" rst="0">
        </bits>
        <bits name="unsel_clk_val_1" pos="10" access="rw" rst="0">
        </bits>
        <bits name="unsel_rst_val_1" pos="9" access="rw" rst="0">
        </bits>
        <bits name="pullup_enable_2" pos="8" access="rw" rst="0">
        </bits>
        <bits name="unsel_clk_val_2" pos="7" access="rw" rst="0">
        </bits>
        <bits name="unsel_rst_val_2" pos="6" access="rw" rst="0">
        </bits>
        <bits name="pullup_enable_3" pos="5" access="rw" rst="0">
        </bits>
        <bits name="unsel_clk_val_3" pos="4" access="rw" rst="0">
        </bits>
        <bits name="unsel_rst_val_3" pos="3" access="rw" rst="0">
        </bits>
        <bits name="pullup_enable_4" pos="2" access="rw" rst="0">
        </bits>
        <bits name="unsel_clk_val_4" pos="1" access="rw" rst="0">
        </bits>
        <bits name="unsel_rst_val_4" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="codec_settings_1_02H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="codec_control_by_abb" pos="15" access="rw" rst="0">
        </bits>
        <bits name="au_deep_pd_n_reg" pos="14" access="rw" rst="0">
        </bits>
        <bits name="au_ref_pd_n_reg" pos="13" access="rw" rst="0">
        </bits>
        <bits name="au_mic_pd_n_reg" pos="12" access="rw" rst="0">
        </bits>
        <bits name="au_ad_pd_n_reg" pos="11" access="rw" rst="0">
        </bits>
        <bits name="au_dac_pd_n_reg" pos="10" access="rw" rst="0">
        </bits>
        <bits name="au_auxmic_sel_reg" pos="9" access="rw" rst="0">
        </bits>
        <bits name="au_auxmic_pd_n_reg" pos="8" access="rw" rst="0">
        </bits>
        <bits name="au_mic_gain_reg" pos="7:4" access="rw" rst="0">
            <comment>au_mic_gain_reg [3:0]
            </comment>
        </bits>
        <bits name="au_mic_mute_n_reg" pos="3" access="rw" rst="0">
        </bits>
        <bits name="au_spk_sel_reg" pos="2" access="rw" rst="0">
        </bits>
        <bits name="au_rcv_sel_reg" pos="1" access="rw" rst="0">
        </bits>
        <bits name="au_head_sel_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="codec_settings_2_03H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="au_fm_sel_reg" pos="15" access="rw" rst="0">
        </bits>
        <bits name="au_spk_mono_sel_reg" pos="14" access="rw" rst="0">
        </bits>
        <bits name="au_spk_mute_n_reg" pos="13" access="rw" rst="0">
        </bits>
        <bits name="au_dac_reset_n_reg" pos="12" access="rw" rst="0">
        </bits>
        <bits name="au_spk_gain_reg" pos="11:8" access="rw" rst="8">
            <comment>au_spk_gain_reg [3:0]
            </comment>
        </bits>
        <bits name="au_rcv_gain_reg" pos="7:4" access="rw" rst="8">
            <comment>au_rcv_gain_reg [3:0]
            </comment>
        </bits>
        <bits name="au_head_gain_reg" pos="3:0" access="rw" rst="8">
            <comment>au_head_gain_reg [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="usb_control_04H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="von_dac_bit" pos="15:14" access="rw" rst="0">
            <comment>von_dac_bit [1:0]
            </comment>
        </bits>
        <bits name="vsw_dac_bit" pos="13:12" access="rw" rst="0">
            <comment>vsw_dac_bit [1:0]
            </comment>
        </bits>
        <bits name="ibit_dac" pos="11:9" access="rw" rst="0">
            <comment>ibit_dac [2:0]
            </comment>
        </bits>
        <bits name="reserved" pos="8:7" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
        <bits name="usb_ctrl" pos="6:4" access="rw" rst="1">
            <comment>usb_ctrl [2:0]
            </comment>
        </bits>
        <bits name="usb_vreg_bit" pos="3:1" access="rw" rst="4">
            <comment>usb_vreg_bit [2:0]
            </comment>
        </bits>
        <bits name="pd_usb" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_05H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="mb_sel_bit" pos="15:14" access="rw" rst="2">
            <comment>mb_sel_bit [1:0]
            </comment>
        </bits>
        <bits name="mic_chop_en" pos="13" access="rw" rst="1">
        </bits>
        <bits name="mic_hpf_mode_en" pos="12" access="rw" rst="0">
        </bits>
        <bits name="miccap_mode_en" pos="11" access="rw" rst="0">
        </bits>
        <bits name="test_en_adc" pos="10" access="rw" rst="0">
        </bits>
        <bits name="mash_en_adc" pos="9" access="rw" rst="1">
        </bits>
        <bits name="reserved" pos="8:6" access="rw" rst="0">
            <comment>reserved [2:0]
            </comment>
        </bits>
        <bits name="micin_ibpga_en_dr" pos="5" access="rw" rst="0">
        </bits>
        <bits name="micin_ibpga_en_reg" pos="4" access="rw" rst="0">
        </bits>
        <bits name="muxin_left_en_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="muxin_left_en_reg" pos="2" access="rw" rst="1">
        </bits>
        <bits name="muxin_right_en_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="muxin_right_en_reg" pos="0" access="rw" rst="1">
        </bits>
    </reg>
    <reg name="pll_setting_1_06H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="mic_std_en_dr" pos="15" access="rw" rst="0">
        </bits>
        <bits name="mic_std_en_reg" pos="14" access="rw" rst="0">
        </bits>
        <bits name="mic_aux_en_dr" pos="13" access="rw" rst="0">
        </bits>
        <bits name="mic_aux_en_reg" pos="12" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="11" access="rw" rst="1">
        </bits>
        <bits name="hp_dischg_res_bit" pos="10:9" access="rw" rst="3">
            <comment>vbit_neg1 [1:0]
            </comment>
        </bits>
        <bits name="clk_sel_bit_neg1" pos="8:7" access="rw" rst="3">
            <comment>clk_sel_bit_neg1 [1:0]
            </comment>
        </bits>
        <bits name="hp_cap_mode_en" pos="6" access="rw" rst="0">
        </bits>
        <bits name="pd_hp_cap_dr" pos="5" access="rw" rst="0">
        </bits>
        <bits name="pd_hp_cap_reg" pos="4" access="rw" rst="0">
        </bits>
        <bits name="pd_neg1_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="pd_neg1_reg" pos="2" access="rw" rst="0">
        </bits>
        <bits name="boost_bp_mic_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="boost_bp_mic_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="pll_setting_2_07H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="mcpga_gain_bit_dr" pos="15" access="rw" rst="0">
        </bits>
        <bits name="mcpga_gain_bit_reg" pos="14:12" access="rw" rst="4">
            <comment>mcpga_gain_bit_reg [2:0]
            </comment>
        </bits>
        <bits name="reci_gain_bit_dr" pos="11" access="rw" rst="0">
        </bits>
        <bits name="reci_gain_bit_reg" pos="10:8" access="rw" rst="4">
            <comment>reci_gain_bit_reg [2:0]
            </comment>
        </bits>
        <bits name="hp_gain_bit_dr" pos="7" access="rw" rst="0">
        </bits>
        <bits name="hp_gain_bit_reg" pos="6:4" access="rw" rst="4">
            <comment>hp_gain_bit_reg [2:0]
            </comment>
        </bits>
        <bits name="spk_gain_bit_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="spk_gain_bit_reg" pos="2:0" access="rw" rst="4">
            <comment>spk_gain_bit_reg [2:0]
            </comment>
        </bits>
    </reg>
    <reg name="linein_setting_08H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="hp_rcv_mute_enable" pos="15" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="14:4" access="rw" rst="0">
            <comment>reserved [10:0]
            </comment>
        </bits>
        <bits name="adc_pd_sel_adc" pos="3" access="rw" rst="0">
        </bits>
        <bits name="mic_to_pa_mode" pos="2" access="rw" rst="0">
        </bits>
        <bits name="linein_to_mic_mode" pos="1" access="rw" rst="0">
        </bits>
        <bits name="linein_to_pa_mode" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="codec_ldo_setting_1_09H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="pd_all_dr" pos="15" access="rw" rst="0">
        </bits>
        <bits name="pd_all_reg" pos="14" access="rw" rst="1">
        </bits>
        <bits name="pd_adc_dr" pos="13" access="rw" rst="0">
        </bits>
        <bits name="pd_adc_reg" pos="12" access="rw" rst="1">
        </bits>
        <bits name="pd_micbias_dr" pos="11" access="rw" rst="0">
        </bits>
        <bits name="pd_micbias_reg" pos="10" access="rw" rst="1">
        </bits>
        <bits name="pu_dac_dr" pos="9" access="rw" rst="0">
        </bits>
        <bits name="pu_dac_reg" pos="8" access="rw" rst="1">
        </bits>
        <bits name="hp_dischg_out_dis_dr" pos="7" access="rw" rst="0">
        </bits>
        <bits name="hp_dischg_out_dis_reg" pos="6" access="rw" rst="1">
        </bits>
        <bits name="pa_enb_reci_dr" pos="5" access="rw" rst="0">
        </bits>
        <bits name="pa_enb_reci_reg" pos="4" access="rw" rst="1">
        </bits>
        <bits name="pa_enb_hp_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="pa_enb_hp_reg" pos="2" access="rw" rst="1">
        </bits>
        <bits name="reset_mux_en_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="reset_mux_en_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="codec_ldo_setting_2_0AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="vcom_mode" pos="15:13" access="rw" rst="6">
            <comment>vcom_mode [2:0]
            </comment>
        </bits>
        <bits name="vref_mode" pos="12:10" access="rw" rst="0">
            <comment>vref_mode [2:0]
            </comment>
        </bits>
        <bits name="isel_bit_b" pos="9:8" access="rw" rst="2">
            <comment>isel_bit_b [1:0]
            </comment>
        </bits>
        <bits name="sel_bg_codec" pos="7" access="rw" rst="0">
        </bits>
        <bits name="reset_dac_dr" pos="6" access="rw" rst="0">
        </bits>
        <bits name="reset_dac_reg" pos="5:4" access="rw" rst="3">
            <comment>reset_dac_reg [1:0]
            </comment>
        </bits>
        <bits name="classg_enable_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="classg_enable_reg" pos="2" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="misc_setting_0BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="hp_mask_startup" pos="15" access="rw" rst="0">
        </bits>
        <bits name="dvdd_dac_bit" pos="14:13" access="rw" rst="0">
            <comment>dvdd_dac_bit [1:0]
            </comment>
        </bits>
        <bits name="reserved_analog" pos="12:10" access="rw" rst="0">
            <comment>reserved_analog [2:0]
            </comment>
        </bits>
        <bits name="reserved" pos="9:3" access="rw" rst="0">
            <comment>reserved [6:0]
            </comment>
        </bits>
        <bits name="NC" pos="2" access="rw" rst="0">
        </bits>
        <bits name="NC" pos="1" access="rw" rst="0">
        </bits>
        <bits name="hp_gain_pop" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="codec_mode_sel_0CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reci_dac_en_dr" pos="15" access="rw" rst="0">
        </bits>
        <bits name="reci_dac_en_reg" pos="14" access="rw" rst="0">
        </bits>
        <bits name="reci_linein_en_dr" pos="13" access="rw" rst="0">
        </bits>
        <bits name="reci_linein_en_reg" pos="12" access="rw" rst="0">
        </bits>
        <bits name="dac_mode_l_en_dr" pos="11" access="rw" rst="0">
        </bits>
        <bits name="dac_mode_l_en_reg" pos="10" access="rw" rst="0">
        </bits>
        <bits name="dac_mode_r_en_dr" pos="9" access="rw" rst="0">
        </bits>
        <bits name="dac_mode_r_en_reg" pos="8" access="rw" rst="0">
        </bits>
        <bits name="micdac_mode_en_dr" pos="7" access="rw" rst="0">
        </bits>
        <bits name="micdac_mode_en_reg" pos="6" access="rw" rst="0">
        </bits>
        <bits name="line_mode_en_dr" pos="5" access="rw" rst="0">
        </bits>
        <bits name="line_mode_en_reg" pos="4" access="rw" rst="0">
        </bits>
        <bits name="NC" pos="3" access="rw" rst="0">
        </bits>
        <bits name="NC" pos="2" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="1:0" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
    </reg>
    <reg name="codec_calibration_setting_0DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:9" access="rw" rst="0">
            <comment>reserved [6:0]
            </comment>
        </bits>
        <bits name="cal_bypass" pos="8" access="rw" rst="0">
        </bits>
        <bits name="resetn_cal_dr" pos="7" access="rw" rst="0">
        </bits>
        <bits name="resetn_cal_reg" pos="6" access="rw" rst="1">
        </bits>
        <bits name="cal_out_polartiy" pos="5" access="rw" rst="0">
        </bits>
        <bits name="cal_clk_inv" pos="4" access="rw" rst="0">
        </bits>
        <bits name="cal_bit_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="cal_bit_reg" pos="2:0" access="rw" rst="4">
            <comment>cal_bit_reg [2:0]
            </comment>
        </bits>
    </reg>
    <reg name="power_control_0EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reset_mic_dr" pos="15" access="rw" rst="0">
        </bits>
        <bits name="reset_mic_reg" pos="14" access="rw" rst="1">
        </bits>
        <bits name="reset_en_ad_dr" pos="13" access="rw" rst="1">
        </bits>
        <bits name="reset_en_ad_reg" pos="12" access="rw" rst="1">
        </bits>
        <bits name="reset_pa_reci_dr" pos="11" access="rw" rst="1">
        </bits>
        <bits name="reset_pa_reci_reg" pos="10" access="rw" rst="1">
        </bits>
        <bits name="reset_pa_hp_dr" pos="9" access="rw" rst="0">
        </bits>
        <bits name="reset_pa_hp_reg" pos="8" access="rw" rst="1">
        </bits>
        <bits name="NC" pos="7" access="rw" rst="0">
        </bits>
        <bits name="NC" pos="6" access="rw" rst="0">
        </bits>
        <bits name="rstn_codec_dr" pos="5" access="rw" rst="0">
        </bits>
        <bits name="rstn_codec_reg" pos="4" access="rw" rst="1">
        </bits>
        <bits name="adc_en_codec_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="adc_en_codec_reg" pos="2" access="rw" rst="0">
        </bits>
        <bits name="dac_en_codec_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="dac_en_codec_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="codec_reset_control_0FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:2" access="rw" rst="0">
        </bits>
        <bits name="register_resetn" pos="1" access="rw" rst="1">
        </bits>
        <bits name="soft_resetn" pos="0" access="rw" rst="1">
        </bits>
    </reg>
    <reg name="abb_8809_10H" protect="rw" >
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="7">
            <comment>reserved [2:0]
            </comment>
        </bits>
        <bits name="dcdc4_resetn_time_sel" pos="12:11" access="rw" rst="2">
            <comment>dcdc4_resetn_time_sel [1:0]
            </comment>
        </bits>
        <bits name="dcdc4_clkgen4_clk_sel" pos="10" access="rw" rst="0">
        </bits>
        <bits name="dcdc4_clkgen4_div_base" pos="9:2" access="rw" rst="128">
            <comment>dcdc4_clkgen4_div_base [7:0]
            </comment>
        </bits>
        <bits name="dcdc4_clkgen4_resetn_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="dcdc4_clkgen4_resetn_reg" pos="0" access="rw" rst="1">
        </bits>
    </reg>
    <reg name="abb_8809_11H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="dssi_inv" pos="15" access="rw" rst="1">
        </bits>
        <bits name="reserved" pos="14" access="rw" rst="1">
        </bits>
        <bits name="dcdc_clkgen3_clk_sel" pos="13" access="rw" rst="1">
        </bits>
        <bits name="dcdc_clkgen3_dither_ct" pos="12:10" access="rw" rst="0">
            <comment>dcdc_clkgen3_dither_ct [2:0]
            </comment>
        </bits>
        <bits name="dcdc_clkgen3_div_base" pos="9:2" access="rw" rst="128">
            <comment>dcdc_clkgen3_div_base [7:0]
            </comment>
        </bits>
        <bits name="dcdc_clkgen3_resetn_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="dcdc_clkgen3_resetn_reg" pos="0" access="rw" rst="1">
        </bits>
    </reg>
    <reg name="abb_8809_12H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="pu_ssi" pos="15" access="rw" rst="1">
        </bits>
        <bits name="dssi_ana_enable" pos="14" access="rw" rst="1">
        </bits>
        <bits name="dssi_stable_time_sel" pos="13:12" access="rw" rst="1">
            <comment>dssi_stable_time_sel [1:0]
            </comment>
        </bits>
        <bits name="dssi_lg_en_time_sel" pos="11:10" access="rw" rst="2">
            <comment>dssi_lg_en_time_sel [1:0]
            </comment>
        </bits>
        <bits name="spk_gain_sel_inv" pos="9" access="rw" rst="0">
        </bits>
        <bits name="spk_lowgain_en_l_dr" pos="8" access="rw" rst="0">
        </bits>
        <bits name="spk_lowgain_en_l_reg" pos="7" access="rw" rst="0">
        </bits>
        <bits name="spk_lowgain_en_r_dr" pos="6" access="rw" rst="0">
        </bits>
        <bits name="spk_lowgain_en_r_reg" pos="5" access="rw" rst="0">
        </bits>
        <bits name="pu_idet_dac" pos="4" access="rw" rst="0">
        </bits>
        <bits name="reset_padet_time_sel" pos="3:2" access="rw" rst="2">
            <comment>reset_padet_time_sel [1:0]
            </comment>
        </bits>
        <bits name="hp_vcom_res_en_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="hp_vcom_res_en_reg" pos="0" access="rw" rst="1">
        </bits>
    </reg>
    <reg name="abb_8809_13H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="pll_aux_clkout_en" pos="15:14" access="rw" rst="1">
            <comment>pll_aux_clkout_en [1:0]
            </comment>
        </bits>
        <bits name="reserved" pos="13:12" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
        <bits name="pll_aux_cpaux_bit" pos="11:9" access="rw" rst="4">
            <comment>pll_aux_cpaux_bit [2:0]
            </comment>
        </bits>
        <bits name="pll_aux_filter_ibit" pos="8:6" access="rw" rst="4">
            <comment>pll_aux_filter_ibit [2:0]
            </comment>
        </bits>
        <bits name="pll_aux_cp_bit" pos="5:3" access="rw" rst="4">
            <comment>pll_aux_cp_bit [2:0]
            </comment>
        </bits>
        <bits name="pll_aux_int_mode" pos="2" access="rw" rst="1">
        </bits>
        <bits name="pll_aux_sdm_clk_sel_rst" pos="1" access="rw" rst="1">
        </bits>
        <bits name="pll_aux_sdm_clk_sel_nor" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_14H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="pll_aux_lock" pos="15" access="r" rst="0">
        </bits>
        <bits name="pll_aux_sdm_clk_test_en" pos="14" access="rw" rst="0">
        </bits>
        <bits name="pll_aux_fefmulti2" pos="13" access="rw" rst="0">
        </bits>
        <bits name="pll_aux_vco_high_test" pos="12" access="rw" rst="0">
        </bits>
        <bits name="pll_aux_vco_low_test" pos="11" access="rw" rst="0">
        </bits>
        <bits name="pll_aux_test_en" pos="10" access="rw" rst="0">
        </bits>
        <bits name="pll_aux_vreg_bit" pos="9:6" access="rw" rst="8">
            <comment>pll_aux_vreg_bit [3:0]
            </comment>
        </bits>
        <bits name="pd_pll_aux_dr" pos="5" access="rw" rst="0">
        </bits>
        <bits name="pd_pll_aux_reg" pos="4" access="rw" rst="1">
        </bits>
        <bits name="pll_aux_reset_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="pll_aux_reset_reg" pos="2" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="1:0" access="rw" rst="3">
            <comment>reserved [1:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_15H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm2_freq" pos="15:0" access="rw" rst="12">
            <comment>bbpll_sdm2_freq [27:12]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_16H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:12" access="rw" rst="0">
            <comment>reserved [3:0]
            </comment>
        </bits>
        <bits name="bbpll_sdm2_freq" pos="11:0" access="rw" rst="0">
            <comment>bbpll_sdm2_freq [11:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_17H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm2_int_dec_sel" pos="15:13" access="rw" rst="0">
            <comment>bbpll_sdm2_int_dec_sel [2:0]
            </comment>
        </bits>
        <bits name="bbpll_sdm2_dither_bypass" pos="12" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm2_ss_en" pos="11" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm2_ss_squre_tri_sel" pos="10" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm2_reserved" pos="9:2" access="rw" rst="0">
            <comment>bbpll_sdm2_reserved [7:0]
            </comment>
        </bits>
        <bits name="bbpll_sdm2_resetn_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm2_resetn_reg" pos="0" access="rw" rst="1">
        </bits>
    </reg>
    <reg name="abb_8809_18H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm2_ss_devi_ct" pos="15:8" access="rw" rst="128">
            <comment>bbpll_sdm2_ss_devi_ct [7:0]
            </comment>
        </bits>
        <bits name="bbpll_sdm2_ss_peri_ct" pos="7:0" access="rw" rst="128">
            <comment>bbpll_sdm2_ss_peri_ct [7:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_19H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="clk52m_double_en" pos="15" access="rw" rst="0">
        </bits>
        <bits name="clk52m_r_ctrl" pos="14:12" access="rw" rst="4">
        </bits>
        <bits name="clk52m_ibias_ctrl" pos="11" access="rw" rst="0">
        </bits>
        <bits name="clk52m_vbias_ctrl" pos="10:9" access="rw" rst="2">
        </bits>
        <bits name="reserved" pos="8:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_1AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_1BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_1CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_1DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_1EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_1FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:1" access="rw" rst="0">
        </bits>
        <bits name="spi_out_sel" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_120H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="61680">
        </bits>
    </reg>
    <reg name="abb_8809_121H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="61680">
        </bits>
    </reg>
    <reg name="abb_8809_122H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_123H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="2">
        </bits>
    </reg>
    <reg name="abb_8809_124H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="23168">
        </bits>
    </reg>
    <reg name="abb_8809_125H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="acomp_rate" pos="15:0" access="rw" rst="37972">
        </bits>
    </reg>
    <reg name="abb_8809_126H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="1320">
        </bits>
    </reg>
    <reg name="abb_8809_127H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="ramp_ind" pos="15" access="rw" rst="0">
        </bits>
        <bits name="ramp_bypass" pos="14" access="rw" rst="1">
        </bits>
        <bits name="rampup_step" pos="13:7" access="rw" rst="10">
            <comment>rampup_step [6:0]
            </comment>
        </bits>
        <bits name="rampdn_step" pos="6:0" access="rw" rst="3">
            <comment>rampdn_step [6:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_128H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="cnt_adc_clk" pos="15:13" access="rw" rst="0">
            <comment>cnt_adc_clk [2:0]
            </comment>
        </bits>
        <bits name="cnt_adc_clk" pos="12:6" access="rw" rst="24">
            <comment>cnt_adc_clk [6:0]
            </comment>
        </bits>
        <bits name="s_adc_osr_sel" pos="5:4" access="rw" rst="0">
            <comment>s_adc_osr_sel [1:0]
            </comment>
        </bits>
        <bits name="reserved" pos="3" access="rw" rst="0">
        </bits>
        <bits name="sleep_mode" pos="2" access="rw" rst="0">
        </bits>
        <bits name="fm_clK_sel" pos="1" access="rw" rst="0">
            <comment>should be set to 1
            </comment>
        </bits>
        <bits name="fm_mode" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_129H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0">
        </bits>
        <bits name="s_phone_sel" pos="12" access="rw" rst="0">
        </bits>
        <bits name="s_dwa_en" pos="11" access="rw" rst="1">
        </bits>
        <bits name="s_dither_bypass" pos="10" access="rw" rst="0">
        </bits>
        <bits name="mash_en_adc" pos="9" access="rw" rst="1">
        </bits>
        <bits name="s_adc_in_inv" pos="8" access="rw" rst="0">
        </bits>
        <bits name="dac_clk_inv" pos="7" access="rw" rst="0">
        </bits>
        <bits name="adc_clk_inv" pos="6" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_clk_div2_en" pos="5" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_clk_int" pos="4" access="rw" rst="0">
        </bits>
        <bits name="s_isphone" pos="3" access="rw" rst="0">
        </bits>
        <bits name="s_codec_en" pos="2" access="rw" rst="0">
        </bits>
        <bits name="s_hpf_bypass" pos="1" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_12AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="s_adc_dvst_ctl" pos="15:12" access="rw" rst="15">
            <comment>s_adc_dvst_ctl [3:0]
            </comment>
        </bits>
        <bits name="sdm_gain" pos="11:10" access="rw" rst="2">
            <comment>sdm_gain [1:0]
            </comment>
        </bits>
        <bits name="dither_gain" pos="9:8" access="rw" rst="1">
            <comment>dither_gain [4:3]
            </comment>
        </bits>
        <bits name="s_dac_volume_mute" pos="7" access="rw" rst="0">
        </bits>
        <bits name="s_dac_volume" pos="6:2" access="rw" rst="24">
            <comment>s_dac_volume [4:0]
            </comment>
        </bits>
        <bits name="s_mute_l" pos="1" access="rw" rst="0">
        </bits>
        <bits name="s_mute_r" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_12BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="dither_gain" pos="15:13" access="rw" rst="0">
            <comment>dither_gain [2:0]
            </comment>
        </bits>
        <bits name="s_adc_volume" pos="12:9" access="rw" rst="7">
            <comment>s_adc_volume [3:0]
            </comment>
        </bits>
        <bits name="s_dac1k" pos="8" access="rw" rst="0">
        </bits>
        <bits name="s_loop" pos="7" access="rw" rst="0">
        </bits>
        <bits name="tports_codec_test_en" pos="6" access="rw" rst="0">
        </bits>
        <bits name="tports_sel" pos="5:1" access="rw" rst="0">
            <comment>tports_sel [4:0]
            </comment>
        </bits>
        <bits name="s_adc_dvst_ctl" pos="0" access="rw" rst="0">
            <comment>s_adc_dvst_ctl [4]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_12CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="s_cnt_constant" pos="15:12" access="rw" rst="0">
            <comment>s_cnt_constant [3:0]
            </comment>
        </bits>
        <bits name="s_dac_gain" pos="11:10" access="rw" rst="0">
            <comment>s_dac_gain [1:0]
            </comment>
        </bits>
        <bits name="reserved" pos="9" access="rw" rst="0">
        </bits>
        <bits name="s_dac_osr_sel" pos="8:7" access="rw" rst="0">
            <comment>s_dac_osr_sel [1:0]
            </comment>
        </bits>
        <bits name="reset_reg" pos="6:5" access="rw" rst="0">
            <comment>reset_reg [1:0]
            </comment>
        </bits>
        <bits name="reserved" pos="4:3" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="2:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_12DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:11" access="rw" rst="0">
        </bits>
        <bits name="s_cnt_constant" pos="10:0" access="rw" rst="0">
            <comment>s_cnt_constant [14:4]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_12EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="tports" pos="15:0" access="rw" rst="0">
            <comment>tports [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_12FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="func_id" pos="15:0" access="rw" rst="52716">
            <comment>func_id [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_130H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0">
        </bits>
        <bits name="deemph_b0" pos="12:0" access="rw" rst="0">
            <comment>deemph_b0 [12:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_131H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0">
        </bits>
        <bits name="deemph_b1" pos="12:0" access="rw" rst="0">
            <comment>deemph_b1 [12:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_132H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0">
        </bits>
        <bits name="deemph_a1" pos="12:0" access="rw" rst="0">
            <comment>deemph_a1 [12:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_133H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0">
        </bits>
        <bits name="record_16k" pos="12" access="rw" rst="0">
        </bits>
        <bits name="record_32k" pos="11" access="rw" rst="0">
        </bits>
        <bits name="adc_lpf_bypass" pos="10" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_flg_code" pos="9:2" access="rw" rst="234">
        </bits>
        <bits name="clkgen_mode" pos="1:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_134H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_cnt_th" pos="12:9" access="rw" rst="3">
            <comment>earphone_det_cnt_th [3:0]
            </comment>
        </bits>
        <bits name="earphone_det_th_l" pos="8:0" access="rw" rst="282">
            <comment>earphone_det_th_l [13:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_135H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:11" access="rw" rst="0">
        </bits>
        <bits name="spk_gain_sel" pos="10:9" access="rw" rst="0">
            <comment>spk_gain_sel [1:0]
            </comment>
        </bits>
        <bits name="earphone_det_th_h" pos="8:0" access="rw" rst="318">
            <comment>earphone_det_th_h [8:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_136H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_137H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_138H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="lpf20_cf_a2" pos="15:0" access="rw" rst="16097">
        </bits>
    </reg>
    <reg name="abb_8809_139H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="lpf20_cf_a1" pos="15:0" access="rw" rst="33062">
        </bits>
    </reg>
    <reg name="abb_8809_13AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:11" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_lpf20_bypass" pos="10" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_hpf_ct_u" pos="9:8" access="rw" rst="2">
        </bits>
        <bits name="earphone_det_gain" pos="7:6" access="rw" rst="0">
        </bits>
        <bits name="lpf20_cf_b0b2" pos="5:0" access="rw" rst="5">
        </bits>
    </reg>
    <reg name="abb_8809_13BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_13CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_coef" pos="15:0" access="rw" rst="0">
            <comment>earphone_det_coef [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_13DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="tone20_gen_enable" pos="15" access="rw" rst="1">
        </bits>
        <bits name="dac_hpf_mode" pos="14" access="rw" rst="0">
        </bits>
        <bits name="nothch20_bypass" pos="13" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_bypass" pos="12" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_sel" pos="11" access="rw" rst="1">
        </bits>
        <bits name="earphone_det_th" pos="10:4" access="rw" rst="10">
            <comment>earphone_det_th [6:0]
            </comment>
        </bits>
        <bits name="earphone_det_coef" pos="3:0" access="rw" rst="0">
            <comment>earphone_det_coef [19:16]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_13EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_a1" pos="15:0" access="rw" rst="0">
            <comment>earphone_det_a1 [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_13FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_b1" pos="15:8" access="rw" rst="0">
            <comment>earphone_det_b1 [7:0]
            </comment>
        </bits>
        <bits name="earphone_det_a1" pos="7:0" access="rw" rst="0">
            <comment>earphone_det_a1 [23:16]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_110H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_b1" pos="15:0" access="rw" rst="1024">
            <comment>earphone_det_b1 [23:8]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_111H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_time" pos="15:0" access="rw" rst="1200">
            <comment>earphone_det_time [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_112H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:8" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_flag" pos="7" access="rw" rst="0">
        </bits>
        <bits name="earphone_det_rssi" pos="6:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="abb_8809_113H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0">
        </bits>
        <bits name="gain_ctrl_th" pos="12:6" access="rw" rst="10">
            <comment>gain_ctrl_th [6:0]
            </comment>
        </bits>
        <bits name="gain_ctrl_num" pos="5:0" access="rw" rst="30">
            <comment>gain_ctrl_num [5:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_114H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="nothch20_cf_b0a2" pos="15:12" access="rw" rst="0">
            <comment>nothch20_cf_b0a2 [3:0]
            </comment>
        </bits>
        <bits name="nothch20_cf_b1a1" pos="11:0" access="rw" rst="0">
            <comment>nothch20_cf_b1a1 [19:8]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_115H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="nothch20_cf_b0a2" pos="15:0" access="rw" rst="0">
            <comment>nothch20_cf_b0a2 [19:4]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_116H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="nothch20_cf_a2" pos="15:4" access="rw" rst="0">
            <comment>nothch20_cf_a2 [11:0]
            </comment>
        </bits>
        <bits name="reserved" pos="3:0" access="rw" rst="0">
            <comment>reserved [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_117H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="nothch20_cf_b1a1" pos="15:8" access="rw" rst="0">
            <comment>nothch20_cf_b1a1 [7:0]
            </comment>
        </bits>
        <bits name="nothch20_cf_a2" pos="7:0" access="rw" rst="0">
            <comment>nothch20_cf_a2 [19:12]
            </comment>
        </bits>
    </reg>
    <reg name="abb_8809_118H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="notch20_cf_bl" pos="15:0" access="rw" rst="0">
            <comment>for hpf mode only
            </comment>
        </bits>
    </reg>

</module>
</archive>


<archive relative = "aif.xml">
<module name="aif" category="Baseband">

  <enum name="AIF_Sampling_Rate">
      <entry name="AIF_8k"/>
      <entry name="AIF_11k025"/>
      <entry name="AIF_12k"/>
      <entry name="AIF_16k"/>
      <entry name="AIF_22k05"/>
      <entry name="AIF_24k"/>
      <entry name="AIF_32k"/>
      <entry name="AIF_44k1"/>
      <entry name="AIF_48k"/>
  </enum>
    
  <var  name="AIF_RX_FIFO_SIZE"    value="4"  />
  <var  name="AIF_TX_FIFO_SIZE"    value="4"  />

  <reg protect="w" name="data">
    <bits access="rw" name="data0" pos="15:0" rst="-">
        <comment> This reg contains data to be read or written by IFC. 
            In mono mode, data0 is before data1.
            In stereo mode, data0 is in left channel.  
        </comment> 
    </bits>
    <bits access="rw" name="data1" pos="31:16" rst="-">
        <comment> This reg contains data to be read or written by IFC. 
            In mono mode, data1 is after data0.
            In stereo mode, data1 is in right channel.  
      </comment> 
    </bits>
  </reg>

  <reg protect="rw" name="ctrl">
    <bits access="rw" name="Enable" pos="0" rst="0">
        <options>
            <default/>
            <option name="ENABLE" value="1"/>
            <option name="DISABLE" value="0"/>
        </options>
        
        <comment> Audio Interface Enable. 
            <br /> 0: if AIF_Tone[0] is also 0, AIF is disabled. 
            <br /> 1 = AIF Enabled. If AIF_Tone[0] is also '1', Tx fifo continue to fetch and distribute data 
                   from IFC when tone is enable. However, these data are not used.
        </comment> 
    </bits>

    <bits access="rw" name="Tx Off" pos="4" rst="0">
        <options>
            <default/>
            <option name="Tx On" value="0"/>
            <option name="Tx Off" value="1"/>
        </options>
        
        <comment> Disable AIF Tx functions. Important: if you want to do record only, you must set this bit otherwise AIF state machine will not start. 
            <br /> 0 = Both Tx Rx enabled.  
            <br /> 1 = Rx enabled only, Tx disabled. 
        </comment> 
    </bits>  

    <bits access="rs" name="Parallel Out Set" pos="8" rst="0">
        <options>
            <default/>
            <option name="SERL" value="0"/>            
            <option name="PARA" value="1"/>            
        </options>
        
        <comment> Selects parallel audio interface connected to analog front-end. 
            <br /> 0 = serial output.  
            <br /> 1 = parallel output.  
        </comment> 
    </bits>  
    
    <bits access="rc" name="Parallel Out Clr" pos="9" rst="0">
        <options>
            <default/>
            <option name="SERL" value="0"/>            
            <option name="PARA" value="1"/>            
        </options>
        
        <comment> Selects parallel audio interface connected to analog front-end. 
            <br /> 0 = serial output.  
            <br /> 1 = parallel output.  
        </comment> 
    </bits>  

    <bits access="rs" name="Parallel In Set" pos="10" rst="0">
        <options>
            <default/>
            <option name="SERL" value="0"/>            
            <option name="PARA" value="1"/>            
        </options>
        
        <comment> Selects parallel audio interface connected to analog front-end. 
            <br /> 0 = serial input.  
            <br /> 1 = parallel input.  
        </comment> 
    </bits>  
    
    <bits access="rc" name="Parallel In Clr" pos="11" rst="0">
        <options>
            <default/>
            <option name="SERL" value="0"/>            
            <option name="PARA" value="1"/>            
        </options>
        
        <comment> Selects parallel audio interface connected to analog front-end. 
            <br /> 0 = serial input.  
            <br /> 1 = parallel input.  
        </comment> 
    </bits>  
    <bits access="rw" name="Tx Stb Mode" pos="12" rst="0">
        <comment> In parallel mode, select AIF Tx Strobe mode. Reserved in serial mode.
            <br /> 0 = Tx STB edge is in middle of data.  
            <br /> 1 = Tx STB edge is aligned to data edge. 
        </comment> 
    </bits>      
    <bits access="rc" name="out underflow" pos="16" rst="0">
        <comment> This bit indicates if the AIF had needed some data while the Out Fifo was empty.
            In case of data famine, the last available data will be sent again.
            <br /> Write one to clear the out_underflow status bit. This bit is auto clear. 
        </comment> 
    </bits>      

    <bits access="rc" name="in overflow" pos="17" rst="0">
        <comment> This bit indicates if the AIF had received some data while the Input Fifo was full.
            If the Fifo In is full, the newly received data will be lost. 
            <br /> Write one to clear the in_overflow status bit. This bit is auto clear.
        </comment> 
    </bits>       

    <bits access="rw" name="Loop back" pos="31" rst="0">
        <options>
            <default/>
            <option name="NORMAL" value="0"/>
            <option name="LOOPBACK" value="1"/>
        </options>
     
        <comment> Sets the loop back mode. The feature is for debug only and can not work in DAI mode. 
        </comment> 
    </bits>   
    
  </reg>

  
  <reg protect="rw" name="serial_ctrl">

    <bits access="rw" name="SERIAL MODE" pos="1:0" rst="00">
        <options>
            <default/>
            <option name="I2S_PCM" value="0"/>
            <option name="VOICE" value="1"/>
            <option name="DAI" value="2"/>
        </options>
        
        <comment> Configure serial AIF mode. "11" is reserved. 
            <br /> 
            <br /> When mode is set DAI, the bit Master Mode should be set to '1', 
            bit Endian_L set to '0'. Data should be sent out on falling edge, which 
            requires either Bclk_Pol = '0' and Half_Cycle_DLY = '1' or Bclk_Pol = '1'
            and Half_Cycle_DLY = '0'. Bits Tx_DLY and BCKOut_Gate must be configured 
            to '0' and '1'.
            <br /> The DAI mode must NOT be modified after AIF is enabled. 
            <br />             
        </comment> 

    </bits>      
    <bits access="rw" name="I2S IN SEL" pos="3:2" rst="0">
        <options>
            <default/>
            <option name="I2S IN 0" value="0"/>
            <option name="I2S IN 1" value="1"/>
            <option name="I2S IN 2" value="2"/>
        </options>
        
        <comment> Select AIF I2S input. 
        </comment> 
    </bits>       
    
    <bits access="rw" name="MASTER MODE" pos="4" rst="1">
        <options>
            <default/>
            <option name="SLAVE" value="0"/>
            <option name="MASTER" value="1"/>
        </options>
        
        <comment> configure AIF works in master mode (LRCLK and BCK timing signals are generated internally)
            or slave mode (LRCLK and BCK timing signals are generated externally). 
        </comment> 
    </bits>  

    <bits access="rw" name="LSB" pos="5" rst="0">
        <options>
            <default/>
            <option name="MSB" value="0"/>
            <option name="LSB" value="1"/>
        </options>
        
        <comment> When high, the output data format is with the least significant bit first. 
        </comment> 
    </bits>

    <bits access="rw" name="LRCK Pol" pos="6" rst="0">
        <options>
            <default/>
            <option name="LEFT_H_RIGHT_L" value="0"/>
            <option name="LEFT_L_RIGHT_H" value="1"/>
        </options>
        
        <comment> configure LRCK polarity. 
            <br /> 0 = high level on LRCK means left channel, low level on LRCK means right channel.
            <br /> 1 = high level on LRCK means right channel, low level on LRCK means left channel. 
            <br />
            <br /> Note: this bit should be set to '0' (LEFT_H_RIGHT_L) in voice mode.
        </comment> 
      </bits>

    <bits access="rw" name="LR justified" pos="7" rst="0">
        <options>
        </options>
        
        <comment> . 
        </comment> 
    </bits>

    <bits access="rw" name="Rx_DLY" pos="9:8" rst="0">
        <options>
            <default/>
            <option name="ALIGN" value="0"/>
            <option name="DLY_1" value="1"/>
            <option name="DLY_2" value="2"/>
            <option name="DLY_3" value="3"/>
        </options>
        
        <comment> Indicates the delay between serial data in MSB and LRCK edge. 
            <br /> "00" = Digital audio in MSB is aligned with LRCLK edge.  
            <br /> "01" = Digital audio in MSB is 1 cycle delayed to LRCLK edge.
            <br /> "10" = Digital audio in MSB is 2 cycle delayed to LRCLK edge.
            <br /> "11" = Digital audio in MSB is 3 cycle delayed to LRCLK edge.
        </comment> 
    </bits>

    <bits access="rw" name="Tx_DLY" pos="10" rst="0">
        <options>
            <default/>
            <option name="ALIGN" value="0"/>
            <option name="DLY_1" value="1"/>
        </options>
        
        <comment> configure the delay between serial data out MSB and LRCK edge. 
            <br /> "0" = Digital audio out MSB is aligned with LRCLK edge.  
            <br /> "1" = Digital audio out MSB is 1 cycle delayed to LRCLK edge.
        </comment> 
    </bits>

    <bits access="rw" name="Tx_DLY_s" pos="11" rst="0">
        <options>
            <default/>
            <option name="NO DLY" value="0"/>
            <option name="DLY" value="1"/>
        </options>
        
        <comment> ONLY for slave mode: configure 1 cycle supplementary Tx delay. 
            <br /> "0" = No supplementary Tx delay.  
            <br /> "1" = One Cycle supplementary Tx delay.
        </comment> 
    </bits>
    
    <bits access="rw" name="Tx_Mode" pos="13:12" rst="0">
        <options>
            <default/>
            <option name="STEREO_STEREO" value="0"/>
            <option name="MONO_STEREO_CHAN_L" value="1"/>
            <option name="MONO_STEREO_DUPLI" value="2"/>
            <option name="STEREO_TO_MONO" value="3"/>
        </options>
        <comment> Configure mono or stereo format for Audio data out.
                  This field is used both in serial mode or in parallel EXT mode. 
            <br /> "00" = stereo input from IFC, stereo output to pin.  
            <br /> "01" = mono input from IFC, stereo output in left channel to pin. 
                          This value is reserved in parallel EXT mode.
            <br /> "10" = mono input from IFC, stereo output duplicate in both channels to pin.  
            <br /> "11" = stereo input from IFC, mono output to left and right channel. This mode is only used for parallel stereo interface.
            <br />
            <br /> if AIF works in DAI or Voice mode, always select "00" mode STEREO_STEREO.
        </comment> 
    </bits>

    <bits access="rw" name="Rx Mode" pos="14" rst="0">
        <options>
            <default/>
            <option name="STEREO_STEREO" value="0"/>
            <option name="STEREO_MONO_FROM_L" value="1"/>
        </options>
        <comment> Configure mono or stereo format for Audio data in. 
            <br /> 0 = stereo input from pin, stereo output to IFC. 
            <br /> 1 = stereo input from pin, mono input to IFC selected from left channel.
            <br />
            <br /> Users can change LRCK polarity to choose mono input from right channel.
        </comment> 
    </bits>
        
    <bits access="rw" name="BCK LRCK" pos="20:16" rst="0">
        <options>
            <default/>
            <option name="BCK LRCK 16" value="0"/>
            <option name="BCK LRCK 17" value="1"/>
            <option name="BCK LRCK 18" value="2"/>
            <option name="BCK LRCK 19" value="3"/>
            <option name="BCK LRCK 20" value="4"/>
            <option name="BCK LRCK 21" value="5"/>
            <option name="BCK LRCK 22" value="6"/>
            <option name="BCK LRCK 23" value="7"/>
            <option name="BCK LRCK 24" value="8"/>
            <option name="BCK LRCK 25" value="9"/>
            <option name="BCK LRCK 26" value="10"/>
            <option name="BCK LRCK 27" value="11"/>
            <option name="BCK LRCK 28" value="12"/>
            <option name="BCK LRCK 29" value="13"/>
            <option name="BCK LRCK 30" value="14"/>
            <option name="BCK LRCK 31" value="15"/>
            <option name="BCK LRCK 32" value="16"/>
            <option name="BCK LRCK 33" value="17"/>
            <option name="BCK LRCK 34" value="18"/>
            <option name="BCK LRCK 35" value="19"/>
            <option name="BCK LRCK 36" value="20"/>
            <option name="BCK LRCK 37" value="21"/>
            <option name="BCK LRCK 38" value="22"/>
            <option name="BCK LRCK 39" value="23"/>
            <option name="BCK LRCK 40" value="24"/>
            <option name="BCK LRCK 41" value="25"/>
            <option name="BCK LRCK 42" value="26"/>
            <option name="BCK LRCK 43" value="27"/>
            <option name="BCK LRCK 44" value="28"/>
            <option name="BCK LRCK 45" value="29"/>
            <option name="BCK LRCK 46" value="30"/>
            <option name="BCK LRCK 47" value="31"/>
            
        </options>
            
        <comment> configure the ratio of BCK and LRCK cycle from 16 to 31.
            <br /> Voice_Mode: "XXXX": each sample takes 16 + "XXXX" BCLK cycle.  
            <br /> Audio_Mode: "XXXX": each sample takes 2*(16 + "XXXX) BCLK cycle. 2 times than Voice Mode because in audio mode each sample occupies two channels. 
        </comment> 
    </bits>  

    <bits access="rw" name="Bck Pol" pos="24" rst="0">
        <options>
            <default/>
            <option name="NORMAL" value="0"/>
            <option name="INVERT" value="1"/>
        </options>
        
        <comment> if Master Mode, invert BCLK out. if slave Mode, invert BCLK in.
        </comment> 
    </bits>   

    <bits access="rw" name="Output Half Cycle DLY" pos="25" rst="0">
        <options>
            <default/>
            <option name="NO DLY" value="0"/>
            <option name="DLY" value="1"/>
        </options>
        
        <comment> delayed Audio output data or LRCK by half cycle.
        </comment> 
    </bits> 

    <bits access="rw" name="Input Half Cycle DLY" pos="26" rst="0">
        <options>
            <default/>
            <option name="NO DLY" value="0"/>
            <option name="DLY" value="1"/>
        </options>
        
        <comment> delayed Audio input data by half cycle.
        </comment> 
    </bits>     
    
    <bits access="rw" name="BckOut Gate" pos="28" rst="0">
        <options>
            <default/>
            <option name="NO GATE" value="0"/>
            <option name="GATED" value="1"/>
        </options>
        
        <comment> Sets the BckOut gating. This bit decide if AIF continue to output BCK clock after 16-bit data has been sent.
        </comment> 
    </bits>       
    
  </reg>
  

  <reg protect="rw" name="tone">
    <bits access="rw" name="Enable H" pos="0" rst="0">
        <options>
            <default/>
            <option name="DISABLE" value="0"/>
            <option name="ENABLE" value="1"/>
        </options>
        
        <comment>When this bit is set, the audio interface is enabled and a comfort tone or DTMF tone is output 
            on the audio interface instead of the regular data, even if the AIF_CTRL[0] enable bit is 0. 
            <br /> 0 = AIF is disabled if the AIF_CTRL[0] is also 0. 
            <br /> 1 = AIF is enabled and generates a tone.
        </comment>
    </bits>

    <bits access="rw" name="Tone Select" pos="1" rst="0">
        <options>
            <default/>
            <option name="DTMF" value="0"/>
            <option name="COMFORT TONE" value="1"/>
        </options>
        
        <comment>Select whether a DTMF of a comfort tone is generated. 
        </comment>
    </bits>

    <bits access="rw" name="DTMF Freq Col" pos="5:4" rst="0">
        <options>
            <default/>
            <option name="1209 Hz" value="0"/>
            <option name="1336 Hz" value="1"/>
            <option name="1477 Hz" value="2"/>
            <option name="1633 Hz" value="3"/>
        </options>  
        
        <comment>Frequency of the first DTMF sine wave.
        </comment>
    </bits>

    <bits access="rw" name="DTMF Freq Row" pos="7:6" rst="0">
        <options>
            <default/>
            <option name="697 Hz" value="0"/>
            <option name="770 Hz" value="1"/>
            <option name="852 Hz" value="2"/>
            <option name="941 Hz" value="3"/>
        </options>  
        
        <comment>Frequency of the second DTMF sine wave. 
        </comment>
    </bits>
        
    <bits access="rw" name="Comfort Freq" pos="9:8" rst="0">
        <options>
            <default/>
            <option name="425 Hz" value="0"/>
            <option name="950 Hz" value="1"/>
            <option name="1400 Hz" value="2"/>
            <option name="1800 Hz" value="3"/>
        </options>  
        
        <comment>Frequency of comfort tone. 
        </comment>
    </bits>
    
    
    <bits access="rw" name="Tone Gain" pos="13:12" rst="0">
        <comment>Tone attenuation. The Comfort Tone or DTMF is attenuated according to this programmable gain. 
        </comment>
        <options>
            <default/>
            <option name="0 dB"  value="0"/>
            <option name="m3 dB"  value="1"/>
            <option name="m9 dB"  value="2"/>
            <option name="m15 dB" value="3"/>
        </options>  
    </bits>
  </reg>

  <reg protect="rw" name="side_tone">
    <bits access="rw" name="Side Tone Gain" pos="3:0" rst="0">
        <comment>Side Tone attenuation. The side tone is attenuated according to this programmable gain.
            <br /> 0000 = mute.
            <br /> 0001 = -36 dB.
            <br /> 0010 = -33 dB. 
            <br /> 0011 = -30 dB.
            <br /> 0100 = -27 dB. 
            <br /> 0101 = -24 dB. 
            <br /> 0110 = -21 dB. 
            <br /> 0111 = -18 dB.
            <br /> 1000 = -15 dB.
            <br /> 1001 = -12 dB.
            <br /> 1010 = -9 dB.
            <br /> 1011 = -6 dB. 
            <br /> 1100 = -3 dB.
            <br /> 1101 = 0 dB. 
            <br /> 1110 = +3 dB. 
            <br /> 1111 = +6 dB. 
        </comment>
    </bits>
</reg>

<reg protect="rw" name="load_pos">
    <bits access="rw" name="rx_load_pos" pos="3:0" rst="0">
        <comment>i2s slave mode, receive shift data load position.
        </comment>
    </bits>
</reg>

<reg protect="rw" name="fm_record_enable">
    <bits access="rw" name="fm_record_en" pos="0" rst="0">
        <comment>i2s slave mode, receive shift data load position.
        </comment>
    </bits>
</reg>
 
</module>
</archive>
<archive relative = "bb_cp2.xml">
<module name="bb_cp2" category="Baseband">
    <reg name="ctrl" protect="rw">
        <bits name="First Poly" pos="2:0" access="rw" rst="111" display="hex">
            <comment>This field is used for setting the first polynomial to encode 
                     or the CRC computation
                    <br/>First polynomial to encode :
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
                    <br/>Cyclic code :
                    <br/>000 = D8 + D4 + D3 + D2 + 1
                    <br/>001 = D3 + D + 1
                    <br/>010 = D14 + D13 + D5 + D3 + D2 +1
                    <br/>011 = D6 + D5 + D3 + D2 + D1 + 1
                    <br/>100 = D10 + D8 + D6 + D5 + D4 + D2 + 1
                    <br/>101 = D16 + D12 + D5 + 1
                    <br/>110 = (D23 + 1)*(D17 + D3 + 1)
                    <br/>111 = reserved
            </comment>
        </bits>
        <bits name="Second Poly" pos="5:3" access="rw" rst="111" display="hex">
            <comment>Second polynomial to encode :
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="Third Poly" pos="8:6" access="rw" rst="111" display="hex">
            <comment>Third polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="Fourth Poly" pos="11:9" access="rw" rst="111" display="hex">
            <comment>Fourth polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="Fith Poly" pos="14:12" access="rw" rst="111" display="hex">
            <comment>Fith polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="Sixth Poly" pos="17:15" access="rw" rst="111" display="hex">
            <comment>Sixth polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="RSC Poly" pos="20:18" access="rw" rst="111" display="hex">
            <comment>RSC (Recursive Systematic Convolutional) polynomial code:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No RSC
            </comment>
        </bits>
        <bits name="NB Poly" pos="23:21" access="rw" rst="111" display="hex">
            <comment>Number of polynomial code to process:
                    <br/>0x0 = 0
                    <br/>0x1 = 1 (First Poly)
                    <br/>0x2 = 2 (First poly and second Poly)
                    <br/>0x3 = 3 (First poly, second poly, third Poly)
                    <br/>0x6 = 6 (first Poly to sixth Poly)
                    <br/>0x7 = reserved
            </comment>
        </bits>
        <bits name="Enable Puncturing" pos="24" access="rw" rst="1">
            <comment>Enable Puncturing
                    <br/>0 = No puncturing (puncturing disabled)
                    <br/>1 = Enable puncturing
            </comment>
        </bits>
    </reg>
    
    <reg name="bit number" protect="rw">
        <bits name="Bit number" pos="8:0" access="rw" rst="0x1FF" display="hex">
            <comment>Number of inputs bits to process
                <br/>0x01 = 1
                <br/>0x02 = 2
                <br/>0x03 = 3
                <br/>...
                <br/>0xFD = 253
                <br/>0xFE = 254
                <br/>0xFF = 255
                <br/>0x100 = 256
                <br/>...
                <br/>0x1BF = 447
                <br/>0x1C0 = 448
            </comment>
        </bits>
    </reg>
    
    <reg name="Status" protect="r">
        <bits name="Enable" pos="0:0" access="r" rst="0">
            <comment>When 1 the bb_cp2 is running
            </comment>
        </bits>
    </reg>
    
    <reg name="lram_addr" protect="rw">
        <bits name="LRAM Address" pos="4:0" access="rw" rst="0x0" display="hex">
            <comment>LRAM address for the next access
                <br/>Automatically incremented after each access
            </comment>
        </bits>
        <bits name="LRAM Select" pos="5" access="rw" rst="0x1">
            <comment>Select LRAM for the next access
                <br/>0 = Puncturing LRAM
                <br/>1 = Data LRAM
            </comment>
        </bits>
    </reg>

    <reg name="CRC code LSB" protect="r">
        <bits name="CRC LSB code" pos="31:0" access="r" rst="0xFFFFFFFF" display="hex">
            <comment>CRC code LSB bits
            </comment>
        </bits>
    </reg>

    <reg name="CRC code MSB" protect="r">
        <bits name="CRC MSB code" pos="7:0" access="r" rst="0x03" display="hex">
            <comment>CRC code MSB bits
            </comment>
        </bits>
    </reg>
    
    <hole size="800" />
    
    <reg name="CP2_Select" protect="rw">
        <bits name="CP2 Select" pos="0" access="rw" rst="1">
            <comment>CP2 register access selection bit
                <br/>0= All registers are only accessible through the APB bus
                <br/>1= All registers are only accessible by the BCPU through the CP2 bus
            </comment>
        </bits>
    </reg>

    <reg name="LRAM_Data" protect="rw">
        <bits name="LRAM Data" pos="31:0" access="rw" rst="no" display="hex">
            <comment>LRAM Data. This register is used for access to the 
                     puncturing LRAM or to the Data LRAM.
                <br/>All access into this register, increment the LRAM_ADDR register.
            </comment>
        </bits>
    </reg>

</module>

<cjoker>
// changing xml generated defines
#undef BB_CP2_ENABLE_PUNCTURING
#undef BB_CP2_LRAM_DATA
#undef BB_CP2_BIT_NUMBER

#define BB_CP2_ENABLE_PUNCTURING(n) (((n)&amp;1)&lt;&lt;24)

/// BB_CP2 address mapping
#define BB_CP2_CTRL                              0
#define BB_CP2_BIT_NUMBER                        1
#define BB_CP2_STATUS                            2
#define BB_CP2_LRAM_ADDR                         3
#define BB_CP2_CRC_CODE_LSB                      4
#define BB_CP2_CRC_CODE_MSB                      5
#define BB_CP2_LRAM_DATA                         0
#define BB_CP2_LRAM_PUNC                         (0&lt;&lt;5)
#define BB_CP2_DATA_LRAM                         (1&lt;&lt;5)

/* BB_CP2 ACCESSES */
// macro for converting a constant to a string
#define CT_CONVERT_TO_STRING(x) #x
// control register -> GPR
#define CT_BB_CP2_RD_CTRL_REG(regaddr, n)       asm volatile("cfc2 %0, $" CT_CONVERT_TO_STRING(regaddr) :"=r"((n)))
//              GPR -> control register
#define CT_BB_CP2_WR_CTRL_REG(regaddr, n)       asm volatile("ctc2 %0, $" CT_CONVERT_TO_STRING(regaddr) ::"r"((n)))
// general register -> GPR
#define CT_BB_CP2_RD_GNRL_REG_GPR(regaddr, n)   asm volatile("mfc2 %0, $" CT_CONVERT_TO_STRING(regaddr) :"=r"((n)))
//              GPR -> general register
#define CT_BB_CP2_WR_GNRL_REG_GPR(regaddr, n)   asm volatile("mtc2 %0, $" CT_CONVERT_TO_STRING(regaddr) ::"r"((n)))
// general register -> memory
#define CT_BB_CP2_RD_GNRL_REG_MEM(regaddr, out)	asm volatile("swc2 $" CT_CONVERT_TO_STRING(regaddr) ", 0(%0)"::"r"((out)))
//           memory -> general register
#define CT_BB_CP2_WR_GNRL_REG_MEM(regaddr, in) 	asm volatile("lwc2 $" CT_CONVERT_TO_STRING(regaddr) ", 0(%0)"::"r"((in)))


</cjoker>

</archive>

<archive relative = "bb_ifc.xml">
<include file="globals.xml"/>
<module name="bb_ifc" category="Baseband">
  <var name="BB_IFC_ADDR_LEN" value="15" />

  <var name="BB_IFC_ADDR_ALIGN" value="2" />

  <var name="BB_IFC_TC_LEN_CH2" value="9" />
  <var name="BB_IFC_TC_LEN" value="8" />

  

  <hole size="512"/>

  

  <reg protect="rw" name="ch2_control">
    <bits access="w" name="enable" pos="0" rst="no">
      <comment>Channel Enable, write one in this bit enable the channel.
      <br />When the channel is enabled, for a peripheral to memory transfer
      the DMA wait request from peripheral to start transfer. </comment>
    </bits>

    <bits access="w" name="disable" pos="1" rst="no">
      <comment>Channel Disable, write one in this bit disable the channel.
      <br />When writing one in this bit, the current AHB transfer and current
      APB transfer (if one in progress) is completed and the channel is then
      disabled.</comment>
    </bits>

    <bits access="rw" name="burst_size" pos="16" rst="1">
      <comment>Burst size on AHB bus 
        <br />0 = Single access 
        <br />1 = burst Access (4 words). 
      </comment>
    </bits>

    <bits access="rw" name="fifo_mode" pos="17" rst="1">
      <comment>Set FIFO mode . <br />0 = no fifo mode, transfer stop when the
      current transfer counter reaches zero. Channel must be re-enabled for
      future transfer. <br />1 = Fifo mode, when the current AHB address
      counter reaches the end address of the FIFO. AHB address counter is
      reloaded with the initial value. In FIFO mode channel is not disabled at
      the end of the transfer.</comment>
    </bits>
  </reg>

  <reg protect="r" name="ch2_status">
    <bits access="r" name="enable" pos="0" rst="0">
      <options>
        <option name="DISABLE" value="0"/>

        <option name="ENABLE" value="1"/>

        <default />
      </options>

      <comment>In no fifo mode the channel is automatically disabled at the
      end of the transfer. In fifo mode the channel is disabled only when
      disabled write is performed in the control register. </comment>
    </bits>

    <bits access="r" name="fifo_empty" pos="4" rst="1">
      <comment>When 1 the fifo is empty </comment>
    </bits>

    <bits access="r" name="cause_itc" pos="8" rst="0">
      <comment>Cause interrupt End of TC.</comment>
    </bits>

    <bits access="r" name="cause_ief" pos="9" rst="0">
      <comment>Cause interrupt End of FIFO. </comment>
    </bits>

    <bits access="r" name="cause_ihtc" pos="10" rst="0">
      <comment>Cause interrupt Half Transfer Count (This interruption is
      generated when the IFC has transferred 96 word).</comment>
    </bits>

    <bits access="r" name="itc" pos="12" rst="0">
      <comment>End of TC interrupt status bit. </comment>
    </bits>

    <bits access="r" name="ief" pos="13" rst="0">
      <comment>End of FIFO interrupt status bit. </comment>
    </bits>

    <bits access="r" name="ihtc" pos="14" rst="0">
      <comment>Half TC interrupt status bit.</comment>
    </bits>

    <bits access="r" name="ch2_cur_tc" pos="BB_IFC_TC_LEN_CH2-1+16:16" rst="0">
      <comment>Current value of transfer counter.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch2_start_addr">
    <bits access="rw" name="ch2_start_addr"
          pos="BB_IFC_ADDR_LEN-1:BB_IFC_ADDR_ALIGN" rst="0xFFFFFFFF" display="hex">
      <comment>AHB Start Address. This field represent the start address in
      the page. The AHB FIFO start address is the concatenation of of
      Page_ADDR and Start_Addr field. </comment>
    </bits>

    <bits access="rw" name="page_addr" pos="NB_BITS_ADDR-1:BB_IFC_ADDR_LEN" rst="0xFFFFFFFF" display="hex">
      <comment>AHB PAGE Address. These nine bits is the MSB bit of the start
      AHB FIFO address. These bits are not incremented during the transfer.
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch2_end_addr">
    <bits access="rw" name="end_addr"
          pos="BB_IFC_ADDR_LEN-1:BB_IFC_ADDR_ALIGN" rst="0xFFFFFFFF" display="hex">
      <comment>The last page address of the FIFO, it is the first address not
      used for the FIFO. The start address of the FIFO is specified by the
      register AHB_ADDR and the last page address of the FIFO is specified by
      this field. The size of the fifo (END_ADDR - START_ADDR) must be a
      multiple of burst of 4x32-bits. </comment>
    </bits>
    <bits access="r" name="page_addr" pos="NB_BITS_ADDR-1:BB_IFC_ADDR_LEN" rst="0xFFFFFFFF" display="hex">
      <comment>AHB PAGE Address. Read only equal to the page_addr field in ch2_start_addr register.
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch2_tc">
    <bits access="rw" name="ch2_tc" pos="BB_IFC_TC_LEN_CH2-1:0" rst="0xFFFFFFFF" display="hex">
      <comment>Transfer Count <br/>In no FIFO mode, this bit indicated
      the transfer size in 32-bits word to perform. Up to 511 32-bits word per
      transfer. <br/>In FIFO mode this field define, after how many
      transfer an interrupt in generated.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch2_int_mask">
    <bits access="rw" name="end_tc" pos="0" rst="0">
      <comment>End TC Mask interrupt. When one this interrupt is
      enabled.</comment>
    </bits>

    <bits access="rw" name="end_fifo" pos="1" rst="0">
      <comment>END FIFO Mask interrupt. When one this interrupt is enabled.
      </comment>
    </bits>

    <bits access="rw" name="half_tc" pos="2" rst="0">
      <comment>Half TC Mask interrupt. When one this interrupt is
      enabled</comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch2_int_clear">
    <bits access="c" name="end_tc" pos="0" rst="0">
      <comment>Write one to clear end of TC interrupt.</comment>
    </bits>

    <bits access="c" name="end_fifo" pos="1" rst="0">
      <comment>Write one to clear end of FIFO interrupt.</comment>
    </bits>

    <bits access="c" name="half_fifo" pos="2" rst="0">
      <comment>Write one to clear end of Half TC interrupt.</comment>
    </bits>
  </reg>

  <reg protect="r" name="ch2_cur_ahb_addr">
    <bits access="r" name="cur_ahb_addr" pos="NB_BITS_ADDR-1:0" rst="0x03ffe000">
      <comment>Current AHB address value. The nine MSB bit is constant and
      equal to the PAGE_ADDR field in the IFC_CH_AHB_START_ADDR register.
      </comment>
    </bits>
  </reg>
  

  <reg protect="w" name="ch3_control">
    <bits access="w" name="enable" pos="0" rst="no">
      <comment>Channel Enable, write one in this bit enable the channel.
      <br />When the channel is enabled, for a peripheral to memory transfer
      the DMA wait request from peripheral to start transfer. </comment>
    </bits>

    <bits access="w" name="disable" pos="1" rst="no">
      <comment>Channel Disable, write one in this bit disable the channel.
      <br />When writing one in this bit, the current AHB transfer and current
      APB transfer (if one in progress) is completed and the channel is then
      disabled.</comment>
    </bits>
  </reg>

  <reg protect="r" name="ch3_status">
    <bits access="r" name="enable" pos="0" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>In no fifo mode the channel is automatically disabled at the
      end of the transfer. In fifo mode the channel is disabled only when
      disabled write is performed in the control register. </comment>
    </bits>

    <bits access="r" name="fifo_empty" pos="4" rst="1">
      <comment>When 1 the fifo is empty </comment>
    </bits>

    <bits access="r" name="cause_itc" pos="8" rst="0">
      <comment>Cause interrupt End of TC.</comment>
    </bits>

    <bits access="r" name="itc" pos="12" rst="0">
      <comment>End of TC interrupt status bit. </comment>
    </bits>

    <bits access="r" name="ch3_cur_tc" pos="BB_IFC_TC_LEN-1+16:16" rst="0xff">
      <comment>Current value of transfer counter.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch3_start_addr">
    <bits access="rw" name="ch3_start_addr"
          pos="BB_IFC_ADDR_LEN-1:BB_IFC_ADDR_ALIGN" rst="0x3FFFFFFF" display="hex">
      <comment>AHB Start Address.</comment>
    </bits>
  </reg>
  <hole size="32"/>
  <reg protect="rw" name="ch3_tc">
    <bits access="rw" name="ch3_tc" pos="BB_IFC_TC_LEN-1:0" rst="0xFF" display="hex">
      <comment>Transfer Count <br/>this bit indicated
      the transfer size in 32-bits word to perform. Up to 255 32-bits word per
      transfer.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch3_int_mask">
    <bits access="rw" name="end_tc" pos="0" rst="0">
      <comment>End TC Mask interrupt. When one this interrupt is
      enabled.</comment>
    </bits>
  </reg>
  <reg protect="rw" name="ch3_int_clear">
    <bits access="c" name="end_tc" pos="0" rst="0">
      <comment>Write one to clear end of TC interrupt.</comment>
    </bits>
  </reg>

  <reg protect="r" name="ch3_cur_ahb_addr">
    <bits access="r" name="cur_ahb_addr" pos="NB_BITS_ADDR-1:0" rst="0x3ffe000">
      <comment>Current AHB address value. 
      </comment>
    </bits>
  </reg>

</module>
</archive>
<archive relative = "bb_irq.xml">

<include file="globals.xml"/>

<module name="bb_irq" category="Baseband">
    
    
    <enum name="BCPU_Irq_Lines">
        <entry name="BCpu_Main_Irq_Line"><comment>BCPU Irq Lines</comment></entry>
        
        <entry name="BCpu_Debug_Irq_Line" value="4"/>
        <entry name="BCpu_Host_Irq_Line"/>
    </enum>


    <reg name="Cause" protect="r">
        <comment>If cause is not null and interrupt are enabled then the interrupt line 0 is driven on the system CPU.
            <br/>The cause for the Irq sources, one bit for each module's irq source.
            <br/>The cause is the actual Irq source masked by the mask register.
        </comment>
        <bits name="Cause" pos="BB_NB_IRQ-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Status" protect="r">
        <comment>The status for the level Irq sources, one bit for each module's irq source.
            <br/>The status reflect the actual Irq source.
        </comment>
        <bits name="Status" pos="BB_NB_IRQ-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Mask_Set" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Set" pos="BB_NB_IRQ-1:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Mask_Clear" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Clr" pos="BB_NB_IRQ-1:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="NonMaskable" protect="rw">
        <bits name="Main_IRQ" pos="10" access="r" rst="0">
            <comment>This is the Main Irq source it drive the system CPU interrupt line 0.
                <br/>This bit comes from the modules irq and is masked by the Mask and SC registers.
            </comment>
        </bits>
        
        <bits name="Debug_IRQ" pos="14" access="rw" rst="0">
            <comment>This is the debug Irq source, the value written here drives the system CPU interrupt line 4.
            </comment>
        </bits>
        <bits name="Host_IRQ" pos="15" access="r" rst="0">
            <comment>This is the Host Irq source it drive the system CPU interrupt line 5.
                <br/>This bit is controlled by the host internal register.
            </comment>
        </bits>
        <bits name="IntEnable_Status" pos="31" access="r" rst="1">
            <comment>Status of the Interrupt enable semaphore bit.
            </comment>
        </bits>
   </reg>
    <reg name="SC" protect="">
        <bits name="IntEnable" pos="0" access="rw" rst="1">
            <comment>Interrupt enable semaphore, used for critical section.
                <br/>Read returns its value and then clears it to '0' disabling interrupts.
                <br/>Write the read value to restore the previous state, this will exit the critical section.
            </comment>
        </bits>
    </reg>
    <reg name="WakeUp_Mask" protect="rw">
        <comment>Each bit to '1' in that registers allows the correcponding interrupt to wake up the System CPU (i.e.: Reenable it's clock, see CLOCK_BB_ENABLE and CLOCK_BB_DISABLE registers in general registers section)
        </comment>
        <bits name="WakeUp_Mask" pos="BB_NB_IRQ-1:0" access="rw" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Cpu_Sleep" protect="w">
        <bits name="Sleep" pos="0" access="w" rst="0">
            <comment>Writing '1' to this bit will put the BCPU to sleep (i.e.: Disable it's clock, see CLOCK_BB_ENABLE and CLOCK_BB_DISABLE registers in general registers section)
            </comment>
        </bits>
    </reg>
    <reg name="Pulse_Mask_Set" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Pulse_Mask_Set" pos="BB_NB_IRQ_PULSE-1:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Mask_Clr" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Pulse_Mask_Clr" pos="BB_NB_IRQ_PULSE-1:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Clear" protect="rw">
        <comment>Writing '1' clears the corresponding Pulse IRQ.
            <br/>Pulse IRQ are set by the modules and cleared here.
        </comment>
        <bits name="Pulse_Clr" pos="BB_NB_IRQ_PULSE-1:0" access="c" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Status" protect="r">
        <comment>The status for the Pulse Irq sources, one bit for each module's irq source.
            <br/>The status reflect the actual Irq source.
        </comment>
        <bits name="Pulse_Status" pos="BB_NB_IRQ_PULSE-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>


</module>

</archive>
<archive relative = "bb_sram.xml">

<include file="globals.xml"/>

<module name="bb_sram" category="Baseband">

    <memory name="ram_array" size="BB_SRAM_SIZE">
        <comment>Baseband side internal memory, also used by accelerators.
        </comment>
    </memory>
</module>


</archive>
<archive relative = "bcpu_cache.xml">
<module name="bcpu_cache" category="Debug">

    <struct name="Line" count="exp2(6)">
        <reg name="Data" protect="rw" count="4">
        <comment>The BCpu cache is accessible only when it is disabled or the cpu is stalled.
            <br/>The bits "9:4" of the address select the line.
            <br/>If the Tag at the corresponding line is valid, the bits "24:10" of the tag are the corresponding address bits.
            <br/>The bits "3:0" of the address select the Data in the line.
        </comment>
            <bits name="data" pos="31:0" access="rw" rst="0">
            </bits>
        </reg>
    </struct>
</module>
</archive>
<archive relative = "bcpu_tag.xml">
<module name="bcpu_tag" category="Debug">

    <reg name="Line" protect="rw" count="exp2(6)">
        <comment>The BCpu tags are accessible only when the corresponding cache is disabled or the cpu is stalled.
            <br/>The bits "9:4" of the address select the line
        </comment>
        <bits name="Tag" pos="24:10" access="rw" rst="0">
            <comment>The Tag represents the bits "24:10" of the address present in the corresponding cache Line.
            </comment>
            <options><default/><shift/><mask/></options>
        </bits>
        <bits name="Valid" pos="29" access="rw" rst="0">
            <comment>When 1 the Tag is valid
            </comment>
            <options><default/><shift/><mask/></options>
        </bits>
    </reg>
</module>
</archive>
<archive relative = "build_version.xml">

<var name="BUILD_VERSION_NUMBER" value="0x014081510"/>
</archive>
<archive relative = "calendar.xml">
<module name="calendar" category="System">

    <reg name="Ctrl" protect="rw">

        <bits name="Interval" pos="1:0" access="rw" rst="0">
            <options>
                <default/>
                <option name="DISABLE" value="0"/>
                <option name="PER SEC" value="1"/>
                <option name="PER MIN" value="2"/>
                <option name="PER HOUR" value="3"/>
            </options>
            <comment>These 2 bits configure the interval of generating an IRQ status.
            </comment>
        </bits>
    </reg>
    
    <reg name="Cmd" protect="rw">
        <bits name="Calendar_Load" pos="0" access="rs" rst="0">
            <comment>When write, command to program calendar with a new value (sec, min, hour, day, month, year, day of week) previously written in registers Calendar_LoadVal_H and Calendar_LoadVal_L. This bit is auto cleared.
                <br/>'1' = load calendar timer.  
                <br/>
                <br/>When read, Calendar timer load status.
                <br/>'1' = Calendar load has not finished.
                <br/>'0' = Calendar load has finished.
            </comment>
        </bits>
        <bits name="Alarm_Load" pos="4" access="rs" rst="0">
            <comment>When write, command to program alarm with a new value (sec, min, hour, day, month, year, day of week) prviously written in registers AlarmVal_H and AlarmVal_L. This bit is auto cleared. 
                <br/>'1' = load alarm.
                <br/>
                <br/>When read, alarm load status.
                <br/>'1' = alarm load has not finished.
                <br/>'0' = alarm load has finished.
            </comment>
        </bits>
        <bits name="Alarm_Enable_Set" pos="5" access="rs" rst="0">
            <comment>command to enable alarm. When alarm is triggered, it will generate a wakup.
                <br/>'1' = enable alarm.
                <br/>
                <br/>When read, alarm enable status.
                <br/>'1' = alarm enable operation is on going, not finished.
                <br/>'0' = alarm is enabled.                  
            </comment>
        </bits>
        <bits name="Alarm_Enable_Clr" pos="6" access="rc" rst="0">
            <comment>command to disable alarm.
                <br/>'1' = disable alarm.
                <br/>
                <br/>When read, alarm enable status.
                <br/>'1' = alarm disable operation is on going, not finished.
                <br/>'0' = alarm is disabled.                  
            </comment>
        </bits>
        <bits name="Alarm_Clr" pos="8" access="rc" rst="0">
            <comment>writing '1', clear Alarm triggered signal (connect to wakeup) and alarm triggered IRQ.
                <br/>
                <br/>When read, get alarm clear status.
                <br/>'1' = alarm clear operation is on going, not finished.
                <br/>'0' = alarm is cleared.                  
            </comment>
        </bits>
        <bits name="Itv_Irq_Clr" pos="9" access="c" rst="0">
            <comment>writing '1', clear interval IRQ.
            </comment>
        </bits>
        <bits name="Itv_Irq_Mask_Set" pos="16" access="rs" rst="0">
            <comment>When write '1', Set interval Irq Mask. 
                <br/>When read, get interval Irq mask.
            </comment>
        </bits>        
        <bits name="Itv_Irq_Mask_Clr" pos="17" access="rc" rst="0">
            <comment>When write '1', Clear interval Irq Mask. 
                <br/>When read, get inteval Irq mask.
            </comment>
        </bits>               
        <bits name="Calendar_Not_Valid" pos="31" access="rs" rst="1">
            <comment>When write '1', mark calendar value to be not valid.
                <br/>
                <br/>When read, Indicate if the Calendar value is valid or not.
                <br/>The calendar value is not valid in case of mismatch between the calendar counter and the APB register,
                    which is the case of wakeup the phone after shut down. This mismatch disappear after one RTC cycle or 
                    after re-porgramming a new calendar value. 
                <br/>'1' = not valid.
            </comment>
        </bits>        
    </reg>

    <reg name="Status" protect="r">
        
        <bits name="Itv_Irq_Cause" pos="0" access="r" rst="0">
            <comment>Interval Irq Cause. 
            </comment>
        </bits>    
        <bits name="Alarm_Irq_Cause" pos="1" access="r" rst="0">
            <comment>Alarm Irq Cause. 
            </comment>
        </bits> 
        <bits name="Force_Wakeup" pos="8" access="r" rst="0">
             <comment>Force Wakeup status. After set "Force_Wakeup" to '1' in sys_ctrl, the real
                 force_wakeup is not set immediatly, this bit indicates when the force wakeup is 
                 really set. This bits also indicates if the interface between Calendar domain and
                 Core domain is enabled. 
                <br/>'1': force wakeup set.
            </comment>
        </bits>           
        <bits name="Chg_Mask" pos="12" access="r" rst="0">
             <comment>Charger Mask status. After set "Chg_Mask" to '1' in sys_ctrl, the real
                 Chg_Mask line is not set immediatly, this bit indicates when the Chg_Mask line is
                 really set.                
                <br/>'1': Chg_Mask line set.
            </comment>
        </bits>           
        <bits name="Itv_Irq_Status" pos="16" access="r" rst="0">
            <comment>Interval Irq Status. 
            </comment>
        </bits>        
        <bits name="Alarm_Enable" pos="20" access="r" rst="0">
            <comment>Alarm Enable Status. 
                <br/> Note: When calendar is not programmed, Alarm can be enabled or not. 
                <br/> It is suggested to clear Alarm Enable when program RTC. 
            </comment>
        </bits>          
        <bits name="Calendar_Not_Prog" pos="31" access="r" rst="0">
            <comment>'1' = Calendar has not been programmed. 
                <br/>This bit keep value '0' after the calendar is programmed once.
            </comment>
        </bits>
    </reg>

    <reg name="Calendar_LoadVal_L" protect="rw">
        <bits name="Sec" pos="5:0" access="rw" rst="-">
            <comment>Second value loaded to calendar, ranged from 0 to 59. 
            </comment>
        </bits>         
        <bits name="Min" pos="13:8" access="rw" rst="-">
            <comment>Minute value loaded to calendar, ranged from 0 to 59. 
            </comment>
        </bits>          
        <bits name="Hour" pos="20:16" access="rw" rst="-">
            <comment>Hour value loaded to calendar, ranged from 0 to 23. 
            </comment>
        </bits>         
    </reg>

    <reg name="Calendar_LoadVal_H" protect="rw">
        <bits name="Day" pos="4:0" access="rw" rst="-">
            <comment>Day value loaded to calendar, ranged from 1 to 31. 
            </comment>
        </bits>         
        <bits name="Mon" pos="11:8" access="rw" rst="-">
            <comment>Month value loaded to calendar, ranged from 1 to 12. 
            </comment>
        </bits>          
        <bits name="Year" pos="22:16" access="rw" rst="-">
            <comment>Year value loaded to calendar, ranged from 0 to 127. 
                <br/>Represent year 2000 to 2127.
            </comment>
        </bits>
        <bits name="WeekDay" pos="26:24" access="rw" rst="-">
            <comment>Day of the week value loaded to calendar, ranged from 1 to 7.
                <br/>Represent Monday, Tuesday etc.
            </comment>
        </bits>
    </reg>

    <reg name="Calendar_CurVal_L" protect="r">
        <bits name="Sec" pos="5:0" access="r" rst="-">
            <comment>Current Second value of calendar, ranged from 0 to 59. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Min" pos="13:8" access="r" rst="-">
            <comment>Current Minute value of calendar, ranged from 0 to 59. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="Hour" pos="20:16" access="r" rst="-">
            <comment>Current Hour value of calendar, ranged from 0 to 23. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>         
    </reg>
    
    <reg name="Calendar_CurVal_H" protect="r">
        <bits name="Day" pos="4:0" access="r" rst="-">
            <comment>Current Day value of calendar, ranged from 1 to 31. 
                <br/>Maximum number of days in each month are stored in the module,
                and leap year is supported, so February can have 28 or 29 days.  
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>         
        <bits name="Mon" pos="11:8" access="r" rst="-">
            <comment>Current Month value of calendar, ranged from 1 to 12. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="Year" pos="22:16" access="r" rst="-">
            <comment>Current Year value of calendar, ranged from 0 to 127. 
                <br/>Represent year 2000 to 2127.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="WeekDay" pos="26:24" access="r" rst="-">
            <comment>Current Day of the week value of calendar, ranged from 1 to 7.
                <br/>Represent Monday, Tuesday etc.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
     
    <reg name="AlarmVal_L" protect="rw">
        <bits name="Sec" pos="5:0" access="rw" rst="-">
            <comment>Second value loaded to alarm, ranged from 0 to 59. 
            </comment>
        </bits>         
        <bits name="Min" pos="13:8" access="rw" rst="-">
            <comment>Minute value loaded to alarm, ranged from 0 to 59. 
            </comment>
        </bits>          
        <bits name="Hour" pos="20:16" access="rw" rst="-">
            <comment>Hour value loaded to alarm, ranged from 0 to 23. 
            </comment>
        </bits>         
    </reg>

    <reg name="AlarmVal_H" protect="rw">
        <bits name="Day" pos="4:0" access="rw" rst="-">
            <comment>Day value loaded to alarm, ranged from 1 to 31. 
            </comment>
        </bits>         
        <bits name="Mon" pos="11:8" access="rw" rst="-">
            <comment>Month value loaded to alarm, ranged from 1 to 12. 
            </comment>
        </bits>          
        <bits name="Year" pos="22:16" access="rw" rst="-">
            <comment>Year value loaded to alarm, ranged from 0 to 127. 
                <br/>Represent year 2000 to 2127.
            </comment>
        </bits>
    </reg>
    
    
</module>



</archive>

<archive relative = "camera.xml">
<var name="FIFORAM_SIZE" value="80"/>    
<module name="camera" category="Periph">

    <reg name="CTRL" protect="rw">
		<bits access="rw" name="Enable" pos="0" rst="0">
            <options>
                <default/>
                <option name="ENABLE"  value="1"/>
                <option name="DISABLE" value="0"/>
            </options>            
			<comment> Enable camera controller,high active. 
			</comment>
    </bits>
		<bits access="rw" name="DctEnable" pos="1" rst="0">         
            <options>
                <default/>
                <option name="1_BUFENABLE_ENABLE"  value="1"/>
                <option name="1_BUFENABLE_DISABLE" value="0"/>
            </options>
			<comment> Enable camera controller,high active. 
			</comment>
    </bits>
    <bits access="rw" name="DataFormat" pos="5:4" rst="0">
            <options>
                <default/>
                <option name="RGB565"  value="0"/>
                <option name="YUV422"  value="1"/>
                <option name="JPEG"    value="2"/>
                <option name="RESERVE" value="3"/>
            </options>               
            <comment> "0" = RGB565.
                <br/> "1" = YUV422.
                <br/> "2" = Compressed Data.
                <br/> "3" = Reserved.
			</comment>
        </bits>
		<bits access="rw" name="RESET_Pol" pos="8" rst="1">
            <options>
                <default/>
                <option name="INVERT" value="1"/>
                <option name="NORMAL" value="0"/>
            </options>   
            <comment> '0' = keep output camera reset polarity.
                <br/> '1' = invert output camera reset polarity. 
			</comment>
        </bits>
		<bits access="rw" name="PWDN_Pol" pos="9" rst="0">
            <options>
                <default/>
                <option name="INVERT" value="1"/>
                <option name="NORMAL" value="0"/>
            </options>   
            <comment> '0' = keep output camera power down polarity.
                <br/> '1' = invert output camera power down polarity. 
			</comment>
        </bits>
		<bits access="rw" name="VSYNC_Pol" pos="10" rst="0">
            <options>
                <default/>
                <option name="INVERT" value="1"/>
                <option name="NORMAL" value="0"/>
            </options>   
            <comment> '0' = keep input VSYNC polarity.
                <br/> '1' = invert input VSYNC polarity. 
			</comment>
        </bits>
		<bits access="rw" name="HREF_Pol" pos="11" rst="0">
            <options>
                <default/>
                <option name="INVERT" value="1"/>
                <option name="NORMAL" value="0"/>
            </options>   
            <comment> '0' = keep input HREF polarity so data is sampled when HREF high.
                <br/> '1' = invert input HREF polarity so data is sampled when HREF low. 
			</comment>
        </bits>
		<bits access="rw" name="PIXCLK_Pol" pos="12" rst="0">
            <options>
                <default/>
                <option name="INVERT" value="1"/>
                <option name="NORMAL" value="0"/>
            </options>   
			<comment> '0' = keep pix clk polarity.
			    <br/> '1' = invert pix clk polarity.
			</comment>
        </bits>
		<bits access="rw" name="VSYNC_Drop" pos="14" rst="1">
            <options>
                <default/>
                <option name="DROP"   value="1"/>
                <option name="NORMAL" value="0"/>
            </options>   
			<comment> '0' = VSYNC irq always exists when Frame decimation is enabled.
			    <br/> '1' = VSYNC irq will drop when Frame data are dropped in decipation.
			</comment>
        </bits>
		<bits access="rw" name="DecimFrm" pos="17:16" rst="0">
            <options>
                <default/>
                <option name="ORIGINAL" value="0"/>
                <option name="DIV_2"    value="1"/>
                <option name="DIV_3"    value="2"/>
                <option name="DIV_4"    value="3"/>
            </options>   
			<comment> "0"= All frame data will be sent.
                <br/> "1"= only one frame out of two (1/2) will be sent.
                <br/> "2"= only one frame out of three (1/3) will be sent.
                <br/> "3"= only one frame out of four (1/4) will be sent.
			</comment>
        </bits>
        <bits access="rw" name="DecimCol" pos="19:18" rst="0">
            <options>
                <default/>
                <option name="ORIGINAL" value="0"/>
                <option name="DIV_2"    value="1"/>
                <option name="DIV_3"    value="2"/>
                <option name="DIV_4"    value="3"/>
            </options>   
			<comment> "0"= Pixel Decimation Disabled.
                <br/> "1"= Pixel Decimation 1/2.
                <br/> "2"= Pixel Decimation 1/3.
                <br/> "3"= Pixel Decimation 1/4.
			</comment>
        </bits> 
        <bits access="rw" name="DecimRow" pos="21:20" rst="0">
            <options>
                <default/>
                <option name="ORIGINAL" value="0"/>
                <option name="DIV_2"    value="1"/>
                <option name="DIV_3"    value="2"/>
                <option name="DIV_4"    value="3"/>
            </options>   
			<comment> "0"= line Decimation Disabled.
                <br/> "1"= line Decimation 1/2.
                <br/> "2"= line Decimation 1/3.
                <br/> "3"= line Decimation 1/4.
			</comment>
        </bits>  
        <bits name="Reorder"  pos="26:24" access="rw" rst="0">
            <comment>Controls the Re-ordering of the FIFO data.
                <br/> In following table, for input data, right comes before left. So YUYV means V comes first.
                <br/> for output data, right data is the LSB. So YUYV means V is stored in low 8-bit (byte0) of 32-bit word.
                <br/>
                <br/> If Bit 26 is '1', byte2 and byte0 is Y. 
                <br/> If Bit 25 is '1', both byte2/byte3 and byte1/byte0 interchange.
                <br/> If Bit 24 is '1', byte U and V should interchange. (UV bytes can be decided using bit 26).
                <br/>
                <br/> input YUYV, output YUYV: "000"
                <br/> input YVYU, output YUYV: "001"
                <br/> input UYVY, output YUYV: "110"
                <br/> input VYUY, output YUYV: "111"
                <br/>
                <br/> input YUYV, output UYVY: "010"
                <br/> input YVYU, output UYVY: "011"
                <br/> input UYVY, output UYVY: "100"
                <br/> input VYUY, output UYVY: "101"
                <br/>
                <br/> input YUYV, output YVYU: "001"
                <br/> input YVYU, output YVYU: "000"
                <br/> input UYVY, output YVYU: "111"
                <br/> input VYUY, output YVYU: "110"
                <br/>
                <br/> input YUYV, output VYUY: "011"
                <br/> input YVYU, output VYUY: "010"
                <br/> input UYVY, output VYUY: "101"
                <br/> input VYUY, output VYUY: "100"                
                <br/>
                <br/> Decimation will reorder data flow also. Input UYVY becomes YUVY after decimation.
                      This reorder is corrected using Bit 26 infomation.
            </comment>
        </bits>
        <bits access="rw" name="CropEn" pos="28" rst="0">
            <options>
                <default/>
                <option name="ENABLE"  value="1"/>
                <option name="DISABLE" value="0"/>
            </options>            
			<comment> "0"= Cropping Disabled.
				<br/> "1"= Cropping Enabled.
                <br/> Note: this bit should set to '0' when bit field "DataFormat" is "10" (compressed data)  
			</comment>
        </bits>          
		<bits access="rw" name="Bist Mode" pos="30" rst="0">
            <options>
                <default/>
                <option name="BIST"   value="1"/>
                <option name="NORMAL" value="0"/>
            </options>            
			<comment> 
				In Bist Mode, FIFO RAM are read and write by its address, FIFO mode is disabled. 
			</comment>
		</bits>       
		<bits access="rw" name="TEST" pos="31" rst="0">
            <options>
                <default/>
                <option name="TEST"  value="1"/>
                <option name="NORMAL" value="0"/>
            </options>            
			<comment> 
				Debug only. A RGB565 test card is sent to system bus instead of real data from sensor. 
			</comment>
		</bits>       
     </reg>
	<reg protect="r" name="STATUS">
		<bits access="r" name="OVFL" pos="0" rst="0">
            <comment> '1' = FIFO over-write IRQ status. 
                <br/> Write to corresponding bit in IRQ CLEAR register will clear this bit.  
			</comment>
		</bits>
		<bits access="r" name="VSYNC_R" pos="1" rst="0">
			<comment> '1' = VSYNC rising edge IRQ status 
                <br/> Write to corresponding bit in IRQ CLEAR register will clear this bit.  
			</comment>
        </bits>
		<bits access="r" name="VSYNC_F" pos="2" rst="0">
			<comment> '1' = VSYNC falling edge IRQ status 
                <br/> Write to corresponding bit in IRQ CLEAR register will clear this bit.  
			</comment>
        </bits>
		<bits access="r" name="DMA DONE" pos="3" rst="0">
			<comment> '1' = DMA Done IRQ status 
                <br/> Write to corresponding bit in IRQ CLEAR register will clear this bit.  
			</comment>
        </bits>
		<bits access="r" name="FIFO EMPTY" pos="4" rst="1">
			<comment> '1' = FIFO Empty status, not clear-able. 
			</comment>
        </bits>
	</reg>
     <reg name="DATA"  protect="r">
         <bits name="RX_DATA" pos="31:0" access="r" rst="0">
           <comment>Read in the receive FIFO
           </comment>
         </bits>
     </reg>

	<reg protect="rw" name="IRQ MASK">
		<bits access="rw" name="OVFL" pos="0" rst="0">
			<comment> '1' = FIFO over-write enable 
			</comment>
		</bits>
		<bits access="rw" name="VSYNC_R" pos="1" rst="0">
			<comment> '1' = VSYNC rising edge enable 
			</comment>
		</bits>
		<bits access="rw" name="VSYNC_F" pos="2" rst="0">
			<comment> '1' = VSYNC falling edge enable 
			</comment>
		</bits>
		<bits access="rw" name="DMA DONE" pos="3" rst="0">
			<comment> '1' = DMA Done enable 
			</comment>
		</bits>
        
	</reg>
     
	<reg protect="w" name="IRQ CLEAR">
		<bits access="w" name="OVFL" pos="0" rst="0">
			<comment> Write '1' to clear FIFO over-write interrupt
			</comment>
		</bits>
		<bits access="w" name="VSYNC_R" pos="1" rst="0">
			<comment> Write '1' to clear VSYNC rising edge interrupt
			</comment>
		</bits>
		<bits access="w" name="VSYNC_F" pos="2" rst="0">
			<comment> Write '1' to clear VSYNC falling edge interrupt
			</comment>
		</bits>
		<bits access="w" name="DMA DONE" pos="3" rst="0">
			<comment> Write '1' to clear DMA Done interrupt
			</comment>
		</bits>
	</reg>
	
	<reg protect="r" name="IRQ CAUSE">
		<bits access="r" name="OVFL" pos="0" rst="0">
			<comment> '1' = FIFO over-write cause 
			</comment>
		</bits>
		<bits access="r" name="VSYNC_R" pos="1" rst="0">
			<comment> '1' = VSYNC rising edge cause 
			</comment>
        </bits>
		<bits access="r" name="VSYNC_F" pos="2" rst="0">
			<comment> '1' = VSYNC falling edge cause 
			</comment>
        </bits>
		<bits access="r" name="DMA DONE" pos="3" rst="0">
			<comment> '1' = DMA Done cause 
			</comment>
        </bits>
	</reg>

	<reg protect="rw" name="CMD SET">
		<bits name="PWDN" pos="0" access="rs" rst="1">
			<comment> Power down pin of CMOS sensor . 
			</comment>
		</bits>
		<bits name="RESET" pos="4" access="rs" rst="1">
			<comment> Reset pin of CMOS sensor. 
                    <br/>Active Low.
			</comment>
        </bits>
       <bits name="FIFO RESET" pos="8" access="s" rst="0">
          <comment>For the software to clear FIFO. This bit is auto-reset to 0.
          </comment>
       </bits>
    </reg>

	<reg protect="rw" name="CMD CLR">
		<bits name="PWDN" pos="0" access="rc" rst="1">
			<comment> Power down pin of CMOS sensor . 
			</comment>
		</bits>
		<bits name="RESET" pos="4" access="rc" rst="1">
			<comment> Reset pin of CMOS sensor. 
			</comment>
        </bits>
    </reg>
   
	<reg protect="rw" name="DSTWINCOL">
		<bits name="DstWinColStart" pos="11:0" access="rw" rst="0">
			<comment> start pixel of cropped window. 
			</comment>
		</bits>
		<bits name="DstWinColEnd" pos="27:16" access="rw" rst="0">
			<comment> end pixel of cropped window. 
			</comment>
        </bits>
    </reg>

	<reg protect="rw" name="DSTWINROW">
		<bits name="DstWinRowStart" pos="11:0" access="rw" rst="0">
			<comment> start line of cropped window. 
			</comment>
		</bits>
    <bits name="DstWinRowEnd" pos="27:16" access="rw" rst="0">
			<comment> end line of cropped window. 
			</comment>
        </bits>
    </reg>

    <reg protect="rw" name="SCALE_COFIG">
        <bits name="SCALE_EN" pos="0" access="rw" rst="0">
            <comment> scale enable.
            </comment>
        </bits>
        <bits name="SCALE_COL" pos="9:8" access="rw" rst="0">
            <comment> scale column.
            </comment>
        </bits>
        <bits name="SCALE_ROW" pos="17:16" access="rw" rst="0">
            <comment> scale row.
            </comment>
        </bits>
    </reg>

    <reg protect="rw" name="CAM_SPI_REG_0">
        <bits name="line_num_per_frame" pos="31:22" access="rw" rst="0">
        </bits>
        <bits name="block_num_per_line" pos="21:12" access="rw" rst="0">
        </bits>
        <bits name="vsync_inv" pos="11" access="rw" rst="0">
        </bits>
        <bits name="href_inv" pos="10" access="rw" rst="0">
        </bits>
        <bits name="overflow_inv" pos="9" access="rw" rst="0">
        </bits>
        <bits name="big_end_dis" pos="8" access="rw" rst="0">
        </bits>
        <bits name="overflow_rst_en" pos="7" access="rw" rst="0">
        </bits>
        <bits name="overflow_observe_only_vsync_low" pos="6" access="rw" rst="0">
        </bits>
        <bits name="overflow_rstn_only_vsync_low" pos="5" access="rw" rst="0">
        </bits>
        <bits name="yuv_out_format" pos="4:2" access="rw" rst="0">
        </bits>
        <bits name="camera_spi_master_en" pos="1" access="rw" rst="0">
        </bits>
        <bits name="camera_spi_slave_en" pos="0" access="rw" rst="0">
        </bits>
    </reg>

    <reg protect="rw" name="CAM_SPI_REG_1">
        <bits name="clk_div_num" pos="15:0" access="rw" rst="0">
        </bits>
        <bits name="cts_spi_master_reg" pos="16" access="rw" rst="0">
        </bits>
        <bits name="ssn_cm_inv" pos="17" access="rw" rst="0">
        </bits>
        <bits name="sck_cm_inv" pos="18" access="rw" rst="0">
        </bits>
        <bits name="ssn_spi_oenb_dr" pos="19" access="rw" rst="0">
        </bits>
        <bits name="ssn_spi_oenb_reg" pos="20" access="rw" rst="0">
        </bits>
        <bits name="sck_spi_oenb_dr" pos="21" access="rw" rst="0">
        </bits>
        <bits name="sck_spi_oenb_reg" pos="22" access="rw" rst="0">
        </bits>
    </reg>

    <reg protect="rw" name="CAM_SPI_REG_2">
        <bits name="ssn_cs_inv" pos="29" access="rw" rst="0">
        </bits>
        <bits name="ready_cs_inv" pos="28" access="rw" rst="0">
        </bits>
        <bits name="data_rcv_choose_bit" pos="27:26" access="rw" rst="0">
        </bits>
        <bits name="ssn_cs_delay" pos="25:24" access="rw" rst="0">
        </bits>
        <bits name="word_num_per_block" pos="23:16" access="rw" rst="0">
        </bits>
        <bits name="init_wait_length" pos="15:8" access="rw" rst="0">
        </bits>
        <bits name="ssn_wait_length" pos="7:0" access="rw" rst="0">
        </bits>
    </reg>

    <reg protect="rw" name="CAM_SPI_REG_3">
        <bits name="ssn_high_length" pos="31:24" access="rw" rst="0">
        </bits>
        <bits name="block_wait_length" pos="23:16" access="rw" rst="0">
        </bits>
        <bits name="line_wait_length" pos="15:0" access="rw" rst="0">
        </bits>
    </reg>

    <reg protect="rw" name="CAM_SPI_REG_4">
        <bits name="block_num_per_packet" pos="15:6" access="rw" rst="0">
        </bits>
        <bits name="image_width_choose_bit" pos="5" access="rw" rst="0">
        </bits>
        <bits name="image_height_choose_bit" pos="4" access="rw" rst="0">
        </bits>
        <bits name="data_size_choose_bit" pos="3" access="rw" rst="0">
        </bits>
        <bits name="sdo_line_choose_bit" pos="2:1" access="rw" rst="0">
        </bits>
        <bits name="camera_spi_master_en_2" pos="0" access="rw" rst="0">
        </bits>
    </reg>

    <reg protect="rw" name="CAM_SPI_REG_5">
        <bits name="sync_code" pos="23:0" access="rw" rst="0">
        </bits>
    </reg>

    <reg protect="rw" name="CAM_SPI_REG_6">
        <bits name="packet_id_frame_start" pos="31:24" access="rw" rst="0">
        </bits>
        <bits name="packet_id_frame_end" pos="23:16" access="rw" rst="0">
        </bits>
        <bits name="packed_id_line_start" pos="15:8" access="rw" rst="0">
        </bits>
        <bits name="packed_id_data_start" pos="7:0" access="rw" rst="0">
        </bits>
    </reg>

    <reg protect="r" name="CAM_SPI_OBSERVE_REG_0">
        <bits name="obs_data_id_wrong" pos="28" access="r" rst="0">
        </bits>
        <bits name="obs_ln_num_wrong" pos="27" access="r" rst="0">
        </bits>
        <bits name="obs_img_width_wrong" pos="26" access="r" rst="0">
        </bits>
        <bits name="obs_img_height_wrong" pos="25" access="r" rst="0">
        </bits>
        <bits name="obs_data_size_wrong" pos="24" access="r" rst="0">
        </bits>
        <bits name="data_id" pos="23:16" access="r" rst="0">
        </bits>
        <bits name="line_id" pos="15:0" access="r" rst="0">
        </bits>
    </reg>

    <reg protect="r" name="CAM_SPI_OBSERVE_REG_1">
        <bits name="image_width" pos="31:16" access="r" rst="0">
        </bits>
        <bits name="image_height" pos="15:0" access="r" rst="0">
        </bits>
    </reg>

    <hole size="3456"/>
    <struct count="FIFORAM_SIZE" name="FIFORAM">
    <reg name="RAMData" protect="r">
        <bits name="Data" pos="31:0" access="r" rst="0">
            <comment> Direct FIFO Ram Access. They are enabled only in Bist Mode.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    </struct>    
    
   
</module>
</archive>

<archive relative = "cfg_regs.xml">


<var name="PROD_ID" value="0x0809"/>
<var name="SUB_ID" value="0x19"/>


<module name="cfg_regs" category="System">
    

    <reg name="CHIP_ID" protect="r">
        <bits name="METAL_ID" pos="11:0" access="r" rst="0">
            <comment> ECO Identification number.
            </comment>
            <options>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="BOND_ID" pos="14:12" access="r" rst="0">
            <comment>Bonding Identification number.
            </comment>
            <options>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="SUB_ID" pos="19:15" access="r" rst="0x19">
            <comment>Product Identification letter.
            </comment>
            <options>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="PROD_ID" pos="31:20" access="r" rst="0x809">
            <comment>Product Identification number.
            </comment>
            <options>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    
    <reg name="Build_Version" protect="r">
        <comment>This register contain the synthesis date and version
        </comment>
        <bits name="Major" pos="31:28" access="r" rst="no">
        </bits>
        <bits name="Year" pos="27:24" access="r" rst="no">
        </bits>
        <bits name="Month" pos="23:16" access="r" rst="no" display="hex">
        </bits>
        <bits name="Day" pos="15:8" access="r" rst="no" display="hex">
        </bits>
        <bits name="Build_Style" pos="5:4" access="r" rst="no">
            <options>
                <option name="FPGA" value ="0"/>
                <option name="CHIP" value ="1"/>
                <option name="FPGA_USB" value ="2"/>
                <option name="FPGA_GSM" value ="3"/>
            </options>
        </bits>
        <bits name="Build_Revision" pos="3:0" access="r" rst="no">
        </bits>
    </reg>

    <hole size="64"/>    

    <reg name="IO_Drive1_Select" protect="rw">
       <bits name="M_D_0_drive" pos="2:0" access="rw" rst="100">
            <comment>Psram Pad drive select, Level 0 is the most stronge</comment>
            <options>
                <option name="drv level 0" value="0"></option>
                <option name="drv level 1"  value="1"></option>
                <option name="drv level 2"  value="2"></option>
                <option name="drv level 3" value="3"></option>
                <option name="drv level 4" value="4"></option>
                <option name="drv level 5" value="5"></option>
                <option name="drv level 6" value="6"></option>
                <option name="drv level 7" value="7"></option>
                <mask/>
            </options>
        </bits>
        <bits name="M_D_1_drive" pos="5:3" access="rw" rst="100">
        </bits>
        <bits name="M_SPI_drive" pos="8:6" access="rw" rst="100">
            <comment>Spiflash Pad drive select Level 0 is the most stronge</comment>
            <options>
                <option name="drv level 0" value="0"></option>
                <option name="drv level 1"  value="1"></option>
                <option name="drv level 2"  value="2"></option>
                <option name="drv level 3" value="3"></option>
                <option name="drv level 4" value="4"></option>
                <option name="drv level 5" value="5"></option>
                <option name="drv level 6" value="6"></option>
                <option name="drv level 7" value="7"></option>
                <mask/>
            </options>
        </bits>
       <bits name="LCD_DATA_drive" pos="10:9" access="rw" rst="all0">
            <comment>V_LCD Pad drive select</comment>
            <options>
                <option name="Fast Fast" value="0"></option>
                <option name="Fast"      value="1"></option>
                <option name="Slow"      value="2"></option>
                <option name="Slow Slow" value="3"></option>
                <mask/>
            </options>
       </bits>
       <bits name="CAM_drive" pos="12:11" access="rw" rst="all0">
            <comment>V_CAM Pad drive select</comment>
            <options>
                <option name="Fast Fast" value="0"></option>
                <option name="Fast"      value="1"></option>
                <option name="Slow"      value="2"></option>
                <option name="Slow Slow" value="3"></option>
                <mask/>
            </options>
       </bits>
       <bits name="GPO_drive" pos="14:13" access="rw" rst="all0">
            <comment>V_STD Pad drive select</comment>
            <options>
                <option name="Fast Fast" value="0"></option>
                <option name="Fast"      value="1"></option>
                <option name="Slow"      value="2"></option>
                <option name="Slow Slow" value="3"></option>
                <mask/>
            </options>
       </bits>
       <bits name="KEYPAD_drive" pos="16:15" access="rw" rst="all0">
            <comment>V_STD Pad drive select</comment>
            <options>
                <option name="Fast Fast" value="0"></option>
                <option name="Fast"      value="1"></option>
                <option name="Slow"      value="2"></option>
                <option name="Slow Slow" value="3"></option>
                <mask/>
            </options>
       </bits>
       <bits name="SDMMC_drive" pos="18:17" access="rw" rst="all0">
            <comment>V_MMC drive select</comment>
            <options>
                <option name="Fast Fast" value="0"></option>
                <option name="Fast"      value="1"></option>
                <option name="Slow"      value="2"></option>
                <option name="Slow Slow" value="3"></option>
                <mask/>
            </options>
       </bits>
    </reg>
    <reg name="IO_Drive2_Select" protect="rw">
       <bits name="M_SPI_D" pos="1:0" access="rw" rst="all0">
            <comment>M_SPI_D drive select</comment>
            <options>
                <option name="Normal"    value="0"></option>
                <option name="Input"     value="1"></option>
                <option name="Output 0"  value="2"></option>
                <option name="Output 1"  value="3"></option>
                <mask/>
            </options>
       </bits>
       <bits name="SPI_CAM_LCD" pos="3:2" access="rw" rst="all0">
            <comment>SPI_CAM to SPI_LCD direct driver select
                <br/>0 = No direct mode, SPI_CAM and SPI_LCD as normal.
                <br/>1 = direct mode, CLK->CLK, DIO->DIO, Z->CS, Z->SDC.
                <br/>2 = HighZ mode, Z->CLK, Z->DIO, Z->CS, Z->SDC.
                <br/>3 = Direct GPIO mode, CLK->CLK, DIO->DIO, GPIO2->CS, GPIO3->SDC.
	    </comment>
            <options>
                <option name="No Direct" value="0"></option>
                <option name="Direct"    value="1"></option>
                <option name="High Z"    value="2"></option>
                <option name="Direct GPIO"  value="3"></option>
                <mask/>
            </options>
        </bits>
        <bits name="FM_Pon" pos="6" access="rw" rst="0">
            <comment>FM power on.
            </comment>
            <options>
                <option name="FM off" value="0"></option>
                <option name="FM on"  value="1"></option>
            </options>
        </bits>
        <bits name="usb_id" pos="16" access="rw" rst="1">
            <options>
                <option name="host mode" value="0"></option>
                <option name="device"    value="1"></option>
            </options>
        </bits>
    </reg>

    <reg name="audio_pd_set" protect="rw">
        <bits name="au_deep_pd_n" pos="0" access="rs" rst="0"> 
            <comment>Power down of all analog audio.
                <br/>0 = Deep Power down
                <br/>1 = Out of Deep Power down
            </comment> 
        </bits>            
        <bits name="au_ref_pd_n" pos="1" access="rs" rst="0"> 
            <comment>Reference audio power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>        
        <bits name="au_mic_pd_n" pos="2" access="rs" rst="0"> 
            <comment>Microphone power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment> 
        </bits>
        <bits name="au_auxmic_pd_n" pos="3" access="rs" rst="0"> 
            <comment>Aux Microphone power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>    
        <bits name="au_ad_pd_n" pos="4" access="rs" rst="0"> 
            <comment>ADC power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment> 
        </bits> 
        <bits name="au_dac_pd_n" pos="5" access="rs" rst="0"> 
            <comment>DAC power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment> 
        </bits> 
        <bits name="au_dac_reset_n" pos="8" access="rs" rst="0"> 
            <comment>Reset audio dac.
                <br/>0 = Reseted
                <br/>1 = Not reseted
            </comment> 
        </bits> 
        
    </reg>

    <reg name="audio_pd_clr" protect="rw">
        <bits name="au_deep_pd_n" pos="0" access="rc" rst="0"> 
            <comment>Power down of all analog audio.
                <br/>0 = Deep Power down
                <br/>1 = Out of Deep Power down
            </comment> 
        </bits>            
        <bits name="au_ref_pd_n" pos="1" access="rc" rst="0"> 
            <comment>Reference audio power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>        
        <bits name="au_mic_pd_n" pos="2" access="rc" rst="0"> 
            <comment>Microphone power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment> 
        </bits> 
        <bits name="au_auxmic_pd_n" pos="3" access="rc" rst="0"> 
            <comment>Aux Microphone power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment> 
        </bits> 
        <bits name="au_ad_pd_n" pos="4" access="rc" rst="0"> 
            <comment>ADC power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment> 
        </bits> 
        <bits name="au_dac_pd_n" pos="5" access="rc" rst="0"> 
            <comment>DAC power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment> 
        </bits>
        <bits name="au_dac_reset_n" pos="8" access="rc" rst="0"> 
            <comment>Reset audio dac.
                <br/>0 = Reseted
                <br/>1 = Not reseted
            </comment> 
        </bits>         
    </reg>
    <reg name="audio_sel_cfg" protect="rw">
        <bits name="au_auxmic_sel" pos="0" access="rw" rst="0"> 
            <comment>Audio aux microphone input select.
                <br/>0 = mic selected
                <br/>1 = auxmic selected
            </comment> 
        </bits> 
        <bits name="au_spk_sel" pos="1" access="rw" rst="0"> 
            <comment>Enable Loudspeaker output.
                <br/>0 = not selected
                <br/>1 = selected
            </comment> 
        </bits> 
        <bits name="au_spk_mono_sel" pos="2" access="rw" rst="0"> 
            <comment>Loudspeaker audio mode select.
                <br/>0 = select Stereo audio mode
                <br/>1 = Select Mono audio mode
            </comment> 
        </bits> 
        <bits name="au_rcv_sel" pos="3" access="rw" rst="0"> 
            <comment>Enable receiver output.
                <br/>0 = not selected
                <br/>1 = selected
            </comment> 
        </bits> 
        <bits name="au_head_sel" pos="4" access="rw" rst="0"> 
            <comment>Enable headphone output.
                <br/>0 = not selected
                <br/>1 = selected
            </comment> 
        </bits> 
        <bits name="au_fm_sel" pos="5" access="rw" rst="0"> 
            <comment>Enable FM output.
                <br/>0 = not selected
                <br/>1 = selected
            </comment> 
        </bits>         
    </reg>
    
    <reg name="audio_mic_cfg" protect="rw">
        <bits name="au_mic_gain" pos="3:0" access="rw" rst="1000"> 
            <comment>Select Microphone gain (default"1000").
            </comment> 
        </bits>  
        <bits name="au_mic_mute_n" pos="4" access="rw" rst="0"> 
            <comment>Microphone mute.
                <br/>0 = Mute
                <br/>1 = Not Mute
            </comment>
        </bits>        
    </reg>
    <reg name="audio_spk_cfg" protect="rw">
        <bits name="au_spk_gain" pos="3:0" access="rw" rst="0"> 
            <comment>Select loudspeaker gain.
            </comment> 
        </bits>          
        <bits name="au_spk_mute_n" pos="4" access="rw" rst="0"> 
            <comment>Loudspeaker audio mute.
                <br/>0 = Mute Audio output
                <br/>1 = Enable Audio output
            </comment>
        </bits>        
    </reg>  
    <reg name="audio_rcv_gain" protect="rw">
        <bits name="au_rcv_gain" pos="3:0" access="rw" rst="0">
            <comment>Select receiver gain.
            </comment>
            <options>
                <mask/>
            </options>
        </bits>
    </reg>
    <reg name="audio_head_gain" protect="rw">
        <bits name="au_head_gain" pos="3:0" access="rw" rst="0">
            <comment>Select headphone gain.
            </comment>
            <options>
                <mask/>
            </options>
        </bits>
    </reg>
    <reg name="thermal_cal" protect="rw">
        <bits name="thermal_cal_value" pos="5:0" access="r" rst="0"> 
            <comment>Select thermalmeter value.
            </comment> 
        </bits>            
        <bits name="thermal_cal_valid" pos="6" access="rw" rst="0"> 
            <comment>Select thermalmeter valid, write 1 to this bit to clear valid.
            </comment> 
        </bits>            
    </reg>    
    <reg name="dbgout_cfg" protect="rw">
        <bits name="dbgout_sel" pos="3:0" access="rw" rst="0"> 
            <comment>Select debug output.
            </comment> 
        </bits>            
        <bits name="dbgout_en" pos="31:16" access="rw" rst="0"> 
            <comment>Debug output enable.
            </comment> 
        </bits>            
    </reg>    
</module>
</archive>





<archive relative = "cholk.xml">
    <module name="cholk" category="Baseband">
    <reg32 name="CHOLK_CTRL" protect="rw">
      <bits name="CHOLK_ON" pos="0" access="rw" rst="0">
	      <comment>write 1 will enable CHOLK module
	      </comment>
      </bits>
      <bits name="CHOLK_INT_MASK" pos="1" access="rw" rst="0">
	      <comment>1:level INT will be masked, 0:level INT will not be masked
	      </comment>
      </bits>   
      <bits name="CHOLK_MODE" pos="2" access="rw" rst="0">
	      <comment>1: Complex mode ; 0: Real mode
	      </comment>
      </bits>      
    </reg32>

    <reg32 name="GAIN" protect="rw">
      <bits name="RESI_GAIN" pos="1:0" access="rw" rst="0">
	      <comment>RESI GAIN
	      </comment>
      </bits> 
  
      <bits name="RESI2_GAIN" pos="3:2" access="rw" rst="0">
	      <comment>RESI2 GAIN
	      </comment>
      </bits> 


      <bits name="OGRS_GAIN" pos="5:4" access="rw" rst="0">
	      <comment>OGRS_GAIN
	      </comment>
      </bits> 


      <bits name="OLES1_GAIN" pos="7:6" access="rw" rst="0">
	      <comment>OLES1_GAIN
	      </comment>
      </bits> 

      <bits name="OLES2_GAIN" pos="9:8" access="rw" rst="0">
	      <comment>OLES2_GAIN
	      </comment>
      </bits> 

      <bits name="COEF_GAIN" pos="11:10" access="rw" rst="0">
	      <comment>COEF_GAIN
	      </comment>
      </bits> 

      <bits name="GRAD_GAIN" pos="13:12" access="rw" rst="0">
	      <comment>GRAD_GAIN
	      </comment>
      </bits> 
                                   
 
      <bits name="GOPS_GAIN" pos="15:14" access="rw" rst="0">
	      <comment>GOPS_GAIN
	      </comment>
      </bits> 

      <bits name="OLES3_GAIN" pos="17:16" access="rw" rst="0">
	      <comment>OLES3_GAIN
	      </comment>
      </bits> 
     </reg32>    

    <reg32 name="ITER_THRE" protect="rw">
      <bits name="ITER_THRE1" pos="15:0" access="rw" rst="0">
	      <comment>ITER_THRE1
	      </comment>
      </bits> 
     </reg32> 

    <reg32 name="MCOVA_BASE" protect="rw">
      <bits name="MCOVA_BASE" pos="12:0" access="rw" rst="0">
	      <comment>Matrix COVA base addr in BBSRAM
	      </comment>
      </bits> 
     </reg32> 

    <reg32 name="MCE_BASE" protect="rw">
      <bits name="MCE_BASE" pos="12:0" access="rw" rst="0">
	      <comment>CE base addr in BBSRAM
	      </comment>
      </bits> 
     </reg32>      

    <reg32 name="MCOEF_BASE" protect="rw">
      <bits name="MCOEF_BASE" pos="12:0" access="rw" rst="0">
	      <comment>COEF base addr in BBSRAM
	      </comment>
      </bits> 
     </reg32>   

    <reg32 name="NUMBER" protect="rw">
      <bits name="ROW_NUMBER" pos="4:0" access="rw" rst="0">
	      <comment>Matrix Row Number, maximal is 24 for Real, and 16 for Complex
	      </comment>
      </bits> 

      <bits name="MCOVA_NUMBER" pos="13:5" access="rw" rst="0">
	      <comment>Matrix COVA effective element number - 1 to read
	      </comment>
      </bits> 
      
      <bits name="ITER_NUMBER" pos="18:14" access="rw" rst="0">
	      <comment>MAXIMAL iteration number - 1 for CHOLK
	      </comment>
      </bits> 
  </reg32> 

   <reg32 name="CHOLK_STATUS" protect="rw">
      <bits name="CHOLK_STATUS" pos="0" access="rw" rst="1">
	      <comment>CHOLK Done status, ACC enable and SW write this bit will clear this Done status, hardware will set this bit when done.
	      </comment>
      </bits> 
  </reg32>  

   <reg32 name="CHOLK_INT" protect="rw">
      <bits name="CHOLK_INT_RAW" pos="0" access="rw" rst="1">
	      <comment>write 0 to this bit will clear CHOLK level RAW interrupt source bit, write 1 will not. read this bit will get raw cholk INT source bit
	      </comment>
      </bits>
      <bits name="CHOLK_INT_out" pos="1" access="r" rst="1">
	      <comment>read this bit will get cholk INT status after masking. INT_out = INT_RAW and ~MASK
	      </comment>
      </bits>                     
   </reg32>                

  </module>
</archive>     
<archive relative = "cipher.xml">
<module name="cipher" category="Baseband">
  <reg protect="rw" name="ctrl">
    <bits access="w" name="Enable" pos="0" rst="no">
        <comment>
            Writing a '1' in this register triggers an A5 process. Ignored if the module is
            already processing. Auto-reset bit
        </comment>
    </bits>
    <bits access="rw" name="Algorithm" pos="4" rst="1">
        <comment>Selects the appropriate algorithm
        </comment>
        <options>
            <option name="A5_1" value="0"/>
            <option name="A5_2" value="1"/>
        </options>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Running" pos="0" rst="0">
      <comment>1 when running, 0 in other case. </comment>
    </bits>
    <bits access="r" name="Data_Blk_Rdy" pos="4" rst="0">
        <comment>1 when data block ready (Ciphering processed), reseted when the data register is read.
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="Kc low">
    <bits access="rw" name="Kc_Lsb" pos="31:0" rst="0xFFFFFFFF" display="hex">
      <comment>Cipher key Kc, LSB bit [31:0].</comment>
    </bits>
  </reg>
  
  <reg protect="rw" name="Kc high">
    <bits access="rw" name="Kc_Msb" pos="31:0" rst="0xFFFFFFFF" display="hex">
      <comment>Cipher key Kc, MSB bit [31:0].</comment>
    </bits>
  </reg>
  
  <reg protect="rw" name="Count">
    <bits access="rw" name="Count" pos="21:0" rst="0x3FFFFFF" display="hex">
      <comment>Count register, this field represent the TDMA frame number.</comment>
    </bits>
  </reg>

  <reg protect="r" name="Data0_block2">
    <bits access="r" name="Data_blk2" pos="31:0" rst="no">
      <comment>Data block2 bit[31:0]</comment>
    </bits>
  </reg>

  <reg protect="r" name="Data1_block2">
      <bits access="r" name="Data_blk2" pos="31:0" rst="no">
      <comment>Data block2 bit[63:32]</comment>
    </bits>
  </reg>

  <reg protect="r" name="Data2_block2">
    <bits access="r" name="Data_blk2" pos="31:0" rst="no">
      <comment>Data block2 bit[95:64]</comment>
    </bits>
  </reg>

  <reg protect="r" name="Data3_block2">
    <bits access="r" name="msb_Data_blk2" pos="17:0" rst="no">
      <comment>Data block2 bit[113:96]</comment>
    </bits>
  </reg>

 <struct count="29" name="Data_block1">
    <reg protect="r" name="Data block1">
      <bits access="r" name="Bit0" pos="7" rst="no">
        <comment> </comment>
      </bits>
      <bits access="r" name="Bit1" pos="15" rst="no">
        <comment> </comment>
      </bits>
      <bits access="r" name="Bit2" pos="23" rst="no">
        <comment> </comment>
      </bits>
      <bits access="r" name="Bit3" pos="31" rst="no">
        <comment> </comment>
      </bits>
    </reg>
  </struct>

</module>
</archive>
<archive relative = "cipher_a53.xml">
<module name="cipher_a53" category="Baseband">
  <reg16 name="CIPH_STAT" protect="rw" >
      <bits access="r" name="RES" pos="15:5" rst="0">
      </bits>
      <bits access="rw" name="A53" pos="4" rst="0"> 
          <comment>
              Select Between A5/1-A5/2 and A5/3 Ciphering Block
          </comment>
      </bits>
      <bits access="rw" name="INIT" pos="3" rst="0"> 
          <comment>
              Initialize A5/3 Ciphering
          </comment>
      </bits>
      <bits access="rw" name="EDGE" pos="2" rst="0">
          <comment>
              Select Ciphering Blcok Size
          </comment>
      </bits>
      <bits access="rw" name="A52" pos="1" rst="0"> 
          <comment>
              Switch Between A5/1 and A5/2 Algorithm if A5/1-A5/2 Block is Selected
          </comment>
      </bits>
      <bits access="rw" name="CACT" pos="0" rst="0"> 
          <comment>
              Status and Activation of Ciphering Block
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register0" protect="rw" >
      <bits access="rw" name="KEY0" pos="15:0" rst="0">
          <comment>
              Cipher Key0
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register1" protect="rw" >
      <bits access="rw" name="KEY1" pos="15:0" rst="0">
          <comment>
              Cipher Key1
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register2" protect="rw" >
      <bits access="rw" name="KEY2" pos="15:0" rst="0">
          <comment>
              Cipher Key2
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register3" protect="rw" >
      <bits access="rw" name="KEY3" pos="15:0" rst="0">
          <comment>
              Cipher Key3
          </comment>
      </bits>
  </reg16>

  <reg16 name="TMOD26" protect="rw" >
      <bits access="rw" name="A52_RES_TMOD26" pos="15:5" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="rw" name="A52_T26N" pos="4:0" rst="0">
          <comment>
          </comment>
      </bits>
  </reg16>

  <reg16 name="TMOD51" protect="rw" >
      <bits access="rw" name="A52_RES_TMOD51" pos="15:6" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="rw" name="A52_T51N" pos="5:0" rst="0">
          <comment>
          </comment>
      </bits>
  </reg16>

  <reg16 name="SFNUM" protect="rw" >
      <bits access="rw" name="A52_RES_SFNUM" pos="15:11" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="rw" name="A52_SFN" pos="10:0" rst="0">
          <comment>
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register4" protect="rw" >
      <bits access="rw" name="KEY4" pos="15:0" rst="0">
          <comment>
              Cipher Key4
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register5" protect="rw" >
      <bits access="rw" name="KEY5" pos="15:0" rst="0">
          <comment>
              Cipher Key5
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register6" protect="rw" >
      <bits access="rw" name="KEY6" pos="15:0" rst="0">
          <comment>
              Cipher Key6
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register7" protect="rw" >
      <bits access="rw" name="KEY7" pos="15:0" rst="0">
          <comment>
              Cipher Key7
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Data1" protect="rw" >
      <bits access="rw" name="CA" pos="15:8" rst="0">
          <comment>
              GSM mode:00001111
              EDGE mode:11110000
          </comment>
      </bits>
      <bits access="rw" name="CB" pos="7:3" rst="0">
          <comment>
              CB=0000
          </comment>
      </bits>
      <bits access="rw" name="CD" pos="2" rst="0">
          <comment>
              CD=0
          </comment>
      </bits>
      <bits access="r" name="RES_KEY_DAT1" pos="1:0" rst="0">
          <comment>
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Data2" protect="rw" >
      <bits access="rw" name="CE" pos="15:0" rst="0">
          <comment>
              CE=0000000000000000
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Data3" protect="rw" >
      <bits access="r" name="RES_15_14" pos="15:14" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="rw" name="SFN_10_5" pos="13:8" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="r" name="RES_7_0" pos="7:0" rst="0">
          <comment>
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Data4" protect="rw" >
      <bits access="rw" name="SFN_4_0" pos="15:11" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="rw" name="T51N" pos="10:5" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="rw" name="T26N" pos="4:0" rst="0">
          <comment>
          </comment>
      </bits>
  </reg16>

  <reg16 name="unused1" protect="rc" count="112" >
  </reg16>

  <reg16 name="block1" protect="rw" count="8" >
  </reg16>

  <reg16 name="unused2" protect="rc" count="24" >
  </reg16>

  <reg16 name="block2" protect="rw" count="8" >
  </reg16>

</module>

<module name="cipher_a53_spram" category="System">
    <memory name="spram_array" size="64*2">
        <comment>cipher_a53 internal Spram space
        </comment>
    </memory>
</module>

</archive>

<archive relative = "comregs.xml">
<module name="comregs" category="Modem">
    <reg name="Snapshot" protect="r">
        <bits name="Snapshot" pos="1:0" access="r" rst="0">
            <comment>Value of snapshots, snapshot value is automatically incremented at frame interrupt. This snapshot counter wrap at the value given by Snapshot_Cfg.
            </comment>
        </bits>
    </reg>
    <reg name="Snapshot_Cfg" protect="rw">
        <bits name="Snapshot_Cfg"  pos="0" access="rw" rst="0">
            <comment>Number of snapshot.
            </comment>
          </bits>
        <bits name="Snapshot_Cfg_rd"  pos="1" access="r" rst="1">
        </bits>          
    </reg>
    <reg name="Cause" protect="r">
        <bits name="Irq0_Cause" pos="7:0" access="r" rst="0">
            <comment>When read from the Xcpu, this return the cause of interruption, basically the set/clear register Irq0 part masked with Irq0_Mask.
                <br/>When read from the Bcpu, this return the cause of interruption, basically the set/clear register Irq0 part masked with Irq0_Mask.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Irq1_Cause" pos="15:8" access="r" rst="0">
            <comment>When read from the Xcpu, this return the cause of interruption, basically the set/clear register X_Irq1 part masked with X_Irq1_Mask.
                <br/>When read from the Bcpu, this return the cause of interruption, basically the set/clear register Irq1 part masked with Irq1_Mask.
            </comment>
            <options><mask/><shift/></options>
        </bits>
    </reg>
    <reg name="Mask_Set" protect="rw">
        <bits name="Irq0_Mask_Set" pos="7:0" access="rs" rst="0">
            <comment>When read: returns the value of the Irq0_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' sets the corresponding bit in the Irq0_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The Irq0_Mask masks the set/clear register to trigger interrupts on the XCPU/BCPU using line 0.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Irq1_Mask_Set" pos="15:8" access="rs" rst="0">
            <comment>When read: returns the value of the Irq1_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' sets the corresponding bit in the Irq1_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The Irq1_Mask masks the set/clear register to trigger interrupts on the XCPU/BCPU using line 1.
            </comment>
           <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="Mask_Clr" protect="rw">
        <bits name="Irq0_Mask_Clr" pos="7:0" access="rc" rst="0">
            <comment>When read: returns the value of the Irq0_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' clears the corresponding bit in the Irq0_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The Irq0_Mask masks the set/clear register to trigger interrupts on the XCPU/BCPU using line 0.
             </comment>
            <options><mask/><shift/><default/></options>
         </bits>
        <bits name="Irq1_Mask_Clr" pos="15:8" access="rc" rst="0">
            <comment>When read: returns the value of the Irq1_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' clears the corresponding bit in the Irq1_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The Irq1_Mask masks the set/clear register to trigger interrupts on the XCPU/BCPU using line 1.
             </comment>
             <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="ItReg_Set" protect="rw">
        <comment>If accesses to ItReg_Set and ItReg_Clr registers are done simultaneously from both CPUs and affecting the same bits, the priority is given to set a bit.</comment>
        <bits name="Irq0_Set" pos="7:0" access="rs" rst="0">
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' sets the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the XCPU/BCPU if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Irq1_Set" pos="15:8" access="rs" rst="0">
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' sets the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the XCPU/BCPU if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bitgroup name="Irq">
            <entry ref="Irq0_Set"/>
            <entry ref="Irq1_Set"/>
        </bitgroup>
    </reg>
    
    <reg name="ItReg_Clr" protect="rw">
        <comment>If accesses to ItReg_Set and ItReg_Clr registers are done simultaneously from both CPUs and affecting the same bits, the priority is given to set a bit.</comment>
        <bits name="Irq0_Clr" pos="7:0" access="rc" rst="0">
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the XCPU/BCPU if enabled.
            </comment>
        </bits>
        <bits name="Irq1_Clr" pos="15:8" access="rc" rst="0">
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the XCPU/BCPU if enabled.
            </comment>
        </bits>
    </reg>

</module>
</archive>

<archive relative = "cordic.xml">

<module name="cordic" category="Baseband">

  <reg name="yin" protect="rw">
    <bits access="rw" name="y_addr" pos="31:0" rst="0x0">
      <comment>Control setting. y, i.e. numerator of atan computation. </comment>
    </bits>
  </reg>

  <reg name="xin" protect="rw">
    <bits access="rw" name="x_addr" pos="31:0" rst="0x0">
      <comment>Control setting. x, i.e. denominator of atan computation. </comment>
    </bits>
  </reg>

  <reg name="cmd" protect="rw">
    <bits access="rw" name="cmd" pos="0:0" rst="0x0">
      <comment>The start signal. Use the posedge of this signal. </comment>
      <options>
          <option name="RST" value="0"></option>
          <option name="START" value="1"></option>
      </options>
    </bits>
  </reg>

  <reg name="status" protect="r">
    <bits access="r" name="op" pos="31:0" rst="0x0">
      <comment>Status is set to 1 when an operation is finished. </comment>
      <options>
          <option name="Busy" value="0x00000000"></option>
          <option name="Free" value="0xFFFFFFFF"></option>
      </options>
    </bits>
  </reg>


  <reg name="dout" protect="r">
    <bits access="r" name="result_angle" pos="15:0" rst="0x0">
        <comment>. angle. The actual value is angle*pi/4</comment>
    </bits>
    <bits access="r" name="result_amplitude" pos="31:16" rst="0x0">
      <comment>amplitude.</comment>
    </bits>
  </reg>

  <reg name="amp" protect="r">
    <bits access="r" name="result_amp" pos="16:0" rst="0x0">
      <comment>amplitude only.</comment>
      <options>
          <mask/>
      </options>
    </bits>
  </reg>

</module>

</archive>
<archive relative = "cp0.xml" asm="no">
<cjoker>

/* Cause register exception codes */

#define ExcCode(x)      ((x)&lt;&lt;2)

/* Hardware exception codes */
#define ExcCode_INT     ExcCode(0)      /* interrupt */
#define ExcCode_MOD     ExcCode(1)      /* TLB modification */
#define ExcCode_TLBL    ExcCode(2)      /* TLB miss, load or fetch */
#define ExcCode_TLBS    ExcCode(3)      /* TLB miss, store */
#define ExcCode_AdEL    ExcCode(4)      /* Read Address Error */
#define ExcCode_AdES    ExcCode(5)      /* Write Address Error */
#define ExcCode_IBE     ExcCode(6)      /* Instruction Bus Error */
#define ExcCode_DBE     ExcCode(7)      /* Data Bus Error */
#define ExcCode_SYSCALL ExcCode(8)      /* SYSCALL */
#define ExcCode_BREAK   ExcCode(9)      /* BREAKpoint */
#define ExcCode_RI      ExcCode(10)     /* Illegal Instruction */
#define ExcCode_CpU     ExcCode(11)     /* CoProcessor Unusable */
#define ExcCode_Ovf     ExcCode(12)     /* OVerflow */

/*
 * cp0 registers
 */
#define Index           $0
#define Random          $1
#define EntryLo         $2
#define Context         $4
#define BadVAddr        $8
#define EntryHi         $10
#define Status          $12
#define Cause           $13
#define EPC             $14
#define PRId            $15


/*
 * Mask for Index Register
 */
#define Index_P         0x80000000      /* Probe Failure bit */
#define Index_Index     0x00003f00      /* Index field */

/*
 * Random register 
 */
#define Random_Index    0x00003f00      /* Random field */

/*
 * Entry Low
 */
#define EntryLo_PFN     0xfffff000      /* page frame number field */
#define EntryLo_N       0x00000800      /* non cachable */
#define EntryLo_D       0x00000400      /* dirty */
#define EntryLo_V       0x00000200      /* valid bit */
#define EntryLo_G       0x00000100      /* global bit */

/*
 * Context register 
 */
#define Context_PTEBase 0xffe00000      /* base for page table entry */
#define Context_BadVPN  0x001ffffc      /* failing virtual page number */

/*
 * Entry High Register
 */
#define EntryHi_VPN     0xfffff000      /* virtual page number field */
#define EntryHi_PID     0x00000fc0      /* process ID field */

/*
 * PRId Register
 */
#define PRID_Imp        0x0000ff00      /* implementation ID */
#define PRID_Rev        0x000000ff      /* revision ID */

/*
 * Status register
 */
#define Status_CUMASK   0xf0000000      /* coproc usable bits */
#define Status_RE       0x02000000      /* Bootstrap exception vector */
#define Status_BEV      0x00400000      /* Bootstrap exception vector */
#define Status_TS       0x200000        /* TLB Shutdown bit */
#define Status_IntMASK  0xff00          /* Interrupt mask */
#define Status_KUo      0x0020          /* old kernel/user, 0 =&gt; k, 1 =&gt; u */
#define Status_IEo      0x0010          /* old interrupt enable, 1 =&gt; ena */
#define Status_KUp      0x0008          /* prev kernel/user, 0 =&gt; k, 1 =&gt; u */
#define Status_IEp      0x0004          /* prev interrupt enable, 1 =&gt; ena */
#define Status_KUc      0x0002          /* cur kernel/user, 0 =&gt; k, 1 =&gt; u */
#define Status_IEc      0x0001          /* cur interrupt enable, 1 =&gt; enable*/

/*
 * Cause Register
 */
#define Cause_BD        0x80000000      /* Branch delay slot */
#define Cause_CE        0x30000000      /* coprocessor error */
#define Cause_IP        0xff00          /* Pending interrupt mask */
#define Cause_SIP       0x0300          /* Pending software interrupt mask */
#define Cause_HIP       0xfc00          /* Pending hardware interrupt mask */
#define Cause_ExcCode   0x003C          /* Exception code bits */

#define DRAM_HANDLER    0x80c00200      /* address of exception handler */
#define EPROM_HANDLER   0xa0e00180      /* address of exception handler BEV */

</cjoker>
</archive>

<archive relative = "debug_host.xml">


<module name="debug_host" category="Debug">
  <reg protect="--" name="cmd">
    <bits access="r" name="Addr" pos="28:0" rst="-">
      <comment>Address of data to be read or written. </comment>
    </bits>

    <bits access="r" name="Size" pos="30:29" rst="-">
      <comment>These two bits indicates element data size. <br />
            when "00" = "byte". <br />
            when "01" = "half word". <br />
            when "10" = "word". 
        </comment>
    </bits>

    <bits access="r" name="Write_H" pos="31" rst="-">
      <comment>This bit indicates command is read or write. <br />
        when "0" = "Read". <br />
        when "1" = "Write".  
      </comment>
    </bits>

  </reg>

  <reg protect="--" name="data">
    <bits access="rw" name="data" pos="31:0" rst="-">
      <comment>Those bits are data to be read or written by IFC. </comment>
    </bits>
    
  </reg>

  <reg protect="rw" name="event">
    <bits access="rw" name="event0_sema" pos="0" rst="0">
      <comment>When read, this bit is used for event semaphore. <br />
            '0' = no new event should be programed. <br />
            '1' = no pending event, new event is authorised. <br />
            If host is not enabled, this bit is always '1'. However in this case, 
            any event written will be ignored. <br />
            When Write, this bit is the least significant bit for a 32-bit event.
      </comment>
    </bits>

    <bits access="w" name="event31_1" pos="31:1" rst="-">
      <comment> These bits combined with bit0 consists a 32-bit event number. If a
            new event is written before the previous event has been sent, it will 
            be ignored. 
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="mode">
    <bits access="rw" name="force_on" pos="0" rst="1">
      <comment>When '1', force the debug host on, use clock UART if clock host is not
            detected. </comment>
    </bits>

    <bits access="r" name="Clk_Host_On" pos="1" rst="0">
      <comment>This bit indicates if clock host is detected to be on or not. <br />
            '0' = no clock host. <br />
            '1' = clock host detected. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="h2p_status">
    <bits access="r" name="h2p_status" pos="7:0" rst="0">
      <comment>Status which can be written through debug uart interface into a debug host
            internal register and read by APB. </comment>
      <options>
        <mask/>
        <shift/>
      </options>
    </bits>
    <bits access="w" name="h2p_status_rst" pos="16" rst="0">
      <comment>write in this bit will reset h2p status register. </comment>
    </bits>
  </reg>
  
  <reg protect="rw" name="p2h_status">
    <bits access="rw" name="p2h_status" pos="7:0" rst="0">
      <comment>Status which can be written by APB and read through debug uart interface 
            as a debug host internal register.
      </comment>
    </bits>
  </reg>
  
  <reg protect="r" name="irq">
    <bits access="r" name="xcpu_irq" pos="0" rst="0">
      <comment>when write '1', clear the xcpu irq level which is programmed in a debug host
          internal register, this bit is automatic cleared. <br /> when read, get the xcpu
          irq status. </comment>
    </bits>
    
    <bits access="r" name="bcpu_irq" pos="1" rst="0">
      <comment>when write '1', clear the bcpu irq level which is programmed in a debug host
            internal register, this bit is automatic cleared.<br /> when read, get the bcpu
            irq status.</comment>
    </bits>
    
  </reg>
</module>



</archive>

<archive relative = "debug_host_internals.xml">

<include file="globals.xml"/>

	<module name="debug_host_internal_registers" category="Debug">
		<ireg name="CTRL_SET" protect="rw">
			<comment>General control signals set.</comment>
			<bits name="Debug_Reset" pos="0" rst="0" access="rs">
				<comment>Debug host generated reset. Signal to system control. Active high.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="XCPU_Force_Reset" pos="1" rst="0" access="rs">
				<comment>Force XCPU Reset signal. Active high. Hold XCPU in reset state until this bit is cleared.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_Wakeup" pos="2" rst="0" access="rs">
				<comment>Force wakeup. Active high.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_BP_XCPU" pos="3" rst="0" access="rs">
				<comment>Force XCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by XCPU.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="Force_BP_BCPU" pos="4" rst="0" access="rs">
				<comment>Force BCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by BCPU.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="IT_XCPU" pos="5" rst="0" access="rs">
				<comment>When write '1, generate a level IRQ to XCPU. Write '0 is ignored. This IRQ can be cleared by written APB register. When Read, Get the IRQ status.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="IT_BCPU" pos="6" rst="0" access="rs">
				<comment>When write '1', generate a level IRQ to BCPU. Write '0' is ignored. This IRQ can be cleared by written APB register. When Read, Get the IRQ status.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="Debug_Port_Lock" pos="7" rst="0" access="rs">
				<comment>Lock Debug port set.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
		</ireg>
		
		<ireg name="CTRL_CLR" protect="rw">
			<comment>General control signals clear.</comment>		
			<bits name="XCPU_Force_Reset" pos="1" rst="0" access="rc">
				<comment>Force XCPU Reset signal. Active high. Hold XCPU in reset state until this bit is cleared.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_Wakeup" pos="2" rst="0" access="rc">
				<comment>Force wakeup. Active high.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_BP_XCPU" pos="3" rst="0" access="rc">
				<comment>Force XCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by XCPU.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>	
			<bits name="Force_BP_BCPU" pos="4" rst="0" access="rc">
				<comment>Force BCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by BCPU.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="Debug_Port_Lock" pos="7" rst="0" access="rc">
				<comment>Lock Debug port clear.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>            
		</ireg>

		<ireg name="CLKDIV" protect="rw">
			<comment>Configure Debug UART Clock divider.</comment>
			<bits name="CFG_CLK" pos="5:0" rst="2" access="rw">
				<comment>Debug host clock divider. The serial clock is generated by dividing  14,7456MHz Host Clock by (CFG_CLK+2). So By default, the serial clock is 14,7456MHz / (2+2) = 3,6864 MHz which corresponds to the 921,6K Baud-rate.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
        </ireg>

		<ireg name="CFG" protect="rw">
			<comment>Configure Debug UART.</comment>
			<bits name="Disable_Uart_H" pos="0" rst="0" access="rw">
                <comment>When '1', Disable Normal Uart functional group.
                    <br/>This bit is set to '1' when break.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name="Disable_IFC_H" pos="1" rst="0" access="rw">
                <comment>When '1', Ignore IFC write and read access so only debug host internal is accessible.
                    <br/>This bit is set to '1' when break.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name="Debug_Host_Sel" pos="2" rst="0" access="rw">
                <comment>The usage of this bit is deternimed by the specific chip.
                    <br/>Can be used as Debug_Port_Lock register to protect some register change by the regular software while debug hosr is used to set thoses registers to specific values.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name="Force_Prio_H" pos="7" rst="1" access="rw">
				<comment>When '1', force the Debug Uart to have priority on TX.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>	
        </ireg>
        

		<ireg name="CRC_REG" protect="rw">
			<comment>Status of CRC.</comment>
			<bits name="CRC" pos="0" rst="0" access="rc">
				<comment>This bit represents that an CRC error has occured in commands received by Debug Host. Once set to '1', it will keep the value until this register is clearred by write '1'.<br/>'0' = no CRC error.<br/>'1' = CRC error.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="FC_Fifo_Ovf" pos="1" rst="0" access="r">
				<comment>This bit represents if the 16-byte Flow Control FIFO has an overflow error. This status will be kept until a RX break is received.<br/>'0' = no Flow Control Overflow Error.<br/>'1' = Flow Control Overflow Error.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>
			
		<ireg name="H2P_STATUS" protect="rw">
			<comment>Host write, APB readable register.</comment>
			<bits name="STATUS" pos="7:0" rst="0" access="rw">
				<comment>These bits can be read by APB and write by host. Corresponds to APB register STATUS. They can also be reseted to zeros by APB command. (see details in debug host APB register mapping) <br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>

		<ireg name="P2H_STATUS" protect="rw">
			<comment>APB write, Host readable register.</comment>
			<bits name="STATUS" pos="7:0" rst="0" access="rw">
				<comment>These bits can be written by APB and read by host. Corresponds to APB register STATUS.<br/>Write to Bit 0 can reset the P2H status.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>

		<ireg name="AHB_SYS_HMBURSREQ" protect="r">
			<comment>Debug information of system side AHB bus status.</comment>
			<bits name="SYS_IFC_HMBURSREQ" pos="0" rst="-" access="r">
				<comment>The bit represent Sys Ifc HMBURSREQ.</comment>
			</bits>
			<bits name="SYS_DMA_HMBURSREQ" pos="1" rst="-" access="r">
				<comment>The bit represent Dma HMBURSREQ.</comment>
			</bits>
			<bits name="SYS_AHB2AHB_HMBURSREQ" pos="2" rst="-" access="r">
				<comment>The bit represent Sys Ahb2ahb HMBURSREQ.</comment>
			</bits>
			<bits name="XCPU_HMBURSREQ" pos="3" rst="-" access="r">
				<comment>The bit represent Xcpu HMBURSREQ.</comment>
            </bits>
			<bits name="USBC_HMBURSREQ" pos="4" rst="-" access="r">
				<comment>The bit represent USBC HMBURSREQ.</comment>
            </bits>
			<bits name="GOUDA_HMBURSREQ" pos="5" rst="-" access="r">
				<comment>The bit represent GOUDA HMBURSREQ.</comment>
            </bits>
		</ireg>
            
		<ireg name="AHB_SYS_HMGRANT" protect="r">
			<bits name="SYS_IFC_HMGRANT" pos="0" rst="-" access="r">
				<comment>The bit represent Sys Ifc HMGRANT.</comment>
			</bits>
			<bits name="SYS_DMA_HMGRANT" pos="1" rst="-" access="r">
				<comment>The bit represent Dma HMGRANT.</comment>
			</bits>
			<bits name="SYS_AHB2AHB_HMGRANT" pos="2" rst="-" access="r">
				<comment>The bit represent Sys Ahb2ahb HMGRANT.</comment>
			</bits>
			<bits name="XCPU_HMGRANT" pos="3" rst="-" access="r">
				<comment>The bit represent Xcpu HMGRANT.</comment>
			</bits>
			<bits name="USBC_HMGRANT" pos="4" rst="-" access="r">
				<comment>The bit represent USBC HMGRANT.</comment>
            </bits>
			<bits name="GOUDA_HMGRANT" pos="5" rst="-" access="r">
				<comment>The bit represent GOUDA HMGRANT.</comment>
            </bits>            
		</ireg>
	
		<ireg name="AHB_SYS_HSEL" protect="r">
			<comment>Debug information of AHB bus status HSEL.</comment>
			<bits name="SYS_MEM_EXT_HSEL" pos="0" rst="-" access="r">
				<comment>The bit represent Sys MEM_EXT HSEL.</comment>
			</bits>
			<bits name="SYS_MEM_INT_HSEL" pos="1" rst="-" access="r">
				<comment>The bit represent Sys MEM_INT HSEL.</comment>
			</bits>
			<bits name="SYS_IFC_HSEL" pos="2" rst="-" access="r">
				<comment>The bit represent Sys Ifc HSEL.</comment>
			</bits>
			<bits name="SYS_AHB2AHB_HSEL" pos="3" rst="-" access="r">
				<comment>The bit represent Sys Ahb2ahb HSEL.</comment>
			</bits>
			<bits name="SYS_USBC_HSEL" pos="4" rst="-" access="r">
				<comment>The bit represent USBC HSEL.</comment>
            </bits>
			<bits name="SYS_GOUDA_HSEL" pos="5" rst="-" access="r">
				<comment>The bit represent GOUDA HSEL.</comment>
            </bits>               
			<bits name="SYS_XCPU_RAM_HSEL" pos="6" rst="-" access="r">
				<comment>The bit represent XCPU RAM HSEL.</comment>
            </bits>               
		</ireg>

		<ireg name="AHB_SYS_HSREADY" protect="r">
			<bits name="SYS_IFC_HSREADY" pos="0" rst="-" access="r">
				<comment>The bit represent Sys Ifc HSREADY.</comment>
			</bits>
			<bits name="SYS_MEM_HSREADY" pos="1" rst="-" access="r">
				<comment>The bit represent Sys EBC HSREADY.</comment>
			</bits>
			<bits name="SYS_AHB2AHB_HSREADY" pos="2" rst="-" access="r">
				<comment>The bit represent Sys Ahb2ahb HSREADY.</comment>
            </bits>
			<bits name="SYS_USBC_HSREADY" pos="4" rst="-" access="r">
				<comment>The bit represent USBC HSREADY.</comment>
            </bits>
			<bits name="SYS_GOUDA_HSREADY" pos="5" rst="-" access="r">
				<comment>The bit represent GOUDA HSREADY.</comment>
            </bits>               
			<bits name="SYS_XCPU_RAM_HSREADY" pos="6" rst="-" access="r">
				<comment>The bit represent XCPU RAM HSREADY.</comment>
            </bits>              
			<bits name="SYS_HREADY" pos="7" rst="-" access="r">
				<comment>The bit represent Sys HSREADY which is sent to all sys AHB slaves.</comment>
			</bits>
		</ireg>

		<ireg name="AHB_BB_MASTER" protect="r">
			<comment>Debug information of baseband side AHB bus status.</comment>
			<bits name="BB_IFC_HMBURSREQ" pos="0" rst="-" access="r">
				<comment>The bit represent BB Ifc HMBURSREQ.</comment>
			</bits>
			<bits name="BB_VOC_HMBURSREQ" pos="1" rst="-" access="r">
				<comment>The bit represent Voc HMBURSREQ.</comment>
			</bits>
			<bits name="BB_AHB2AHB_HMBURSREQ" pos="2" rst="-" access="r">
				<comment>The bit represent BB Ahb2ahb HMBURSREQ.</comment>
			</bits>
			<bits name="BCPU_HMBRSREQ" pos="3" rst="-" access="r">
				<comment>The bit represent Bcpu HMBURSREQ.</comment>
			</bits>
			<bits name="BB_IFC_HMGRANT" pos="4" rst="-" access="r">
				<comment>The bit represent BB Ifc HMGRANT.</comment>
			</bits>
			<bits name="BB_VOC_HMGRANT" pos="5" rst="-" access="r">
				<comment>The bit represent Voc HMGRANT.</comment>
			</bits>
			<bits name="BB_AHB2AHB_HMGRANT" pos="6" rst="-" access="r">
				<comment>The bit represent BB Ahb2ahb HMGRANT.</comment>
			</bits>
			<bits name="BCPU_HMGRANT" pos="7" rst="-" access="r">
				<comment>The bit represent Bcpu HMGRANT.</comment>
			</bits>
		</ireg>

		<ireg name="AHB_BB_HSREADY" protect="r">
			<comment>Debug information of AHB bus status HSEL.</comment>
			<bits name="BB_MEM_HSREADY" pos="0" rst="-" access="r">
				<comment>The bit represent BB MEM HSREADY.</comment>
            </bits>
			<bits name="BB_VOC_HSREADY" pos="1" rst="-" access="r">
				<comment>The bit represent BB VoC HSREADY.</comment>
			</bits>
			<bits name="BB_SRAM_HSREADY" pos="2" rst="-" access="r">
				<comment>The bit represent BB Sram HSREADY.</comment>
			</bits>
			<bits name="BB_IFC_HSREADY" pos="3" rst="-" access="r">
				<comment>The bit represent BB Ifc HSREADY.</comment>
			</bits>
			<bits name="BB_AHB2AHB_HSREADY" pos="4" rst="-" access="r">
				<comment>The bit represent BB Ahb2ahb HSREADY.</comment>
			</bits>
			<bits name="BB_HREADY" pos="7" rst="-" access="r">
				<comment>The bit represent BB HREADY which is sent to all BB AHB slaves.</comment>
			</bits>
		</ireg>

		<ireg name="AHB_BB_HSEL" protect="r">
			<comment>Debug information of AHB bus status HSEL.</comment>
			<bits name="BB_MEM_EXT_HSEL" pos="0" rst="-" access="r">
				<comment>The bit represent BB MEM_EXT HSEL.</comment>
			</bits>
			<bits name="BB_MEM_INT_HSEL" pos="1" rst="-" access="r">
				<comment>The bit represent BB MEM_INT HSEL.</comment>
			</bits>
			<bits name="BB_VOC_HSEL" pos="2" rst="-" access="r">
				<comment>The bit represent BB VOC HSEL.</comment>
			</bits>
			<bits name="BB_SRAM_HSEL" pos="3" rst="-" access="r">
				<comment>The bit represent BB Sram HSEL.</comment>
			</bits>
			<bits name="BB_IFC_HSEL" pos="4" rst="-" access="r">
				<comment>The bit represent BB Ifc HSEL.</comment>
			</bits>
			<bits name="BB_AHB2AHB_HSEL" pos="5" rst="-" access="r">
				<comment>The bit represent BB Ahb2ahb HSEL.</comment>
			</bits>
		</ireg>

		<ireg name="AHB_SYS_MASK_SPLIT" protect="r">
            <comment>Represents the split status register of the SYS_AHBC.</comment>
            <bits name="Sys_Mask_Split" pos="SYS_NB_MASTERS-1:1" access="r" rst="-" cut="1" cutenum="Sys_Master_Id" cutprefix="Mask_Split" cutstart="1">
            </bits>
		</ireg>
		<ireg name="AHB_BB_MASK_SPLIT" protect="r">
            <comment>Represents the split status register of the BB_AHBC.</comment>
            <bits name="BB_Mask_Split" pos="BB_NB_MASTERS:1" access="r" rst="-" cut="1" cutenum="BB_Master_Id" cutprefix="Mask_Split" cutstart="1">
            </bits>
		</ireg>
        
	</module>

</archive>

<archive relative = "debug_host_test_chip.xml">

  <include file="debug_host.xml" />
  <include file="debug_host_internals.xml" />


</archive>


<archive relative = "debug_uart.xml">
<module name="debug_uart" category="System">
  <var  name="DEBUG_UART_RX_FIFO_SIZE"    value="16"  />
  <var  name="DEBUG_UART_TX_FIFO_SIZE"    value="16"  />
  <var  name="DEBUG_UART_NB_RX_FIFO_BITS" value="4"   />
  <var  name="DEBUG_UART_NB_TX_FIFO_BITS" value="4"   />
  <var  name="ESC_DAT"                    value="92"  />
  
  <reg protect="rw" name="ctrl">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Allows to turn off the UART:<br />0 = Disable<br />1 = Enable
      </comment>
    </bits>

    <bits access="rw" name="Data Bits" pos="1" rst="0">
      <options>
        <option name="7_BITS" value="0" />

        <option name="8_BITS" value="1" />

        <default />
      </options>

      <comment>Number of data bits per character (least significant bit
          first):<br />0 = 7 bits<br />1 = 8 bits <br /> This bit will be masked to
          '1' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Tx Stop Bits" pos="2" rst="0">
      <options>
        <option name="1_BIT" value="0" />

        <option name="2_BITS" value="1" />

        <default />
      </options>

      <comment>Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).<br />0 = one stop bit is
      transmitted in the serial data.<br />1 = two stop bits are generated and
      transmitted in the serial data out. <br /> This bit will be masked to
      '0' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Parity Enable" pos="3" rst="0">
      <options>
        <option name="NO" value="0" />

        <option name="YES" value="1" />

        <default />
      </options>

      <comment> Parity is enabled when this bit is set. <br /> This bit will be masked to
      '0' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Parity Select" pos="5:4" rst="0">
      <options>
        <option name="ODD" value="0" />

        <option name="EVEN" value="1" />

        <option name="SPACE" value="2" />

        <option name="MARK" value="3" />

        <default />
      </options>

      <comment> Controls the parity format when parity is enabled:<br />00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).<br />01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).<br />10 = a space is
      generated and received as parity bit.<br />11 = a mark is generated and
      received as parity bit. <br /> These bit will be ignored if debug host is
      enabled. </comment>
    </bits>

    <bits access="rw" name="Tx Break Control" pos="6" rst="0">
      <comment> Sends a break signal by holding the Uart_Tx line low until
          this bit is cleared.<br /> This bit will be masked to '0' if debug host
          is enabled. </comment>
      <options>
        <option name="OFF" value="0" />
        <option name="ON"  value="1" />
        <default />
      </options>
    </bits>

   <bits access="rw" name="RX FIFO RESET" pos="7" rst="0">
      <comment>reset rx fifo. </comment>
   </bits>

   <bits access="rw" name="TX FIFO RESET" pos="8" rst="0">
      <comment>reset tx fifo. </comment>
   </bits>


    <bits access="rw" name="DMA Mode" pos="9" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC. </comment>
    </bits>

    <bits access="rw" name="SWRX flow ctrl" pos="13:12" rst="1">
        <comment> When this field is "00" and SWTX_flow_Ctrl is also "00", hardwre
            flow ctrl is used. Otherwise, software flow control is used: <br />
            00 = no transmit flow control. <br />
            01 = transmit XON1/XOFF1 as flow control bytes<br />
            10 = transmit XON2/XOFF2 as flow control bytes<br />
            11 = transmit XON1 and XON2/XOFF1 and XOFF2 as flow control bytes<br />
        </comment>
        <options><default/><mask/><shift/></options>
    </bits>

    <bits access="rw" name="SWTX flow ctrl" pos="15:14" rst="1">
        <comment> When this field is "00" and SWRX_flow_Ctrl is also "00", hardwre
            flow ctrl is used. Otherwise, software flow control is used: <br />
            00 = no receive flow control<br />
            01 = receive XON1/XOFF1 as flow control bytes<br />
            10 = receive XON2/XOFF2 as flow control bytes<br />
            11 = receive XON1 and XON2/XOFF1 and XOFF2 as flow control bytes<br />
            <br /> Note: If single XON/XOFF character is used for flow contol, the received 
            XON/XOFF character will not be put into Rx FIFO. This is also the case if XON is
            received when XOFF is expected. <br />
            If double XON/XOFF characters are expected, the XON1/XOFF1 must followed sequently 
            by XON2/XOFF2 to be considered as patterns, which will not be put into Rx FIFO. 
            Otherwise they will be considered as data. This is also the case if XOFF1 is followed
            by character other than XOFF2. <br />
        </comment>
        <options><default/><mask/><shift/></options>
    </bits>

    <bits access="rw" name="BackSlash En" pos="16" rst="1">
        <comment> When soft flow control characters or backslash are encountered in the data file, 
            they will be inverted and a backslash will be added before them. for example, if tx data
            is XON(0x11) with BackSlash_En = '1', then uart will send 5Ch(Backslash) + EEh (~XON).
        </comment>
    </bits>    
    
    <bits access="rw" name="Tx Finish n Wait" pos="19" rst="0">
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>

    <bits access="rw" name="Divisor Mode" pos="20" rst="0">
      <comment>Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.<br />0 =
      (BCLK = SCLK / 4)<br />1 = (BCLK = SCLK / 16) <br /> This bit will be
      masked to '0' if debug host is enabled.</comment>
    </bits>

    <bits access="rw" name="IrDA Enable" pos="21" rst="0">
      <comment>When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details). <br /> This bit will be
      masked to '0' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Rx RTS" pos="22" rst="0">
      <comment>Controls the Uart_RTS output (not directly in auto flow control
      mode).<br />0 = the Uart_RTS will be inactive high<br />1 = the Uart_RTS
      will be active low <br /> This bit will be masked to '1' if debug host is
      enabled. </comment>
      <options>
        <option name="INACTIVE" value="0" />
        <option name="ACTIVE"  value="1" />
        <default />
      </options>
    </bits>

    <bits access="rw" name="Auto Flow Control" pos="23" rst="0">
      <options>       
        <option name="ENABLE" value="1" />
        
        <option name="DISABLE" value="0" />
        
        <default />
      </options>
      <comment>Enables the auto flow control. <br/> 
          In case HW flow control (both swTx_Flow_ctrl=0 and swRx_Flow_Ctrl=0),
          If Auto_Flow_Control is enabled, Uart_RTS is controlled by the Rx RTS bit in 
          CMD_Set register and the UART Auto Control Flow System(flow controlled by Rx
          Fifo Level and AFC_Level in Triggers register). 
          Tx data flow is stopped If Uart_CTS become inactive high.<br/>
          If Auto_Flow_Control is disabled, Uart_RTS is controlled only by the Rx RTS
          bit in CMD_Set register. Uart_CTS will not take effect. <br/><br/>

          In case SW flow control(either swTx_Flow_ctrl/=0 or swRx_Flow_Ctrl/=0),
          If Auto_Flow_Control is enabled, XON/XOFF will be controlled by the Rx RTS bit
          in CMD_Set register and the UART Auto Control Flow System(flow controlled by Rx
          Fifo Level and AFC_Level in Triggers register). <br/>
          If Auto_Flow_Control is disabled, XON/XOFF will be controlled only by Rx RTS bit
          in CMD_Set register. Tx data flow will be stoped when XOFF is received either
          this bit is enable or disabled.<br/>
          <br /> This bit will be masked to '1' if debug host is enabled.
      </comment>
    </bits>

    <bits access="rw" name="Loop Back Mode" pos="24" rst="0">
      <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support). </comment>
    </bits>

    <bits access="rw" name="Rx Lock Err" pos="25" rst="0">
      <comment>Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept. <br /> This bit 
      will be masked to '0' if debug host is enabled. </comment>
      <options>
        <option name="DISABLE" value="0" />
        <option name="ENABLE" value="1" />
        <default />
      </options>
    </bits>

    <bits access="rw" name="HST TXD oen" pos="26" rst="0">
      <comment>HST TXD output enable. '0' enable.</comment>
      <options>
        <option name="DISABLE" value="1" />
        <option name="ENABLE" value="0" />
        <default />
      </options>
    </bits>

    <bits access="rw" name="Rx Break Length" pos="31:28" rst="0xF">
      <comment>Length of a break, in number of bits. <br /> This bit will be masked
      to "1011" if debug host is enabled. </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Rx Fifo Level" pos="4:0" rst="0">
        <options>
            <mask/>
            <shift/>
        </options>
    <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read. </comment>
    </bits>

    <bits access="r" name="Tx Fifo Level" pos="12:8" rst="0">
         <options>
            <mask/>
            <shift/>
        </options>
      <comment>Those bits indicate the number of data available in the Tx
      Fifo. Those data will be sent. </comment>
    </bits>

    <bits access="r" name="Tx Active" pos="13" rst="0">
      <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface. </comment>
    </bits>

    <bits access="r" name="Rx Active" pos="14" rst="0">
      <comment>This bit indicates that the UART is receiving a byte.
      </comment>
    </bits>

    <bits access="r" name="Rx Overflow Err" pos="16" rst="0">
      <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Tx Overflow Err" pos="17" rst="0">
      <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when 
          the UART_STATUS register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Parity Err" pos="18" rst="0">
      <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Framing Err" pos="19" rst="0">
      <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Break Int" pos="20" rst="0">
      <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value. </comment>
    </bits>

    <bits access="r" name="Tx DCTS" pos="24" rst="0">
      <comment>In case HW flow ctrl(both swRx_Flow_Ctrl=0 and swTx_Flow_Ctrl=0), 
            This bit is set when the Uart_CTS line changed since the last
            time this register has been written. <br/>
            In case SW flow ctrl(either swRx_Flow_Ctrl/=0 or swTx_Flow_Ctrl/=0), 
            This bit is set when received XON/XOFF status changed since the last time
            this register has been writtern. <br/>
            This bit is cleared when the UART_STATUS register is written with any value. 
       </comment>
    </bits>

    <bits access="r" name="Tx CTS" pos="25" rst="0">
        <comment>In case HW flow ctrl(both swRx_Flow_Ctrl=0 and swTx_Flow_Ctrl=0),
            current value of the Uart_CTS line. 
            <br/> '1' = Tx not allowed. 
            <br/> '0' = Tx allowed. 
            <br/>In case SW flow ctrl(either swRx_Flow_Ctrl/=0 or swTx_Flow_Ctrl/=0),
            current state of software flow control.
            <br/> '1' = when XOFF received. 
            <br/> '0' = when XON received. 
        </comment>
    </bits>

    <bits access="r" name="Tx Fifo Rsted L" pos="28" rst="0">
      <comment>This bit is set when Tx Fifo Reset command is received by CTRL
      register and is cleared when Tx fifo reset process has finished.      
      </comment>
    </bits>

    <bits access="r" name="Rx Fifo Rsted L" pos="29" rst="0">
      <comment>This bit is set when Rx Fifo Reset command is received by CTRL
      register and is cleared when Rx fifo reset process has finished.      
      </comment>
    </bits>
    
    <bits access="r" name="Enable n finished" pos="30" rst="0">
      <comment>This bit is set when bit enable is changed from '0' to '1' or 
      from '1' to '0', it is cleared when the enable process has finished.      
      </comment>
    </bits>
    
    <bits access="r" name="Clk Enabled" pos="31" rst="0">
      <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      Rx RTS too early.</comment>
    </bits>
  </reg>

  <reg protect="--" name="rxtx_buffer">
    <bits access="r" name="Rx Data" pos="7:0" rst="no">
      <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur. </comment>
    </bits>

    <bits access="w" name="Tx Data" pos="7:0" rst="no">
      <comment>The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="irq_mask">
    <bits access="rw" name="Tx Modem Status" pos="0" rst="0">
        <comment>Clear to send signal change or XON/XOFF detected. </comment>
    </bits>

    <bits access="rw" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. </comment>
    </bits>

    <bits access="rw" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>Pulse detected on Uart_Dma_Tx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>Pulse detected on Uart_Dma_Rx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
      <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.</comment>
        </bits>

    <bits access="rw" name="XOFF_detected" pos="8" rst="0">
    </bits>
    
  </reg>

  <reg protect="rw" name="irq_cause">
    <bits access="r" name="Tx Modem Status" pos="0" rst="0">
      <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level. </comment>
    </bits>

    <bits access="r" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.
      </comment>
    </bits>

    <bits access="r" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.</comment>
    </bits>

    <bits access="r" name="Tx Modem Status U" pos="16" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Data Available U" pos="17" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed U" pos="18" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Timeout U" pos="19" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Line Err U" pos="20" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Dma Done U" pos="21" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Done U" pos="22" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Timeout U" pos="23" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="triggers">
    <bits access="rw" name="Rx Trigger" pos="3:0" rst="0">
      <comment>Defines the threshold level at which the Data Available
      Interrupt will be generated. <br />The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.</comment>
    </bits>

    <bits access="rw" name="Tx Trigger" pos="7:4" rst="0">
      <comment>Defines the threshold level at which the Data Needed
      Interrupt will be generated.<br />The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.</comment>
    </bits>

    <bits access="rw" name="AFC Level" pos="11:8" rst="0">
      <comment>Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).<br />The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.</comment>
    </bits>
  </reg>
  <reg protect="rw" name="XChar">
    <bits access="rw" name="XON1" pos="7:0" rst="17">
        <comment>XON1 character value. Reset Value is CTRL-Q 0x11.</comment>
    </bits>
    <bits access="rw" name="XOFF1" pos="15:8" rst="19">
        <comment>XOFF1 character value. Reset Value is CTRL-S 0x13</comment>
    </bits>
    <bits access="rw" name="XON2" pos="23:16" rst="0">
        <comment>XON2 character value. </comment>
    </bits>
    <bits access="rw" name="XOFF2" pos="31:24" rst="0">
        <comment>XOFF2 character value. </comment>
    </bits>
    <comment> These characters must respect following constraints: They must be different if used in software control, if BackSlash_En='1', they cannot be '\' and they cannot be complementary to each other, for example neither XON1 = ~XOFF1 nor XON1 = ~'\' is permitted. </comment>
  </reg>
  
</module>
</archive>

<archive relative = "dma.xml">
<module name="dma" category="System">
  <reg protect="w" name="get_channel">
    <bits access="r" name="Get Channel" pos="0" rst="1">
      <comment>Returns 1 and locks the DMA channel for a transaction if it is
      available. Else returns 0. <br />Clear the transfer done interrupt
      status. </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Enable" pos="0" rst="0">
      <comment>Status of the DMA: 1 if enabled, 0 if disabled. </comment>
    </bits>

    <bits access="r" name="Int Done Cause" pos="1" rst="0">
      <comment>Cause of the interrupt. This bit is set when the transfer is
      done and the interrupt mask bit is set. <br />Write one in the Int Clear
      or write 0 in Enable control bits to clear Int Done Cause bit.
      </comment>
    </bits>

    <bits access="r" name="Int Done Status" pos="2" rst="0">
      <comment>Status of the interrupt. Status of the transfer: 1 if the
      transfer is finished, 0 if it is not finished. <br />Write one in the
      Int Clear or write 0 in Enable control bits to clear Int Done Status
      bit. </comment>
    </bits>

    <bits access="r" name="Channel Lock" pos="4" rst="0">
      <comment>Actual status of channel lock. Channel is unlocked at the end
      of transaction or when the DMA is disabled. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="control">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <comment>Controls the DMA. Write 1 to enable the DMA, write 0 to disable
      it. When 0 is written in this register, the Int Done Status and Cause
      bits are reset. </comment>
    </bits>

    <bits access="rw" name="Int Done Mask" pos="1" rst="0">
      <comment>End of transfer interrupt generation. When 1, the DMA will send
      an interrupt at transaction completion. </comment>
      <options>
        <shift/>
      </options>  
    </bits>

    <bits access="rw" name="Int Done Clear" pos="2" rst="0">
      <comment>Clear the transfer done interruption (this will clear Int Done
      Status and Int Done Cause). <br />This bit is auto-clear. You will
      always read 0 here. </comment>
    </bits>

    <bits access="rw" name="Use Pattern" pos="4" rst="0">
      <comment>If this bit is set, the source address will be ignored and the
      memory will be fill with the value of the pattern register. </comment>
    </bits>

    <bits access="w" name="Stop Transfer" pos="8" rst="0">
      <comment>The DMA stop the current transfer and flush his FIFO (write
      only bit). When the FIFO is empty and last write performed, the DMA is
      disabled and available for a next transfer. The number of bytes copied
      is readable on DMA_XFER_SIZE register.</comment>
    </bits>

    <bits access="rw" name="GEA Enable" pos="12" rst="0">
      <options>
        <option name="DMA" value="0" />

        <option name="GEA" value="1" />

        <default />
      </options>

      <comment>Enable Gea process when 1.</comment>
    </bits>

    <bits access="rw" name="GEA Algorithm" pos="13" rst="1">
      <options>
        <option name="GEA1" value="0" />

        <option name="GEA2" value="1" />

        <default />
      </options>

      <comment>This field sets the type of GEA algorithm to process.</comment>
    </bits>

    <bits access="rw" name="GEA Direction" pos="14" rst="1">
      <options>
        <shift/>
      </options>
      <comment>This field selects the Direction in the GEA algorithm.
      </comment>
    </bits>

    <bits access="rw" name="FCS Enable" pos="16" rst="0">
      <options>
        <option name="NORMAL_DMA" value="0" />

        <option name="FCS_PROCESS" value="1" />

        <default />
      </options>

      <comment>Enable FCS process when 1.</comment>
    </bits>

    <bits access="rw" name="Dst Addr Mgt" pos="21:20" rst="0">
      <options>
        <option name="NORMAL_DMA" value="0" />

        <option name="CONST_ADDR" value="1" />

        <option name="ALTERN_ADDR" value="2" />

        <option name="RESERVED" value="3" />

        <default />
      </options>

      <comment>Destination address management.<br />00 : Normal DMA operation,
      DMA_DST_ADDR register define the destination address.<br /> 01 : DMA
      write address is constant (no incremented) and defined by the
      DMA_DST_ADDR register. All data write are in 16-bit.<br /> 10 : DMA
      write address is alternatively defined by DMA_DST_ADDR and
      DMA_SD_DST_ADDR registers. All data write are in 16-bit. <br />In this
      configuration, DMA write operation is alternatively: <br />DMA_DST_ADDR
      &lt;= DMA_PATTERN register <br />DMA_SD_DST_ADDR &lt;=
      Data[DMA_SRC_ADDR] <br />11 : reserved </comment>
    </bits>
  </reg>

  <reg protect="rw" name="src_addr">
    <bits access="rw" name="Src Address" pos="27:0" rst="0xFFFFFFF">
      <comment>Source start read byte address. When a transfer is stalled by
      the Stop_Transfer bit, this register give the next current source
      address, which is directly the value to re-program to complete the
      transfer stopped.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="dst_addr">
    <bits access="rw" name="Dst Address" pos="27:0" rst="0xFFFFFFF">
      <comment>Destination start read byte address. When a transfer is stalled
      by the Stop_Transfer bit, this register give the next current
      destination address, which is directly the value to re-program to
      complete the transfer stopped.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="sd_dst_addr">
    <bits access="rw" name="Sd Dst Address" pos="27:0" rst="0xFFFFFFF">
      <comment>Second destination address. This register is only used when
      Dst_Address_Mgt=10.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="xfer_size">
    <bits access="rw" name="Transfer Size" pos="17:0" rst="0x3FFFF">
      <comment>Transfer size in bytes. Maximum: 262144 bytes. When a transfer
      is stopped by the Stop_Transfer bit, this register give the number of
      remainder bytes to transfer.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="pattern">
    <bits access="rw" name="Pattern" pos="31:0" rst="0xFFFFFFFF">
      <comment>Value taken to fill the memory when the configuration bit Use
      Pattern is set. When the pattern mode is used the destination address
      must be 32-bit aligned and the transfer size multiple of 4. when
      Dst_Address_Mgt=10 Pattern is the data written at the address given by
      the Dst_Address register.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gea_kc_low">
    <bits access="rw" name="KC_LSB" pos="31:0" rst="0xFFFFFFFF">
      <comment>GEA key Kc, LSB bit [31:0]. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gea_kc_high">
    <bits access="rw" name="KC_MSB" pos="31:0" rst="0xFFFFFFFF">
      <comment>GEA key Kc, MSB bit [31:0]. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gea_messkey">
    <bits access="rw" name="MessKey" pos="31:0" rst="0xFFFFFFFF">
      <comment>MessKey (Input) register. </comment>
    </bits>
  </reg>

  <reg protect="r" name="fcs">
    <bits access="r" name="FCS" pos="23:0" rst="0">
      <comment>Frame Check Sequence.</comment>
    </bits>

    <bits access="r" name="FCS Correct" pos="31" rst="0">
      <comment>The FCS is correct in reception when the final remainder is
      equal to C(x)= x^22 + x^21 + x^19 + x^18 + x^16 + x^15 + x^11 + x^8 +
      x^5 + x^4</comment>
    </bits>

    
  </reg>
</module>
</archive>


<archive relative = "excor.xml">

<include file="globals.xml"/>

<module name="excor" category="Baseband">

 <var name="EXCOR_IDLE" value="0" />
 <var name="EXCOR_BMMLZF" value="1" />
 <var name="EXCOR_COMPMATRIMUL" value="2" />
 <var name="EXCOR_COMPCONV" value="3" />
 <var name="EXCOR_COMPPOW" value="4" />
 <var name="EXCOR_DEROTATE" value="5" />
 <var name="EXCOR_DCCOMP" value="6" />
 <var name="EXCOR_SRECPSK8" value="7" />
 <var name="EXCOR_FCCH" value="8" />
 <var name="EXCOR_IR_COMB" value="9" />
 <var name="EXCOR_IQ_SHIFT" value="10" />
 <var name="EXCOR_STATUS_MASK" value="1" />
 <var name="EXCOR_FASTMATRIMUL" value="11" />
 <var name="EXCOR_FASTCONV" value="12" />
 
  <reg name="ctrl" protect="rw">
    <bits access="rw" name="cmd" pos="7:0" rst="0x0">
      <comment>Control setting. comand type. </comment>
    </bits>

    <bits access="rw" name="nb_iloop" pos="15:8" rst="0x0">
      <comment>Control setting. Number of internal loop iteration.
      </comment>
    </bits>

    <bits access="rw" name="nb_oloop" pos="25:16" rst="0x0">
      <comment>Control setting. Number of nb_symbol.
      </comment>
    </bits>

    <bits access="rw" name="shift_bit" pos="30:26" rst="0x0">
      <comment>Control setting. Number of shift bits.
      </comment>
    </bits>
  </reg>

 <reg name="addr0" protect="rw">
    <bits access="rw" name="addr0" pos="14:0" rst="0x0">
        <comment>address register 0. </comment>
    </bits>

  </reg>
  
  <reg name="addr1" protect="rw">
    <bits access="rw" name="addr1" pos="14:0" rst="0x0">
        <comment>address register 1. </comment>
    </bits>
  </reg>
  
  <reg name="addr2" protect="rw">
    <bits access="rw" name="addr2" pos="14:0" rst="0x0">
        <comment>address register 2. </comment>
    </bits>
  </reg>
  
<reg name="addr3" protect="rw">
    <bits access="rw" name="addr3" pos="31:0" rst="0x0">
        <comment>address register 3. </comment>
    </bits>
  </reg>
  
<reg name="addr4" protect="rw">
    <bits access="rw" name="addr4" pos="31:0" rst="0x0">
        <comment>address register 4. </comment>
    </bits>
  </reg>  
  
<reg name="addr5" protect="rw">
    <bits access="rw" name="addr5" pos="31:0" rst="0x0">
        <comment>address register 5. </comment>
    </bits>
  </reg>  
  
 <reg name="data0" protect="rw">
    <bits access="rw" name="data0" pos="31:0" rst="0x0">
        <comment>data register 0. </comment>
    </bits>
  </reg>  
  
 <reg name="data1" protect="rw">
    <bits access="rw" name="data1" pos="31:0" rst="0x0">
        <comment>data register 1. </comment>
    </bits>
  </reg>
  
 <reg name="data2" protect="rw">
    <bits access="rw" name="data2" pos="31:0" rst="0x0">
        <comment>data register 2. </comment>
    </bits>
  </reg>  
    
 <reg name="data3" protect="rw">
    <bits access="rw" name="data3" pos="31:0" rst="0x0">
        <comment>data register 3. </comment>
    </bits>
  </reg>  
  
 <reg name="data4" protect="rw">
    <bits access="rw" name="ircom_psidx0" pos="1:0" rst="0x0">
      <comment>for ircombine idx0 </comment>
    </bits>
    <bits access="rw" name="ircom_psidx2" pos="5:4" rst="0x0">
      <comment>for ircombine idx1 </comment>
    </bits>
    <bits access="rw" name="ircom_psidx1" pos="18:8" rst="0x0">
      <comment>for ircombine idx2 </comment>
    </bits>
  </reg>    
  
 <reg name="data5" protect="rw">
    <bits access="rw" name="data5" pos="31:0" rst="0x0">
        <comment>data register 5. </comment>
    </bits>
  </reg>    
  
  
  <reg name="status" protect="rw">
    <bits access="rw" name="status" pos="7:0" rst="0x0">
        <comment>Status is set to 1 when an operation is finished. </comment>
    </bits>
  </reg>
  <reg name="ctrl_fast" protect="rw">
    <bits access="rw" name="loop_num_a" pos="2:0" rst="0x0">
      <comment>Control setting. Number of A row. </comment>
    </bits>

    <bits access="rw" name="loop_num_b" pos="6:4" rst="0x0">
      <comment>Control setting. Number of B column.
      </comment>
    </bits>

    <bits access="rw" name="loop_num_ab" pos="15:8" rst="0x0">
      <comment>Control setting. Number of  A column and B row.
      </comment>
    </bits>
    <bits access="rw" name="shift_bit_reg1" pos="20:16" rst="0x0">
      <comment>Control setting. Number of  shift bit after multiply.
      </comment>
    </bits>
  </reg>  
</module>

</archive>
<archive relative = "fm.xml" relative="fmd.xml">
<module name="fmd" category="Analog">
    <reg name="REG_00" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>
      <bits access="rw" name="CHIPID[15:0]" pos="15:0" rst="16'h5804">
        <comment>Chip ID.
		</comment>
      </bits>
    </reg>
    <reg name="REG_01" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>
      <bits access="rw" name="REVID[5:0]" pos="15:10" rst="6'h01">
        <comment>Revision ID.
		</comment>
      </bits>
      <bits access="rw" name="reserved" pos="9:8" rst="2'b00">
        <comment>Read as 0
		</comment>
      </bits>
      <bits access="rw" name="FIRMWARE[7:0]" pos="7:0" rst="8'h00">
        <comment>Firmware Version.
		8'h00 when ENABLE = 0;
		8'h01 when ENABLE = 1.
		</comment>
      </bits>
    </reg>
    <reg name="REG_02" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>
      <bits access="rw" name="DHIZ" pos="15" rst="1'b0">
        <comment>Audio Output High-Z Disable.
		0 = High impedance
		1 = Normal operation
		</comment>
      </bits>
      <bits access="rw" name="DMUTE" pos="14" rst="1'b0">
        <comment>Mute Disable.
		0 = Mute
		1 = Normal operation
		</comment>
      </bits>
      <bits access="rw" name="MONO" pos="13" rst="1'b0">
        <comment>Mono Select.
		0 = Stereo
		1 = Force mono
		</comment>
      </bits>
      <bits access="rw" name="BASS" pos="12" rst="1'b0">
        <comment>Bass Boost.
		0 = Disabled
		1 = Bass boost enabled
		</comment>
      </bits>
      <bits access="rw" name="Rfpll_cnt_en_b" pos="11" rst="1'b0">
        <comment>0 = dynamic rfpll close cal enable
		</comment>
      </bits>
      <bits access="rw" name="clk32k_input_en_b" pos="10" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="SEEKUP" pos="9" rst="1'b0">
        <comment>Seek Up.
		0 = Seek down
		1 = Seek up
		</comment>
      </bits>
      <bits access="rw" name="SEEK" pos="8" rst="1'b0">
        <comment>Seek.
		0 = Disable (default)
		1 = Enable
		Seek begins in the direction specified by SEEKUP and ends when a channel is found with RSSI level above SEEKTH[5:0], or the entire band has been searched.
		The SEEK bit is reset to low automatically and the STC bit is set high when the seek operation completes.
		</comment>
      </bits>
      <bits access="rw" name="SKMODE" pos="7" rst="1'b0">
        <comment>Seek Mode
		0 = wrap at the upper or lower band limit and continue seeking(default)
		1 = stop seeking at the upper or lower band limit
		</comment>
      </bits>
      <bits access="rw" name="CLK_MODE[2:0]" pos="6:4" rst="1'b0">
        <comment>000 = 32.768 kHz ;
		001 = 12 MHz ;
		010 = 13 MHz ;
		011 = 19.2 MHz ;
		100 = 32.768 kHz ;
		101 = 24 MHz ;
		110 = 26 MHz ;
		111 = 38.4 MHz.
		</comment>
      </bits>
      <bits access="rw" name="RDS_EN" pos="3" rst="1'b0">
        <comment>1 = enable
		</comment>
      </bits>
      <bits access="rw" name="rsvd" pos="2" rst="1'b0">
        <comment>Read as 0
		</comment>
      </bits>
      <bits access="rw" name="SOFT_RESET" pos="1" rst="1'b0">
        <comment>Soft reser
		1 = reset ;
		0 = not reset.
		</comment>
      </bits>
      <bits access="rw" name="ENABLE" pos="0" rst="1'b0">
        <comment>Powerup enable.
		0 = disabled (default);
		1 = enabled.
		</comment>
      </bits>
    </reg>
    <reg name="REG_03" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>
      <bits access="rw" name="CHAN_REG[9:0]" pos="15:6" rst="10d319">
        <comment>Channel Select.
		BAND = 0
		Frequency =
		Channel Spacing (kHz) x CHAN+ 87.0 MHz
		BAND = 1
		Frequency =
		Channel Spacing (kHz) x CHAN + 76.0 MHz
		CHAN is updated after a seek operation.
		</comment>
      </bits>
      <bits access="rw" name="direct_reg" pos="5" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="TUNE" pos="4" rst="1'b0">
        <comment>Tune
		0 = Disable(default)
		1 = Enable
		The tune operation begins when the TUNE bit is set high. The STC bit is set high when the tune operation completes.
		The tune bit is reset to low automatically when the tune operation completes..
		</comment>
      </bits>
      <bits access="rw" name="BAND[1:0]" pos="3:2" rst="2'b0">
        <comment>Band Select.
		00 =
		87.0~108 MHz (US/Europe)
		01 = 76 ~91 MHz (Japan)
		10 =
		76~108 MHz (Japan wide)
		11 = 65~76 MHz (East Eruope)
		</comment>
      </bits>
      <bits access="rw" name="SPACE[1:0]" pos="1:0" rst="2'b0">
        <comment>Channel Spacing.
		00 = 100 kHz
		01 = 200 kHz
		10 = 50 kHz
		11 = 25 kHz
		</comment>
      </bits>
    </reg>
    <reg name="REG_04" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>
      <bits access="rw" name="RDSIEN" pos="15" rst="1'b0">
        <comment>RDS ready Interrupt Enable.
		0 = Disable Interrupt
		1 = Enable Interrupt	
		Setting STCIEN = 1 will generate a low pulse on GPIO2 when the interrupt occurs.
		</comment>
      </bits>
      <bits access="rw" name="STCIEN" pos="14" rst="1'b0">
        <comment>Seek/Tune Complete Interrupt Enable.
		0 = Disable Interrupt
		1 = Enable Interrupt
		Setting STCIEN = 1 will generate a low pulse on GPIO2 when the interrupt occurs.
		</comment>
      </bits>
      <bits access="rw" name="RBDS" pos="13" rst="1'b0">
        <comment>1 = RBDS mode enable
		0 = RDS mode only
		</comment>
      </bits>
      <bits access="rw" name="RDS_FIFO_EN" pos="12" rst="1'b0">
        <comment>1 = RDS fifo mode enable.
		</comment>
      </bits>
      <bits access="rw" name="DE" pos="11" rst="1'b0">
        <comment>De-emphasis.
		0 = 75 us
		1 = 50 us
		</comment>
      </bits>
      <bits access="rw" name="RDS_FIFO_CLR" pos="10" rst="1'b1">
        <comment>1 = clear RDS fifo
		</comment>
      </bits>
      <bits access="rw" name="SOFTMUTE_EN" pos="9" rst="1'b0">
        <comment>Soft mute enable.
		1 = enabled ;
		0 = disabled.
		</comment>
      </bits>
      <bits access="rw" name="AFCD" pos="8" rst="1'b0">
        <comment>Afc disable.
		1 = disabled;
		0 = afc word
		</comment>
      </bits>
      <bits access="rw" name="rsvd" pos="7" rst="1'b0">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="I2S_ENABLE" pos="6" rst="1'b0">
        <comment>I2S enable.
		0 = disabled;
		1 = enabled.
		</comment>
      </bits>
      <bits access="rw" name="GPIO3[1:0]" pos="5:4" rst="2'b0">
        <comment>General Purpose I/O 3.when gpio_sel=01
		00 = High impedance
		01 = Mono/Stereo indicator (ST)
		10 = Low
		11 = High
		</comment>
      </bits>
      <bits access="rw" name="GPIO2[1:0]" pos="3:2" rst="2'b0">
        <comment>General Purpose I/O 2. when gpio_sel=10
		00 = High impedance
		01 = Interrupt (INT)
		10 = Low
		11 = High
		</comment>
      </bits>
      <bits access="rw" name="GPIO1[1:0]" pos="1:0" rst="2'b0">
        <comment>General Purpose I/O 1. when gpio_sel=01
		00 = High impedance
		01 = Reserved
		10 = Low
		11 = High
		</comment>
      </bits>
    </reg>
    <reg name="REG_05" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="INT_MODE" pos="15" rst="1'b0">
        <comment>If 0, generate 5ms interrupt;
		If 1, interrupt last until read action occurs.
		</comment>
      </bits>
      <bits access="rw" name="Seek_mode-1:0" pos="14:13" rst="2'b0">
        <comment>no comment
		</comment>
      </bits>
      <bits access="rw" name="reserved" pos="12">
        <comment />
      </bits>
      <bits access="rw" name="SEEK_TH[53:0]" pos="11:8" rst="6d8">
        <comment>(inverse of noise_h_th-3:0)
		Seek Threshold. RSSI scale is logarithmic.
		000000 = min RSSI
		111111 = max RSSI
		</comment>
      </bits>
      <bits access="rw" name="LNA_PORT_SEL[1:0]" pos="7:6" rst="2'b10">
        <comment>LNA input port selection bit:
		00: no input
		01: LNAN
		10: LNAP
		11: dual port input
		</comment>
      </bits>
      <bits access="rw" name="LNA_ICSEL_BIT[1:0]" pos="5:4" rst="2'b00">
        <comment>Lna working current bit:
		00=1.8mA
		01=2.1mA
		10=2.5mA
		11=3.0mA
		</comment>
      </bits>
      <bits access="rw" name="DAC_GAIN_BIT[3:0]" pos="3:0" rst="4'b1011">
        <comment>DAC gain control bits.
		0000=min
		1000=max
		Volume scale is logarithmic
		</comment>
      </bits>
    </reg>
    <reg name="REG_06" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15" rst="1'b0">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="page" pos="14" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="rsvd" pos="13" rst="1'b0">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="slave_master" pos="12" rst="1'b0">
        <comment>I2S slave or master.
		1 = slave;
		0 = master.
		</comment>
      </bits>
      <bits access="rw" name="ws_lr" pos="11" rst="1'b0">
        <comment>Ws relation to l/r channel.
		If 0, ws=0 ->r, ws=1 ->l;
		If 1, ws=0 ->l, ws=1 ->r.
		</comment>
      </bits>
      <bits access="rw" name="sclk_i_edge" pos="10" rst="1'b0">
        <comment>If 0, use normal sclk internally;
		If 1, inverte sclk internally.
		</comment>
      </bits>
      <bits access="rw" name="data_signed" pos="9" rst="1'b0">
        <comment>If 0, I2S output unsigned 16-bit audio data.
		If 1, I2S output signed 16-bit audio data.
		</comment>
      </bits>
      <bits access="rw" name="ws_i_edge" pos="8" rst="1'b0">
        <comment>If 0, use normal ws internally;
		If 1, inverte ws internally.
		</comment>
      </bits>
      <bits access="rw" name="ws_mode[3:0]" pos="7:4" rst="4'b0">
        <comment>Valid only in Master mode.
		</comment>
      </bits>
      <bits access="rw" name="ws_o_edge" pos="3" rst="1'b0">
        <comment>If 1, invert ws output when as master.
		</comment>
      </bits>
      <bits access="rw" name="sclk_o_edge" pos="2" rst="1'b0">
        <comment>If 1, invert sclk output when as master.
		</comment>
      </bits>
      <bits access="rw" name="l_delay" pos="1" rst="1'b0">
        <comment>If 1, L channel data delay 1T.
		</comment>
      </bits>
      <bits access="rw" name="r_delay" pos="0" rst="1'b0">
        <comment>If 1, R channel data delay 1T.
		</comment>
      </bits>
    </reg>
    <reg name="REG_07" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="reserved" pos="15">
        <comment>Must be 0
		</comment>
      </bits>
      <bits access="rw" name="TH_SOFTBLEND[5:0]" pos="14:10" rst="6d195d19">
        <comment>Threshold for noise soft blend setting, unit 2dB.
		Force to mono mode when RSSI less than 2*th_softblend*2,
		Release to stereo mode when RSSI more than 2*(8+th_softblend*2).
		</comment>
      </bits>
      <bits access="rw" name="band[2]" pos="9" rst="1'b1">
        <comment>Valid when band[1:0] = 2'b11
		1 = 65~76 MHz;
		0 = 50~76 MHz.
		</comment>
      </bits>
      <bits access="rw" name="reserved" pos="8">
        <comment />
      </bits>
      <bits access="rw" name="rsvdseekth" pos="7:2" rst="3'b011">
        <comment>Valid when seek_mode[0]=1!!!
		</comment>
      </bits>
      <bits access="rw" name="softblend_en" pos="1" rst="1'b1">
        <comment>1 = soft blend enable
		</comment>
      </bits>
      <bits access="rw" name="freq_mode" pos="0" rst="1'b0">
        <comment>If 1, then freq setting changed.
		Freq = 76000(or 87000) kHz + freq_direct (08H) kHz.
		</comment>
      </bits>
    </reg>
    <reg name="REG_08" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="freq_direct[15:0]" pos="15:0" rst="16d0">
        <comment>Valid when freq_mode = 1.
		</comment>
      </bits>
    </reg>
    <reg name="REG_09" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:10" rst="6'b0">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="pd_cryosc" pos="9" rst="1'b1">
        <comment>Power down crystal.
		1 = power down;
		0 = power up.
		</comment>
      </bits>
      <bits access="rw" name="pd_ana" pos="8" rst="1'b1">
        <comment>Power down analog all.
		1 = power down;
		0 = power up.
		</comment>
      </bits>
      <bits access="rw" name="rsvd" pos="7" rst="1'b0">
        <comment>Read as 0
		</comment>
      </bits>
      <bits access="rw" name="pd_rfpll" pos="6" rst="1'b1">
        <comment>Power down rfpll.
		1 = power down;
		0 = power up.
		</comment>
      </bits>
      <bits access="rw" name="pd_lna" pos="5" rst="1'b1">
        <comment>Power down lna.
		1 = power down;
		0 = power up.
		</comment>
      </bits>
      <bits access="rw" name="pd_mixer" pos="4" rst="1'b1">
        <comment>Power down mixer.
		1 = power down;
		0 = power up.
		</comment>
      </bits>
      <bits access="rw" name="pd_pga" pos="3" rst="1'b1">
        <comment>Power down pga.
		1 = power down;
		0 = power up.
		</comment>
      </bits>
      <bits access="rw" name="pd_adc" pos="2" rst="1'b1">
        <comment>Power down adc.
		1 = power down;
		0 = power up.
		</comment>
      </bits>
      <bits access="rw" name="pd_dig" pos="1" rst="1'b1">
        <comment>Power down dsp.
		1 = power down;
		0 = power up.
		</comment>
      </bits>
      <bits access="rw" name="pd_dac" pos="0" rst="1'b1">
        <comment>Power down dac.
		1 = power down;
		0 = power up.
		</comment>
      </bits>
    </reg>
    <reg name="REG_0a (Read Only)" protect="rw">
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="r" name="RDSR" pos="15">
        <comment>RDS ready
		0 = No RDS/RBDS group ready(default)
		1 = New RDS/RBDS group ready
		</comment>
      </bits>
      <bits access="r" name="STC" pos="14">
        <comment>Seek/Tune Complete.
		0 = Not complete
		1 = Complete
		The seek/tune complete flag is set when the seek or tune operation completes.
		</comment>
      </bits>
      <bits access="r" name="SF" pos="13">
        <comment>Seek Fail.
		0 = Seek successful
		1 = Seek failure
		The seek fail flag is set when the seek operation fails to find a channel under the condition.
		</comment>
      </bits>
      <bits access="r" name="RDSS" pos="12">
        <comment>RDS Synchronization
		0 = RDS decoder not synchronized(default)
		1 = RDS decoder synchronized
		Available only in RDS Verbose mode
		</comment>
      </bits>
      <bits access="r" name="BLK_E" pos="11">
        <comment>1 = Block E has been found
		0 = no Block E has been found
		</comment>
      </bits>
      <bits access="r" name="ST" pos="10">
        <comment>Stereo Indicator.
		0 = Mono
		1 = Stereo
		Stereo indication is available on GPIO3 by setting GPIO1[1:0] =01.
		</comment>
      </bits>
      <bits access="rw" name="READCHAN[9:0]" pos="9:0">
        <comment>Read Channel.
		BAND = 0
		Freq = Channel Spacing (kHz) * READCHAN + 87.5 MHz
		BAND = 1 or 2
		Freq = Channel Spacing (kHz) * READCHAN + 76.0 MHz
		READCHAN is updated after a tune or seek operation.
		</comment>
      </bits>
    </reg>
    <reg name="REG_0b (Read Only)" protect="rw">
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="r" name="RSSI[6:0]" pos="15:9">
        <comment>RSSI, unit dB.
		000000 = min
		111111 = max
		RSSI scale is logarithmic.
		</comment>
      </bits>
      <bits access="r" name="FM_TRUE" pos="8">
        <comment>1 = the current channel is a station
		0 = the current channel is not a station
		</comment>
      </bits>
      <bits access="r" name="FM_READY" pos="7">
        <comment>1 = seek ready;
		0 = not ready.
		</comment>
      </bits>
      <bits access="r" name="rsvd" pos="6:5">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="r" name="ABCD_E" pos="4">
        <comment>1 = the block id of register 0cH,0dH,0eH,0fH is E	
		0 = he block id of register 0cH,0dH,0eH,0fH is A,B,C,D
		</comment>
      </bits>
      <bits access="r" name="BLERA[1:0]" pos="3:2">
        <comment>
		BLK Errors Level of RDS_DATA_0, and is always read as Errors Level of RDS BLOCK A( in RDS mode) or BLOCK E(in RBDS mode when ABCD_E flag is 1).
		00 = 0 errors requiring correction
		01 = 1~2 errors requiring correction
		10 = 3~5 errors requiring correction	
		11 = 6+ errors or error in checkword, correctionnot possible
		Available only in RDS Verbose mode
		</comment>
      </bits>
      <bits access="r" name="BLERB[1:0]" pos="1:0">
        <comment>BLK Errors Level of RDS_DATA_1, and is always read as Errors Level of RDS BLOCK B( in RDS mode) or E(in RBDS mode when ABCD_E flag is 1).
		00 = 0 errors requiring correction
		01 = 1~2 errors requiring correction
		10 = 3~5 errors requiring correction
		11 = 6+ errors or error in checkword, correctionnot possible
		Available only in RDS Verbose mode
		</comment>
      </bits>
    </reg>
    <reg name="REG_0c (Read Only)" protect="rw">
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="r" name="RDSA[15:0]" pos="15:0" rst="16'h5803">
        <comment>BLOCK A (in RDS mode) or BLOCK E(in RBDS mode when ABCD_E flag is 1)
		</comment>
      </bits>
    </reg>
    <reg name="REG_0d (Read Only)" protect="rw">
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="r" name="RDSB[15:0]" pos="15:0" rst="16'h5804">
        <comment>BLOCK B (in RDS mode) or BLOCK E(in RBDS mode when ABCD_E flag is 1)
		</comment>
      </bits>
    </reg>
    <reg name="REG_0e (Read Only)" protect="rw">
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="RDSC[15:0]" pos="15:0" rst="16'h5801h5808">
        <comment>BLOCK C/c' (in RDS mode) or BLOCK E(in RBDS mode when ABCD_E flag is 1)
		</comment>
      </bits>
    </reg>
    <reg name="REG_0f (Read Only)" protect="rw">
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="RDSD[15:0]" pos="15:0" rst="16'h5804">
        <comment>BLOCK D (in RDS mode) or BLOCK E(in RBDS mode when ABCD_E flag is 1)
		</comment>
      </bits>
    </reg>
    <reg name="REG_10 (Read Only)" protect="rw">
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="BLERC[1:0]" pos="15:14">
        <comment>BLK Errors Level of RDS_DATA_2, and is always read as Errors Level of RDS BLOCK C/c'( in RDS mode) or BLOCK E(in RBDS mdoe when ABCD_E flag is 1).
		00 = 0 errors requiring correction
		01 = 1~2 errors requiring correction
		10 = 3~5 errors requiring correction		
		11 = 6+ errors or error in checkword, correctionnot possible
		Available only in RDS Verbose mode
		</comment>
      </bits>
      <bits access="r" name="BLERD[1:0]" pos="13:12">
        <comment>BLK Errors Level of RDS_DATA_3, and is always read as Errors Level of RDS BLOCK D( in RDS mode) or BLOCK E(in RBDS mdoe when ABCD_E flag is 1).
		00 = 0 errors requiring correction
		01 = 1~2 errors requiring correction
		10 = 3~5 errors requiring correction	
		11 = 6+ errors or error in checkword, correctionnot possible
		Available only in RDS Verbose mode
		</comment>
      </bits>
      <bits access="r" name="snr_rds[5:0]" pos="11:6">
        <comment>unit dB
		</comment>
      </bits>
      <bits access="r" name="rds_fifo_full_flag" pos="5">
        <comment>1 = fifo full
		</comment>
      </bits>
      <bits access="r" name="rds_fifo_empty_flag" pos="4">
        <comment>1 = fifo empty
		</comment>
      </bits>
      <bits access="r" name="rds_flag" pos="3" rst="13'b0">
        <comment>1 = rds/rbds/ari 57khz energy has found.
		</comment>
      </bits>
      <bits access="r" name="GPIO3_I" pos="2" rst="1'b0">
        <comment>GPIO3 status
		</comment>
      </bits>
      <bits access="r" name="GPIO2_I" pos="1" rst="1'b0">
        <comment>GPIO2 status
		</comment>
      </bits>
      <bits access="r" name="GPIO1_I" pos="0" rst="1'b0">
        <comment>GPIO1 status
		</comment>
      </bits>
    </reg>
    <reg name="REG_11" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="snr_out[5:0]" pos="15:10" rst="6'b0">
        <comment>SNR, unit 1dB.
		</comment>
      </bits>
      <bits access="rw" name="sk_cmp_grp_flag[4:0]" pos="9:5" rst="4'b0">
        <comment>[4]: 19k pilot flag
		[3]: offset flag
		[2]: snr flag
		[1]: rssi flag
		[0]: noise flag
		</comment>
      </bits>
      <bits access="rw" name="sk_cmp_grp_en[4:0]" pos="4:0" rst="4'b11011">
        <comment>[4]: seek with pilot enable
		[3]: seek with offset enable
		[2]: seek with snr enable
		[1]: seek with rssi enable
		[0]: seek with noise enable
		</comment>
      </bits>
    </reg>
    <reg name="REG_12" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15" rst="6'b0">
        <comment />
      </bits>
      <bits access="rw" name="signal_db2[6:0]" pos="14:8" rst="4'b0">
        <comment>Signal, unit 1dB.
		</comment>
      </bits>
      <bits access="rw" name="offset2[7:0]" pos="7:0" rst="4'b11011">
        <comment>Freq offset, unit 1.28kHz
		</comment>
      </bits>
    </reg>
    <reg name="REG_13" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="adc_reset_en_dsp" pos="15" rst="1'b1">
        <comment>If 1, adc reset from dsp enabled
		</comment>
      </bits>
      <bits access="rw" name="adc_data_test" pos="14" rst="1'b0">
        <comment>If 1, output adc_data_i/q and adc_clk via GPIO1,2,3
		</comment>
      </bits>
      <bits access="rw" name="adc_ictrl_bit[1:0]" pos="13:12" rst="2'b00">
        <comment />
      </bits>
      <bits access="rw" name="adc_reset_dr" pos="11" rst="1'b0">
        <comment>If 1, adc reset direct.
		</comment>
      </bits>
      <bits access="rw" name="adc_reset_reg" pos="10" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="adc_iq_swap" pos="9" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="adc_test_enable" pos="8" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="adc_dig_pwr_dr" pos="7" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="adc_dig_pwr_reg[2:0]" pos="6:4" rst="3'b100">
        <comment />
      </bits>
      <bits access="rw" name="adc_cal_refi_bit_dr" pos="3" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="adc_cal_refi_bit_reg[2:0]" pos="2:0" rst="3'b100">
        <comment />
      </bits>
    </reg>
    <reg name="REG_14" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="pll_fbc_sel[2:0]" pos="15:13" rst="3'b001">
        <comment />
      </bits>
      <bits access="rw" name="pga_ictrl[3:0]" pos="12:9" rst="4'b1000">
        <comment />
      </bits>
      <bits access="rw" name="pga_test_en" pos="8" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="pga_test_bit[1:0]" pos="7:6" rst="2'b11">
        <comment />
      </bits>
      <bits access="rw" name="dac_common_bit[1:0]" pos="5:4" rst="2'b11">
        <comment />
      </bits>
      <bits access="rw" name="dac_isel_bit[3:0]" pos="3:0" rst="4'b0001">
        <comment />
      </bits>
    </reg>
    <reg name="REG_15" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="pll_mini_pd" pos="15" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_fts_cap_bit[2:0]" pos="14:12" rst="3'b011">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_presc_vreg_bit[3:0]" pos="11:8" rst="4'b1000">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_div_ibit[3:0]" pos="7:4" rst="4'b1000">
        <comment />
      </bits>
      <bits access="rw" name="pga_bw[1:0]" pos="3:2" rst="3'b100">
        <comment />
      </bits>
      <bits access="rw" name="adc_isel_bit[1:0]" pos="1:0">
        <comment />
      </bits>
    </reg>
    <reg name="REG_16" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rfpll_vco_ibit[3:0]" pos="15:12" rst="4'b1000">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_vco_band_dr" pos="11" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_vco_band_reg[10:0]" pos="10:0" rst="11'h400">
        <comment />
      </bits>
    </reg>
    <reg name="REG_17" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="pll_fbc_state" pos="15" rst="1'b0">
        <comment>Read only
		</comment>
      </bits>
      <bits access="rw" name="rfpll_vardac_dr" pos="14" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_var_sel_reg[4:0]" pos="13:9" rst="5'b1_0000">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_rdac_din_reg[8:0]" pos="8:0" rst="9'b1_0000_0000">
        <comment />
      </bits>
    </reg>
    <reg name="REG_18" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rfpll_cal_fast_mode" pos="15" rst="1'b1">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_cal_time_sel[5:0]" pos="14:9" rst="6'b000100">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_div_direct" pos="8" rst="1'b0">
        <comment>If 1, rfpll div4/5/6/7 direct.
		</comment>
      </bits>
      <bits access="rw" name="rfpll_div6_mode" pos="7" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_div5_mode" pos="6" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_div_clk_adc_dr" pos="5" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_div_clk_adc_reg[4:0]" pos="4:0" rst="5'b1_0000">
        <comment />
      </bits>
    </reg>
    <reg name="REG_19" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rfpll_cal_err_cnt_th[7:0]" pos="15:8" rst="8d10">
        <comment>threshold for dynamic closed calibration
		</comment>
      </bits>
      <bits access="rw" name="rfpll_cal_opt" pos="7" rst="1'b1">
        <comment>1 = option select for vco_band calibration.
		0 = normal.
		</comment>
      </bits>
      <bits access="rw" name="rsvd" pos="6" rst="1'b1">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_cal_gain_sel[2:0]" pos="5:3" rst="3'b100">
        <comment>gain selection for dynamic closed calibration.
		000(max) ~111(min)
		</comment>
      </bits>
      <bits access="rw" name="rfpll_cal_rdac_num[2:0]" pos="2:0" rst="3'b000">
        <comment>rdac_din and var_sel calibration bits number equal (rdac_cal_num plus 8)
		</comment>
      </bits>
    </reg>
    <reg name="REG_1a" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="pll_reset_reg" pos="15" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="pll_start_en" pos="14" rst="1'b1">
        <comment />
      </bits>
      <bits access="rw" name="adc_cal_select[1:0]" pos="13:12" rst="2'b00">
        <comment />
      </bits>
      <bits access="rw" name="dc_cal_select[1:0]" pos="11:10" rst="2'b00">
        <comment />
      </bits>
      <bits access="rw" name="crystal_offset[9:0]" pos="9:0" rst="12d0">
        <comment>"[9]: 1 = add, 0 = sub."
		"[8:0]>: 32.768 kHz crystal offset value."
		</comment>
      </bits>
    </reg>
    <reg name="REG_1b" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="offset_cal_onetime" pos="15" rst="1'b1">
        <comment />
      </bits>
      <bits access="rw" name="offset_cal_init_delay[1:0]" pos="14:13" rst="2'b00">
        <comment>00 = 32 us,  01 = 128us;
		10 = 256 us, 11 = 512us.
		</comment>
      </bits>
      <bits access="rw" name="offset_cal_bit_dr" pos="12" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="offset_cal_bit_i_reg[5:0]" pos="11:6" rst="6'b100000">
        <comment />
      </bits>
      <bits access="rw" name="offset_cal_bit_q_reg[5:0]" pos="5:0" rst="6'b100000">
        <comment />
      </bits>
    </reg>
    <reg name="REG_1c" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="dig_pwr_bit[2:0]" pos="13:11" rst="3'b100">
        <comment />
      </bits>
      <bits access="rw" name="dvdd_io_bit[1:0]" pos="10:9" rst="2'b00">
        <comment />
      </bits>
      <bits access="rw" name="ldo_vctrl1_bit[2:0]" pos="8:6" rst="3'b100">
        <comment />
      </bits>
      <bits access="rw" name="ldo_vctrl2_bit[2:0]" pos="5:3" rst="3'b011">
        <comment />
      </bits>
      <bits access="rw" name="ldo_vctrl3_bit[2:0]" pos="2:0" rst="3'b101">
        <comment />
      </bits>
    </reg>
    <reg name="REG_1d" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="reset_sdm_delay[1:0]" pos="15:14" rst="2'b10">
        <comment>00 = 64 us, 01 = 96 us,
		10 = 128 us, 11 = 160 us.
		</comment>
      </bits>
      <bits access="rw" name="sdm_resetn_dr" pos="13" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="sdm_resetn_reg" pos="12" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="reset_dsp_delay[1:0]" pos="11:10" rst="2'b00">
        <comment>00 = 32 us, 01 = 0.32 ms,
		10 = 0.64 ms, 11 = 1.28 ms.
		</comment>
      </bits>
      <bits access="rw" name="dsp_resetn_dr" pos="9" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="dsp_resetn_reg" pos="8" rst="1'b0">
        <comment />
      </bits>
      <bits access="rw" name="dac_polarity" pos="7" rst="1'b0">
        <comment>Dac power up inverse.
		</comment>
      </bits>
      <bits access="rw" name="dac_pup_delay[1:0]" pos="6:5" rst="2'b01">
        <comment>00 = 32 ms, 01 = 64 ms,
		10 = 128 ms, 11 = 256 ms.
		</comment>
      </bits>
      <bits access="rw" name="dac_pup_bypass" pos="4" rst="1'b1">
        <comment />
      </bits>
      <bits access="rw" name="i2c_drv_bit[1:0]" pos="3:2" rst="2'b10">
        <comment />
      </bits>
      <bits access="rw" name="gpio_drv_ibit[1:0]" pos="1:0" rst="2'b10">
        <comment />
      </bits>
    </reg>
    <reg name="REG_1e" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="sk_timer1[3:0]" pos="15:12" rst="4d2">
        <comment>Seek time setting for agc/afc&#8230; stable, unit 0.75ms.
		</comment>
      </bits>
      <bits access="rw" name="sk_timer2[5:0]" pos="11:6" rst="6d7">
        <comment>Seek time setting for current freq, unit 0.75ms.
		</comment>
      </bits>
      <bits access="rw" name="sk_timer3[5:0]" pos="5:0" rst="6d5">
        <comment>Seek time setting for upper/lower adjacent freq, unit 0.75ms.
		</comment>
      </bits>
    </reg>
    <reg name="REG_1f" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="th_softblend2[5:0]" pos="14:9" rst="6d20">
        <comment>Threshold for noise soft blend setting, unit 2dB.	
			Force to mono mode when (127-noise_db2) less than 2*th_softblend2,		
			Release to stereo mode when (127-noise_db2) more than 2*(8+th_softblend2).
		</comment>
      </bits>
      <bits access="rw" name="gainct[8:0]" pos="8:0" rst="9'b010_000110">
        <comment>"[8:6]: gain adjust to mpx signal, step 3dB from -6dB to 15dB."		
		[5:3]: gain adjust to L/R channel after dcc before deemph, 6dB step.	
		[2]: gain adjust to L/R channel after dcc before deemph, 2dB step.		
		[1]: gain adjust to L/R channel after dcc before deemph, 2dB step.	
		[0]: gain adjust to L/R channel after dcc before deemph, 1dB step.
		</comment>
      </bits>
    </reg>
    <reg name="REG_20" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="seek_mode[2]" pos="14">
        <comment>Seek_mode[2:0] definition:
		000 = seek current freq only.
		001,010 = seek current freq and adjacent freq.
		011 = seek stop at SNR_ST.
		100 = seek stop at CENTER_ST.
		101 = seek stop at UPPER_ST.
		110 = seek stop at LOWER_ST.
		111 = seek bypass.
		</comment>
      </bits>
      <bits access="rw" name="reserved seek_mode[2:0]" pos="13:12" rst="3'b001">
      </bits>
      <bits access="rw" name="sel_fircut[2:0]" pos="11:9" rst="3'b111">
        <comment>Valid when rds_en = 0
		Fircut band width setting.
		111 = 180 kHz, 110 = 160 kHz,
		101 = 140 kHz, 100 = 120 kHz,
		011 = 100 kHz, 010 = 80 kHz,
		001 = 60 kHz, 000 = 40 kHz.
		</comment>
      </bits>
      <bits access="rw" name="sel_fircut2[2:0]" pos="8:6" rst="3'b100">
        <comment>Valid when rds_en = 0
		Fircut band width setting under worse condition.
		111(180kHz)~000(40kHz).
		</comment>
      </bits>
      <bits access="rw" name="fircut_sel0-2:0" pos="5:3">
        <comment>seek current freq fircut BW setting.
		</comment>
      </bits>
      <bits access="rw" name="fircut_offset_sel_bypass" pos="2">
        <comment>1 = bypass
		</comment>
      </bits>
    </reg>
    <reg name="REG_21" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="imgrej" pos="14" rst="1'b0">
        <comment>+/- 125kHz.
		</comment>
      </bits>
      <bits access="rw" name="imgrej_dsp" pos="13" rst="1'b0">
        <comment>I/Q swap before 125kHz mixer.
		</comment>
      </bits>
      <bits access="rw" name="iq_swap" pos="12" rst="1'b0">
        <comment>I/Q swap after 125kHz mixer.
		</comment>
      </bits>
      <bits access="rw" name="fircut_bypass" pos="11" rst="1'b0">
        <comment>1 = bypass fircut.
		</comment>
      </bits>
      <bits access="rw" name="bypass_lpf" pos="10" rst="1'b0">
        <comment>1 = bypass 15kHz lpf.
		</comment>
      </bits>
      <bits access="rw" name="lr_swap" pos="9" rst="1'b0">
        <comment>1 = L/R swap.
		</comment>
      </bits>
      <bits access="rw" name="pilot_cosine" pos="8" rst="1'b0">
        <comment>1 = cosine pilot.
		</comment>
      </bits>
      <bits access="rw" name="audio_dcc_bypass" pos="7" rst="1'b0">
        <comment>1 = bypass dcc.
		</comment>
      </bits>
      <bits access="rw" name="deemph_bypass" pos="6" rst="1'b0">
        <comment>1 = bypass deemph.
		</comment>
      </bits>
      <bits access="rw" name="sdm_bypass" pos="5" rst="1'b0">
        <comment>1 = bypass sdm.
		</comment>
      </bits>
      <bits access="rw" name="ts_mod[4:0]" pos="4:0" rst="5d0">
        <comment>5'h1f = dac test mode(reserved_dsp)
		5'h1e = dccancel out
		5'h1d = dc out
		5'h1c = sinc limit out
		5'h1b = 125k mixer out
		5'h1a = hbfilter1 out
		5'h19 = cordic in(before fm demod)
		5'h18 = cordic out(after fm demod)
		5'h17 = hbfiter3 out(L), mpx38k(R)
		5'h16 = stereo demod out
		5'h15 = rssi iir out 1
		5'h14 = rssi iir out 2
		5'h13 = offset
		5'h12 = agc_index(L), afc_out(R)
		5'h11 = rssi_db1(L), signal_db1(R)
		5'h10 = noise_db1(L), pilot_db1(R)
		5'h0f = rds_sinc_out_i/q
		5'h0e = rds_lpfil_out_i/q
		5'h0d = rds_pfd_out(L),
		rds_loopfil_out(R)
		5'h0c = sine 125k test
		5'h0b = angle_57k(L),
		rds_angle_out(R)
		5'h0a = rds_notchfil_out(L),
		rds_pll2ord_acc(R)
		5'h09 = rds_matchfil_out(L),
		rds_hpfil_out(R)
		5'h08 = cos19k(L), sin38k(R)
		5'h07~5'h04, reserved
		5'h03 = TEST
		5'h02 = reserved
		5'h01 = reserved
		5'h00 = channel out
		</comment>
      </bits>
    </reg>
    <reg name="REG_22" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="rssi_h_th[6:0]" pos="13:11" rst="7d20">
        <comment>RSSI high threshold, unit 1dB.
		</comment>
      </bits>
      <bits access="rw" name="rssi_l_th[6:0]" pos="10:0" rst="7d15">
        <comment>RSSI low threshold, unit 1dB.
		</comment>
      </bits>
    </reg>
    <reg name="REG_23" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="noise_h_th[6:04]" pos="13:711" rst="7d72">
        <comment>NOISE high threshold high 3bits, unit 1dB.
		</comment>
      </bits>
      <bits access="rw" name="reservednoise_l_th[6:0]" pos="610:0" rst="7d68">
        <comment>NOISE low threshold, unit 1dB
		</comment>
      </bits>
    </reg>
    <reg name="REG_24" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="pilot_h_th[6:0]" pos="13:7" rst="7d10">
        <comment>PILOT high threshold, unit 1dB.
		</comment>
      </bits>
      <bits access="rw" name="pilot_l_th[6:0]" pos="6:0" rst="7d6">
        <comment>PILOT low threshold, unit 1dB
		</comment>
      </bits>
    </reg>
    <reg name="REG_25" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="offset_h_th[6:0]" pos="13:7" rst="7d25">
        <comment>OFFSET high threshold, unit 1.28kHz.
		</comment>
      </bits>
      <bits access="rw" name="offset_l_th[6:0]" pos="6:0" rst="7d16">
        <comment>OFFSET low threshold, unit 1.28kHz
		</comment>
      </bits>
    </reg>
    <reg name="REG_26" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="sk_timer4[5:0]" pos="15:10" rst="6d40">
        <comment>Seek time setting for SNR detect, unit 0.75ms.
		</comment>
      </bits>
      <bits access="rw" name="snr_th[5:0]" pos="9:4" rst="6d18">
        <comment>Threshold for SNR, unit dB.
		</comment>
      </bits>
      <bits access="rw" name="snr_cnt_th[3:0]" pos="3:0" rst="4d5">
        <comment>SNR counter threshold.
		</comment>
      </bits>
    </reg>
    <reg name="REG_27" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>
      <bits access="rw" name="rssi_select[1:0]" pos="15:14" rst="2'b00">
        <comment>[1]: 1 = sdm_dither_bypass
		[0]: rssi_select[0]? offset4 :
		</comment>
      </bits>
      <bits access="rw" name="adc_ictrl_bit_cal[1:0]" pos="13:12" rst="2'b00">
        <comment>adc_ictrl_bit for calibration
		</comment>
      </bits>
      <bits access="rw" name="ct_u_rssi[5:0]" pos="11:6" rst="6'b011_100">
        <comment>[5 :3] : rssi_db1 BW setting
		[2 :0] : rssi_db2 BW setting
		</comment>
      </bits>
    <bits access="rw" name="ct_u_noise[5:0]" pos="5:0" rst="6'b011_100">
        <comment>[5 :3] : noise_db1 BW setting
		[2 :0] : noise_db2 BW setting
		</comment>
      </bits>
    </reg>
    <reg name="REG_28" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="audio_dcc_ct[2:0]" pos="13:11" rst="3'b101">
        <comment>BW setting for audio dcc.
		111 = 4 Hz, 110 = 7Hz, 101 = 15Hz,
		100 = 30 Hz, 011 = 60 Hz,
		010 = 125 Hz, 001 = 250 Hz,
		000 = 500 Hz.
		</comment>
      </bits>
      <bits access="rw" name="bass_gain[1:0]" pos="10:9" rst="2'b01">
        <comment>Bass_boost gain.
		00: 6dB; 01: 9dB; 10: 14dB; 11: 24dB
		</comment>
      </bits>
      <bits access="rw" name="volume[3:0]" pos="8:5" rst="4'b1111">
        <comment>Gain adjust to L/R signal (after deemph)
		Setp 1dB from -15dB(0000) to 0dB(1111)
		</comment>
      </bits>
      <bits access="rw" name="rssi_flt_ct_u[4:0]" pos="4:0" rst="5'b0_1000">
        <comment>00(wide)~11(narrow)
		00(wide)~11(narrow)
		</comment>
      </bits>
    </reg>
    <reg name="REG_29" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:12">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="softmute_th2[5:0]" pos="11:6" rst="6d20">
        <comment>Soft mute threshold setting for noise.
		If (127-noise_db2)>2*th_softmute2, turn soft mute off.
		</comment>
      </bits>
      <bits access="rw" name="softmute_th3[5:0]" pos="5:0" rst="6d5">
        <comment>Soft mute threshold setting for snr.
		If (snr*2)>2*th_softmute3, turn soft mute off.
		</comment>
      </bits>
    </reg>
    <reg name="REG_2a" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="pilot_cnt_th[7:0]" pos="15:8" rst="8d50">
        <comment>Pilot counter setting for seek process.
		</comment>
      </bits>
      <bits access="rw" name="rssi_cnt_th[7:0]" pos="7:0" rst="8d50">
        <comment>Rssi counter setting for seek process.
		</comment>
      </bits>
    </reg>
    <reg name="REG_2b" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="noise_cnt_th[7:0]" pos="15:8" rst="8d50">
        <comment>Noise counter setting for seek process.
		</comment>
      </bits>
      <bits access="rw" name="offset_cnt_th[7:0]" pos="7:0" rst="8d50">
        <comment>Offset counter setting for seek process.
		</comment>
      </bits>
    </reg>
    <reg name="REG_2c" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:12">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="ct_u_pilot[5:0]" pos="11:6" rst="6'b011_100" >
        <comment>[5 :3] : pilot_db1 BW setting
		[2 :0] : pilot_db2 BW setting
		</comment>
      </bits>
      <bits access="rw" name="rsvd" pos="5:0" rst="6'b011_100" >
        <comment>[5 :3] : signal_db1 BW setting
		[2 :0] : signal_db2 BW setting
		</comment>
      </bits>
    </reg>
    <reg name="REG_2d" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="afc_select0" pos="13" rst="1'b1">
        <comment>1 = adjust 125k mixer
		0 = adjust var_sel and rdac_din
		</comment>
      </bits>
      <bits access="rw" name="afc_inv0" pos="12" rst="1'b1">
        <comment>1 = inverse afc adjust value
		</comment>
      </bits>
      <bits access="rw" name="seek_afc_on" pos="11" rst="1'b1">
        <comment>1 = afc enabled when seek.
		</comment>
      </bits>
      <bits access="rw" name="afc_ct[5:0]" pos="10:5" rst="6'b100_110">
        <comment>000(wide)~111(narrow)
		000(fast)~111(slow)
		</comment>
      </bits>
      <bits access="rw" name="seek_range[4:0]" pos="4:0" rst="5d20">
        <comment>Seek upper/lower adjacent freq setting, unit 5.12kHz
		</comment>
      </bits>
    </reg>
    <reg name="REG_2e" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:12">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="afc_range[5:0]" pos="11:6" rst="6d7">
        <comment>Afc following range, unit 2.5kHz
		</comment>
      </bits>
      <bits access="rw" name="afc_ct_sk[5:0]" pos="5:0" rst="6'b010_010">
        <comment>Afc BW setting when seek.
		000(wide)~111(narrow)
		000(fast)~111(slow)
		</comment>
      </bits>
    </reg>
    <reg name="REG_2f" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="limit_sel" pos="13" rst="1'b1">
        <comment>1 = *1.0, 0 = *0.75 to sinc1 out signal
		</comment>
      </bits>
      <bits access="rw" name="dig_delayct[4:0]" pos="12:8" rst="5d10">
        <comment>Dig gain change delay setting, unit 0.375us.
		</comment>
      </bits>
      <bits access="rw" name="dc_ct[7:0]" pos="7:0" rst="8'b0111_1011">
        <comment>Dc cancel control
		00: fast-]slow
		01: slow
		10: fast
		00:64, 01:128, 10:256        , 11:512
		00:4, 01:5, 10:6, 11:7
		00:8, 01:9, 10:10, 11:11
		</comment>
      </bits>
    </reg>
    <reg name="REG_30" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="softmute_th[5:0]" pos="13:8" rst="6d34">
        <comment>Soft mute threshold setting for rssi.
		If rssi_db2 more than 2*th_softmute, turn soft mute off.
		</comment>
      </bits>
      <bits access="rw" name="ct_interval_sm[1:0]" pos="7:6" rst="2'b0">
        <comment>Step loop:
		00: 25ms; 01: 100ms; 10: 200ms; 11:400ms
		</comment>
      </bits>
      <bits access="rw" name="sm_attenu[3:0]" pos="5:2" rst="4'b1111">
        <comment>Soft mute attenu setting, index less than  sm_attenu, index range is:0000(0dB)~1111(-78dB) leaner
		</comment>
      </bits>
      <bits access="rw" name="sm_rate[1:0]" pos="1:0" rst="2'b01">
        <comment>00: fast(1dB step);
		01: normal(2dB step) ;
		10: slow(4dB step);
		11: slowest(8dB step)
		</comment>
      </bits>
    </reg>
    <reg name="REG_31" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:13">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="nco_ct_u[2:0]" pos="12:10" rst="3'b100">
        <comment>NCO dc BW setting.
		000(wide)~111(narrow)
		</comment>
      </bits>
      <bits access="rw" name="nco_ct_u_dt[2:0]" pos="9:7" rst="3'b110">
        <comment>19kHz tone detect BW setting.
		000(wide)~111(narrow)
		</comment>
      </bits>
      <bits access="rw" name="nco_ct_u_dt_sk[2:0]" pos="6:4" rst="3'b011">
        <comment>19kHz tone detect BW setting when seek.
		000(wide)~111(narrow)
		</comment>
      </bits>
      <bits access="rw" name="nco_ct_bw[3:0]" pos="3:0" rst="4'b1010">
        <comment>NCO 2ord BW setting.
		00(max)~11(min)
		</comment>
      </bits>
    </reg>
    <reg name="REG_32" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="over_th_sel[2:0]" pos="14:12" rst="3'b100">
        <comment>11: 1v, 10: 0.95v, 01: 0.9v, 00: 0.75v
		</comment>
      </bits>
      <bits access="rw" name="ct_endelay[2:0]" pos="11:9" rst="3'b100">
        <comment>PGA_AGC enable delay time after reset
		000 = 0.375us, 001 = 3us, 010 = 6us,
		011 = 9.75us, 100 = 13.875us,
		101 = 18us, 110 = 21us, 111 = 24us
		</comment>
      </bits>
      <bits access="rw" name="agc_index_in[3:0]" pos="8:5" rst="4'b1111">
        <comment>Agc analog gain initial index
		</comment>
      </bits>
      <bits access="rw" name="agc_thd[4:0]" pos="4:0" rst="5d16">
        <comment>Agc digital gain th, unit 2dB
		Limit digital gain to agc_thd*2 dB
		</comment>
      </bits>
    </reg>
    <reg name="REG_33" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="agc_ct_u[2:0]" pos="15:13" rst="3'b001">
        <comment>[2]: 1 = disable agc target comp sent
		[1:0]: BW setting 
		</comment>
      </bits>
      <bits access="rw" name="agc_test" pos="12" rst="1'b0">
        <comment>1 = test, fix analog gain and digital gain
		</comment>
      </bits>
      <bits access="rw" name="agc_update0[2:0]" pos="11:9" rst="3'b000">
        <comment>Agc updata time when seek mode
		111 (slow)~000 (fast)
		</comment>
      </bits>
      <bits access="rw" name="agc_update1[2:0]" pos="8:6" rst="3'b100">
        <comment>Agc updata time when normal mode
		111 (slow)~000 (fast)
		</comment>
      </bits>
      <bits access="rw" name="agc_loop_gain0[2:0]" pos="5:3" rst="3'b111">
        <comment>Agc loop gain when seek mode
		111 (fast)~000 (slow)
		</comment>
      </bits>
      <bits access="rw" name="agc_loop_gain1[2:0]" pos="2:0" rst="3'b100">
        <comment>Agc loop gain when normal mode
		111 (fast)~000 (slow)
		</comment>
      </bits>
    </reg>
    <reg name="REG_34" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:13">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="dig_gain_in[4]" pos="12">
        <comment>{ig_ain_in[4], jig_gain_in[3:0]}
		</comment>
      </bits>
      <bits access="rw" name="agc_target_pwr[5:0]" pos="11:6" rst="6d38">
        <comment>Agc target power, unit 2dB
		</comment>
      </bits>
      <bits access="rw" name="agc_chg_th[1:0]" pos="5:4" rst="2d1">
        <comment>Agc adjust th, unit dB
		</comment>
      </bits>
      <bits access="rw" name="dig_gain_in[3:0]" pos="3:0" rst="4d6">
        <comment>Agc digital gain initial index
		</comment>
      </bits>
    </reg>
    <reg name="REG_35" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:13">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="log_over_sel" pos="12" rst="1'b1">
        <comment>If 1, adjust agc_index sub step when log_agc>log_agc_th
		</comment>
      </bits>
      <bits access="rw" name="log_agc_th[5:0]" pos="11:6" rst="6d60">
        <comment>Threshold for agc loop adjust, unit 1dB
		Threshold = 64+log_agc_th dB
		</comment>
      </bits>
      <bits access="rw" name="over_step[5:0]" pos="5:0" rst="5'b100_010">
        <comment>[5:3] : Agc loop sub step when sinc_over or log_agc more than th, unit 1dB	
		[2:0] : agc loop sub/add step when acc is saturation, unit 1dB
		</comment>
      </bits>
    </reg>
    <reg name="REG_36" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="afc_select1" pos="15" rst="1'b1">
        <comment>1 = adjust 125k mixer
		0 = adjust var_sel and rdac_din
		</comment>
      </bits>
      <bits access="rw" name="afc_inv1" pos="14" rst="1'b1">
        <comment>1 = inverse afc adjust value
		</comment>
      </bits>
      <bits access="rw" name="freq_change_dr" pos="13" rst="1'b0">
        <comment>If 1, then adc clk freq changed when freq_change_reg = 1.
		</comment>
      </bits>
      <bits access="rw" name="freq_change_reg" pos="12" rst="1'b0">
        <comment>Valid when freq_change_dr = 1
		</comment>
      </bits>
      <bits access="rw" name="rfpll_close_cal_gain[1:0]" pos="11:10">
        <comment />
      </bits>
      <bits access="rw" name="dac_gain_bit_pwrup" pos="9:6">
        <comment>Dac gain bit when power up
		</comment>
      </bits>
      <bits access="rw" name="rfpll_cal_time_sel_sk[2:0]" pos="5:3">
        <comment />
      </bits>
      <bits access="rw" name="rfpll_cal_gain_sel_sk[2:0]" pos="2:0">
        <comment />
      </bits>
    </reg>
    <reg name="REG_37" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="th_max_bw[6:0]" pos="13:7" rst="7d24">
        <comment>Fircut/LPF15khz/gain38k change high threshold for RSSI, unit 1dB
		</comment>
      </bits>
      <bits access="rw" name="th_min_bw[6:0]" pos="6:0" rst="7d16">
        <comment>Fircut/gain38k change low threshold for RSSI, unit 1dB
		</comment>
      </bits>
    </reg>
    <reg name="REG_38" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="nco_ct_bw[3:0]" pos="14:11" rst="4'b1101">
        <comment />
      </bits>
      <bits access="rw" name="reserved" pos="10">
        <comment />
      </bits>
      <bits access="rw" name="Lpf15k_bw_dr" pos="9">
        <comment />
      </bits>
      <bits access="rw" name="lpf15k_bw_reg[2:0]" pos="8:6" rst="6d16">
        <comment />
      </bits>
      <bits access="rw" name="th_min_hcc[5:0]" pos="5:0" rst="6d32">
        <comment>lpf15k_bw threshold, unit 2dB.
		</comment>
      </bits>
    </reg>
    <reg name="REG_39" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="lna_gain_bit_f[1:0]" pos="13:12" rst="2'b11">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_f[2:0]" pos="11:9" rst="3'b111">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_f[1:0]" pos="8:7" rst="2'b11">
        <comment />
      </bits>
      <bits access="rw" name="lna_gain_bit_e[1:0]" pos="6:5" rst="2'b10">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_e[2:0]" pos="4:2" rst="3'b111">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_e[1:0]" pos="1:0" rst="2'b11">
        <comment />
      </bits>
    </reg>
    <reg name="REG_3a" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="lna_gain_bit_d[1:0]" pos="13:12" rst="2'b10">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_d[2:0]" pos="11:9" rst="3'b110">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_d[1:0]" pos="8:7" rst="2'b11">
        <comment />
      </bits>
      <bits access="rw" name="lna_gain_bit_c[1:0]" pos="6:5" rst="2'b10">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_c[2:0]" pos="4:2" rst="3'b101">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_c[1:0]" pos="1:0" rst="2'b11">
        <comment />
      </bits>
    </reg>
    <reg name="REG_3b" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="lna_gain_bit_b[1:0]" pos="13:12" rst="2'b10">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_b[2:0]" pos="11:9" rst="3'b100">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_b[1:0]" pos="8:7" rst="2'b11">
        <comment />
      </bits>
      <bits access="rw" name="lna_gain_bit_a[1:0]" pos="6:5" rst="2'b10">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_a[2:0]" pos="4:2" rst="3'b011">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_a[1:0]" pos="1:0" rst="2'b11">
        <comment />
      </bits>
    </reg>
    <reg name="REG_3c" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="lna_gain_bit_9[1:0]" pos="13:12" rst="2'b01">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_9[2:0]" pos="11:9" rst="3'b011">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_9[1:0]" pos="8:7" rst="2'b11">
        <comment />
      </bits>
      <bits access="rw" name="lna_gain_bit_8[1:0]" pos="6:5" rst="2'b01">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_8[2:0]" pos="4:2" rst="3'b010">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_8[1:0]" pos="1:0" rst="2'b11">
        <comment />
      </bits>
    </reg>
    <reg name="REG_3d" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="lna_gain_bit_7[1:0]" pos="13:12" rst="2'b01">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_7[2:0]" pos="11:9" rst="3'b001">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_7[1:0]" pos="8:7" rst="2'b11">
        <comment />
      </bits>
      <bits access="rw" name="lna_gain_bit_6[1:0]" pos="6:5" rst="2'b01">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_6[2:0]" pos="4:2" rst="3'b000">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_6[1:0]" pos="1:0" rst="2'b11">
        <comment />
      </bits>
    </reg>
    <reg name="REG_3e" protect="rw">
       <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>   	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="lna_gain_bit_5[1:0]" pos="13:12" rst="2'b00">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_5[2:0]" pos="11:9" rst="3'b000">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_5[1:0]" pos="8:7" rst="2'b11">
        <comment />
      </bits>
      <bits access="rw" name="lna_gain_bit_4[1:0]" pos="6:5" rst="2'b00">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_4[2:0]" pos="4:2" rst="3'b000">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_4[1:0]" pos="1:0" rst="2'b10">
        <comment />
      </bits>
    </reg>
    <reg name="REG_3f" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:14">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="lna_gain_bit_3[1:0]" pos="13:12" rst="2'b00">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_3[2:0]" pos="11:9" rst="3'b000">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_3[1:0]" pos="8:7" rst="2'b01">
        <comment />
      </bits>
      <bits access="rw" name="lna_gain_bit_2[1:0]" pos="6:5" rst="2'b00">
        <comment />
      </bits>
      <bits access="rw" name="pga_gain_bit_2[2:0]" pos="4:2" rst="3'b000">
        <comment />
      </bits>
      <bits access="rw" name="adc_gain_bit_2[1:0]" pos="1:0" rst="2'b00">
        <comment />
      </bits>
    </reg>
    <reg name="REG_40" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:0">
        <comment />
      </bits>
    </reg>
    <reg name="REG_41" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15:0">
        <comment />
      </bits>
    </reg>
    <reg name="REG_42" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="ana_gain_rssi_f[7:0]" pos="15:8" rst="8d66">
        <comment />
      </bits>
      <bits access="rw" name="ana_gain_rssi_e[7:0]" pos="7:0" rst="8d60">
        <comment />
      </bits>
    </reg>
    <reg name="REG_43" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="ana_gain_rssi_d[7:0]" pos="15:8" rst="8d54">
        <comment />
      </bits>
      <bits access="rw" name="ana_gain_rssi_c[7:0]" pos="7:0" rst="8d48">
        <comment />
      </bits>
    </reg>
    <reg name="REG_44" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="ana_gain_rssi_b[7:0]" pos="15:8" rst="8d42">
        <comment />
      </bits>
      <bits access="rw" name="ana_gain_rssi_a[7:0]" pos="7:0" rst="8d36">
        <comment />
      </bits>
    </reg>
    <reg name="REG_45" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="ana_gain_rssi_9[7:0]" pos="15:8" rst="8d30">
        <comment />
      </bits>
      <bits access="rw" name="ana_gain_rssi_8[7:0]" pos="7:0" rst="8d24">
        <comment />
      </bits>
    </reg>
    <reg name="REG_46" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="ana_gain_rssi_7[7:0]" pos="15:8" rst="8d18">
        <comment />
      </bits>
      <bits access="rw" name="ana_gain_rssi_6[7:0]" pos="7:0" rst="8d12">
        <comment />
      </bits>
    </reg>
    <reg name="REG_47" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="ana_gain_rssi_5[7:0]" pos="15:8" rst="8d6">
        <comment />
      </bits>
      <bits access="rw" name="ana_gain_rssi_4[7:0]" pos="7:0" rst="8d0">
        <comment />
      </bits>
    </reg>
    <reg name="REG_48" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="ana_gain_rssi_3[7:0]" pos="15:8" rst="-8d6">
        <comment />
      </bits>
      <bits access="rw" name="ana_gain_rssi_2[7:0]" pos="7:0" rst="-8d12">
        <comment />
      </bits>
    </reg>
    <reg name="REG_49" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="rsvd" pos="15">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="rw" name="interval_dr" pos="14" rst="1'b0">
        <comment>Direct mode enable
		</comment>
      </bits>
      <bits access="rw" name="interval_reg[13:0]" pos="13:0" rst="14d6144">
        <comment>Interval direct value when interval_dr =1
		</comment>
      </bits>
    </reg>
    <reg name="REG_4a (Read Only)" protect="rw">
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="r" name="rssi_cnt[7:0]" pos="15:8">
        <comment />
      </bits>
      <bits access="r" name="noise_cnt[7:0]" pos="7:0">
        <comment />
      </bits>
    </reg>
    <reg name="REG_4b (Read Only)" protect="rw">
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="r" name="pilot_cnt[7:0]" pos="15:8">
        <comment />
      </bits>
      <bits access="r" name="offset_cnt[7:0]" pos="7:0">
        <comment />
      </bits>
    </reg>
    <reg name="REG_4c (Read Only)" protect="rw">
      <bits name="read_req" pos="30" access="rw">
      </bits>   	
      <bits access="r" name="rsvd" pos="15:13">
        <comment>Read as 0.
		</comment>
      </bits>
      <bits access="r" name="noise_db2[6:0]" pos="12:6">
        <comment />
      </bits>
      <bits access="r" name="snr19k_out[5:0]" pos="5:0">
        <comment />
      </bits>
    </reg>
    <reg name="REG_4d (Read Only)" protect="rw">
      <bits name="read_req" pos="30" access="rw">
      </bits>   	
      <bits access="r" name="ct_hcc[1:0]" pos="15:14">
        <comment />
      </bits>
      <bits access="r" name="fircut_bw[2:0]" pos="13:11">
        <comment />
      </bits>
      <bits access="r" name="snr_cnt2[3:0]" pos="10:7">
        <comment />
      </bits>
      <bits access="r" name="pilot_db2[6:0]" pos="6:0">
        <comment />
      </bits>
    </reg>
    <reg name="REG_4e (Read Only)" protect="rw">
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="r" name="rsvd" pos="15:13">
        <comment />
      </bits>
      <bits access="r" name="fmdem_sel" pos="12">
        <comment>1 = plldem, 0 = cordic
		</comment>
      </bits>
      <bits access="rw" name="dig_gainct[7:4]" pos="11:8">
        <comment>dig_gainct signe bit
		</comment>
      </bits>
      <bits access="rw" name="index_out[3:0]" pos="7:4">
        <comment />
      </bits>
      <bits access="rw" name="dig_gaict[3:0]" pos="3:0">
        <comment />
      </bits>
    </reg>
    <reg name="REG_4f" protect="rw">
      <bits name="write_req" pos="31" access="rw">
      </bits>
      <bits name="read_req" pos="30" access="rw">
      </bits>    	
      <bits access="rw" name="reserved_dsp[15:0]" pos="15:0" rst="16hd1f9">
        <comment>[15:10]: softmute_th4, Soft mute threshold setting for offset2, unit 2.56kHz.	
		"If (127-offset2/2)>2*th_softmute4, turn soft mute off."	
		[2]: noise_cancel_sel. 1= rssi_db2, 0 = ~noise_db2.
		</comment>
      </bits>
    </reg>
<reg name="REG_50" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="rsvd" pos="15" access="rw">
            <comment>rsvd &#60;15&#62;
            </comment>
        </bits>
        <bits name="offset_enable" pos="14" access="rw">
            <comment>offset_enable &#60;14&#62;
            </comment>
        </bits>
        <bits name="offset_value" pos="13:0" access="rw">
            <comment>offset_value &#60;13:0&#62;
            </comment>
        </bits>
    </reg>
  <reg name="REG_51" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="rsvd" pos="15:14" access="rw">
            <comment>rsvd &#60;15:14&#62;
            </comment>
        </bits>
        <bits name="dither_bypass" pos="13" access="rw">
            <comment>dither_bypass &#60;13&#62;
            </comment>
        </bits>
        <bits name="tri_wave_bypass" pos="12" access="rw">
            <comment>tri_wave_bypass &#60;12&#62;
            </comment>
        </bits>
        <bits name="nphase" pos="11:8" access="rw">
            <comment>nphase &#60;11:8&#62;
            </comment>
        </bits>
        <bits name="int_dec_sel[" pos="7:6" access="rw">
            <comment>int_dec_sel[ &#60;7:6&#62;
            </comment>
        </bits>
        <bits name="dec_numerator" pos="5:3" access="rw">
            <comment>dec_numerator &#60;5:3&#62;
            </comment>
        </bits>
        <bits name="offset_mode" pos="2:0" access="rw">
            <comment>offset_mode &#60;2:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="REG_52" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="rsvd" pos="15:8" access="rw">
            <comment>rsvd &#60;15:8&#62;
            </comment>
        </bits>
        <bits name="reserved_sdm" pos="7:0" access="rw">
            <comment>reserved_sdm &#60;7:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="REG_53" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="rsvd" pos="15" access="rw">
            <comment>rsvd &#60;15&#62;
            </comment>
        </bits>
        <bits name="gain_38k1" pos="14:0" access="rw">
            <comment>gain_38k1 &#60;14:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="REG_54" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="rsvd" pos="15" access="rw">
            <comment>rsvd &#60;15&#62;
            </comment>
        </bits>
        <bits name="gain_38k2" pos="14:0" access="rw">
            <comment>gain_38k2 &#60;14:0&#62;
            </comment>
        </bits>
    </reg>
  <reg name="REG_55" protect="rw">
        <bits name="write_req" pos="31" access="rw">
       </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="rds_rolloff" pos="15:13" access="rw">
            <comment>rds_rolloff Rds lpf bw setting &#60;15:13&#62;
            </comment>
        </bits>
        <bits name="rds_pfd_gain" pos="12:10" access="rw">
            <comment>rds_pfd_gain &#60;12:10&#62;
            </comment>
        </bits>
        <bits name="rds_nco_ct_u" pos="9:7" access="rw">
            <comment>rds_nco_ct_u &#60;9:7&#62;
            </comment>
        </bits>
        <bits name="rds_nco_ct_bw" pos="6:1" access="rw">
            <comment>rds_nco_ct_bw &#60;6:1&#62;
            </comment>
        </bits>
        <bits name="rds_pll_1ord[" pos="0" access="rw">
            <comment>rds_pll_1ord[ &#60;0&#62;
            </comment>
        </bits>
    </reg>    
  <reg name="REG_56" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="rds_gain_ct_u" pos="15:13" access="rw">
            <comment>rds_gain_ct_u &#60;15:13&#62;
            </comment>
        </bits>
        <bits name="rds_hpf_ct_u" pos="12:10" access="rw">
            <comment>rds_hpf_ct_u &#60;12:10&#62;
            </comment>
        </bits>
        <bits name="rds_match_ct_u" pos="9:7" access="rw">
            <comment>rds_match_ct_u &#60;9:7&#62;
            </comment>
        </bits>
        <bits name="rds_gain_dr" pos="6" access="rw">
            <comment>rds_gain_dr &#60;6&#62;
            </comment>
        </bits>
        <bits name="rds_gain1[" pos="5:0" access="rw">
            <comment>rds_gain1[ &#60;5:0&#62;
            </comment>
        </bits>
    </reg>    
  <reg name="REG_57" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="rsvd" pos="15" access="rw">
            <comment>rsvd &#60;15&#62;
            </comment>
        </bits>
        <bits name="rds_test" pos="14" access="rw">
            <comment>rds_test &#60;14&#62;
            </comment>
        </bits>
        <bits name="rds_noerror_cm" pos="13" access="rw">
            <comment>rds_noerror_cm &#60;13&#62;
            </comment>
        </bits>
        <bits name="rds_noshift_cm" pos="12" access="rw">
            <comment>rds_noshift_cm &#60;12&#62;
            </comment>
        </bits>
        <bits name="rds_sync_th1[" pos="11:6" access="rw">
            <comment>rds_sync_th1[ &#60;11:6&#62;
            </comment>
        </bits>
        <bits name="rds_sync_th2[" pos="5:0" access="rw">
            <comment>rds_sync_th2[ &#60;5:0&#62;
            </comment>
        </bits>
    </reg>    
 <reg name="REG_58" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="rsvd" pos="15" access="rw">
            <comment>rsvd &#60;15&#62;
            </comment>
        </bits>
        <bits name="rds_lpfil_bypass" pos="14" access="rw">
            <comment>rds_lpfil_bypass &#60;14&#62;
            </comment>
        </bits>
        <bits name="rds_notchfil_bypass" pos="13" access="rw">
            <comment>rds_notchfil_bypass &#60;13&#62;
            </comment>
        </bits>
        <bits name="rds_hpfil_bypass" pos="12" access="rw">
            <comment>rds_hpfil_bypass &#60;12&#62;
            </comment>
        </bits>
        <bits name="rds_h_th[" pos="11:6" access="rw">
            <comment>rds_h_th[ &#60;11:6&#62;
            </comment>
        </bits>
        <bits name="rds_l_th[" pos="5:0" access="rw">
            <comment>rds_l_th[ &#60;5:0&#62;
            </comment>
        </bits>
    </reg>                    
   <reg name="REG_59" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="rsvd" pos="15" access="rw">
            <comment>rsvd &#60;15&#62;
            </comment>
        </bits>
        <bits name="rds_cnt_th" pos="14:9" access="rw">
            <comment>rds_cnt_th &#60;14:9&#62;
            </comment>
        </bits>
       <bits name="gain_target[" pos="8:3" access="rw">
            <comment>gain_target[ &#60;8:3&#62;
            </comment>
        </bits>
        <bits name="gain_chg_th[" pos="2:0" access="rw">
            <comment>gain_chg_th[ &#60;2:0&#62;
            </comment>
        </bits>
    </reg>   
   <reg name="REG_5a" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="rsvd" pos="15" access="rw">
            <comment>rsvd &#60;15&#62;
            </comment>
        </bits>
        <bits name="rds_cnt" pos="14:7" access="r">
            <comment>rds_cnt &#60;14:7&#62;
            </comment>
        </bits>
        <bits name="rds_db2[" pos="6:0" access="r">
            <comment>rds_db2[ &#60;6:0&#62;
            </comment>
        </bits>
    </reg>   
   <reg name="REG_5b" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="plldem_gain" pos="15:10" access="rw">
            <comment>plldem_gain &#60;15:10&#62;
            </comment>
        </bits>
        <bits name="pfd_sel" pos="8" access="rw">
            <comment>pfd_sel &#60;8&#62;
            </comment>
        </bits>
        <bits name="rds_gain rssi sel" pos="7" access="rw">
            <comment>rds_gain rssi sel &#60;7&#62;
            </comment>
        </bits>
        <bits name="rds nco disable" pos="6" access="rw">
            <comment>rds nco disable &#60;6&#62;
            </comment>
        </bits>
        <bits name=" rds_en_stretch" pos="5" access="rw">
            <comment> rds_en_stretch &#60;5&#62;
            </comment>
        </bits>
        <bits name="rds_err_th[" pos="4:1" access="rw">
            <comment>rds_err_th[ &#60;4:1&#62;
            </comment>
        </bits>
        <bits name=" bpf_57k bypass" pos="0" access="rw">
            <comment> bpf_57k bypass &#60;0&#62;
            </comment>
        </bits>
    </reg>   
    <reg name="REG_5c" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="plldem_swap" pos="15" access="rw">
            <comment>plldem_swap &#60;15&#62;
            </comment>
        </bits>
        <bits name="fmdem_sel_grp" pos="14:12" access="rw">
            <comment>fmdem_sel_grp &#60;14:12&#62;
            </comment>
        </bits>
        <bits name="plldem_th_max" pos="11:6" access="rw">
            <comment>plldem_th_max &#60;11:6&#62;
            </comment>
        </bits>
        <bits name="plldem_th_min" pos="5:0" access="rw">
            <comment>plldem_th_min &#60;5:0&#62;
            </comment>
        </bits>
    </reg>          
    <reg name="REG_5d" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:6" access="rw">
            <comment>reserved &#60;15:6&#62;
            </comment>
        </bits>
        <bits name="Rds_fircut" pos="5:3" access="rw">
            <comment>Rds_fircut &#60;5:3&#62;
           </comment>
        </bits>
        <bits name="rds_fircut2" pos="2:0" access="rw">
            <comment>rds_fircut2 &#60;2:0&#62;
            </comment>
        </bits>
    </reg>          
    <reg name="REG_5e" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:0" access="rw">
            <comment>reserved &#60;15:6&#62;
            </comment>
        </bits>
    </reg>          
    <reg name="REG_5f" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:0" access="rw">
            <comment>reserved &#60;15:6&#62;
            </comment>
        </bits>
    </reg>          
    <reg name="REG_60" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="mt" pos="15" access="rw">
            <comment>mt &#60;15&#62;
            </comment>
        </bits>
        <bits name="rsvd_60_14" pos="14" access="rw">
            <comment>rsvd_60_14 &#60;14&#62;
            </comment>
        </bits>
        <bits name="pll_w" pos="13:0" access="rw">
            <comment>pll_w &#60;13:0&#62;
            </comment>
        </bits>
    </reg>      
    <reg name="REG_55" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="rsvd" pos="15:13" access="rw">
            <comment>rds_rolloff Rds lpf bw setting &#60;15:13&#62;
            </comment>
        </bits>
        <bits name="hlsi" pos="12" access="rw">
            <comment>hlsi &#60;12&#62;
            </comment>
        </bits>
        <bits name="ms" pos="11" access="rw">
            <comment>ms &#60;11&#62;
            </comment>
        </bits>
        <bits name="rsvd_61_10" pos="10" access="rw">
            <comment>rsvd_61_10 &#60;10&#62;
            </comment>
        </bits>
        <bits name="rsvd_61_9" pos="9" access="rw">
            <comment>rsvd_61_9 &#60;9&#62;
            </comment>
        </bits>
        <bits name="swp1" pos="8" access="rw">
            <comment>swp1 &#60;8&#62;
            </comment>
        </bits>
        <bits name="swp2" pos="7" access="rw">
            <comment>swp2 &#60;7&#62;
            </comment>
        </bits>
        <bits name="stby" pos="6" access="rw">
            <comment>stby &#60;6&#62;
            </comment>
        </bits>
        <bits name="rsvd_61_5" pos="5" access="rw">
            <comment>rsvd_61_5 &#60;5&#62;
            </comment>
        </bits>
        <bits name="rsvd_61_4" pos="4" access="rw">
            <comment>rsvd_61_4 &#60;4&#62;
            </comment>
        </bits>
        <bits name="smute" pos="3" access="rw">
            <comment>smute &#60;3&#62;
            </comment>
        </bits>
        <bits name="rsvd_61_2" pos="2" access="rw">
            <comment>rsvd_61_2 &#60;2&#62;
            </comment>
        </bits>
        <bits name="rsvd_61_1" pos="1" access="rw">
            <comment>rsvd_61_1 &#60;1&#62;
            </comment>
        </bits>
        <bits name="si" pos="0" access="rw">
            <comment>si &#60;0&#62;
            </comment>
        </bits>
   </reg>       
    <reg name="REG_62" protect="rw">
        <bits name="write_req" pos="31" access="rw">
       </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="rsvd" pos="15" access="rw">
            <comment>rsvd &#60;15&#62;
            </comment>
        </bits>
        <bits name="dtc" pos="14" access="rw">
            <comment>dtc &#60;14&#62;
            </comment>
        </bits>
        <bits name="rsvd" pos="13:0" access="rw">
            <comment>rsvd &#60;13:0&#62;
            </comment>
        </bits>
    </reg>          
</module>
</archive>



<archive relative = "gouda.xml">

<include file='globals.xml'/>

<module name="gouda" category="System">
  <var name="GD_MAX_OUT_WIDTH" value="640" />
      <comment>Maximum output width in pixels</comment>
  <var name="GD_NB_BITS_LCDPOS" value="11" />
      <comment>Number of bits coding position in virtual screen</comment>
  <var name="GD_FP_FRAC_SIZE" value="8" />
      <comment>Number of bits of fractional part of internal fixed point values</comment>
  <var name="GD_FIXEDPOINT_SIZE" value="3+GD_FP_FRAC_SIZE" />
      <comment>Number of bits of internal fixed point values</comment>
  <var name="GD_NB_BITS_STRIDE" value="13" />
      <comment>Number of bits for stride storage</comment>

  <var name="GD_MAX_SLCD_READ_LEN" value="4" />
  <var name="GD_MAX_SLCD_CLK_DIVIDER" value="255" />

  
  <reg protect="rw" name="gd_command">
    <bits access="rw" name="start" pos="0" rst="0x0">
      <comment>Starts the image transfer. Autoreset</comment>
    </bits>
  </reg>

  <reg protect="r" name="gd_status">
    <bits access="r" name="ia_busy" pos="0" rst="0x0">
      <comment>High while image accelerator is busy</comment>
    </bits>
    <bits access="r" name="lcd_busy" pos="4" rst="0x0">
      <comment>High while LCD controller is busy</comment>
    </bits>
  </reg>

  <reg protect="rc" name="gd_eof_irq">
    <bits access="rc" name="eof_cause" pos="0" rst="0x0">
        <comment>High when End Of Frame IRQ has been generated.
            <br />To clear it, write 1 in this bit or in eof_status.
        </comment>
    </bits>
    <bits access="rc" name="eof_status" pos="16" rst="0x0">
      <comment>Unmasked version of eof_cause.
            <br />To clear it, write 1 in this bit or in eof_status.
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_eof_irq_mask">
    <bits access="rw" name="eof_mask" pos="0" rst="0x0">
        <comment>EOF interrupt generation mask:
            <br />0: EOF IRQ disabled
            <br />1: EOF IRQ enabled
        </comment>
    </bits>
  </reg>

  
  <reg protect="rw" name="gd_roi_tl_ppos">
    <bits access="rw" name="x0" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>LCD Region Of Interest Top-Left pixel x-axis </comment>
    </bits>
    <bits access="rw" name="y0" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>LCD Region Of Interest Top-Left pixel y-axis </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_roi_br_ppos">
    <bits access="rw" name="x1" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>LCD Region Of Interest Bottom-Right pixel x-axis </comment>
    </bits>
    <bits access="rw" name="y1" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>LCD Region Of Interest Bottom-Right pixel y-axis </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_roi_bg_color">
    <bits access="rw" name="b" pos="4:0" rst="0x0">
        <comment>Blue component of the ROI background color</comment>
    </bits>
    <bits access="rw" name="g" pos="10:5" rst="0x0">
        <comment>Green component of the ROI background color</comment>
    </bits>
    <bits access="rw" name="r" pos="15:11" rst="0x0">
        <comment>Red component of the ROI background color</comment>
    </bits>
  </reg>

  
  <reg protect="rw" name="gd_vl_input_fmt">
    <bits access="rw" name="format" pos="1:0" rst="0x0">
        <comment>Input image format
            <br />00b: RGB565 pixel packed
            <br />01b: YUV4:2:2 pixel packed (UYVY)
            <br />10b: YUV4:2:2 pixel packed (YUYV)
            <br />11b: YUV4:2:0 planar (IYUV)
        </comment>
    </bits>
    <bits access="rw" name="stride" pos="GD_NB_BITS_STRIDE+1:2" rst="0x0">
        <comment>Image stride in bytes (of Y component for planar formats).
            <br />This is the length from the beginning of a line to the beginning of the next line (can be different from image width * pixel size).
        </comment>
    </bits>
    <bits access="rw" name="active" pos="31" rst="0x0">
        <comment>Defines Layer's activity:
            <br />0: Layer disabled
            <br />1: Layer active
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_tl_ppos">
    <bits access="rw" name="x0" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>Video Layer (layer 0) Top-Left pixel x-axis position</comment>
    </bits>
    <bits access="rw" name="y0" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>Video Layer (layer 0) Top-Left pixel y-axis position</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_br_ppos">
    <bits access="rw" name="x1" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>Video Layer (layer 0) Bottom-Right pixel x-axis position</comment>
    </bits>
    <bits access="rw" name="y1" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>Video Layer (layer 0) Bottom-Right pixel y-axis position</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_extents">
    <bits access="rw" name="max_line" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>Number of lines of source image (idem gd_vl_br_ppos.y1 when
                 vertical scaling factor is one).
        </comment>
    </bits>
    <bits access="rw" name="max_col" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>Number of columns of source image (idem gd_vl_br_ppos.x1 when
                 vertical scaling factor is one).
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_blend_opt">
    <bits access="rw" name="chroma key b" pos="4:0" rst="0x0">
        <comment>Blue component of the Chroma Key</comment>
        <options><mask/></options>
    </bits>
    <bits access="rw" name="chroma key g" pos="10:5" rst="0x0">
        <comment>Green component of the Chroma Key</comment>
        <options><mask/></options>
    </bits>
    <bits access="rw" name="chroma key r" pos="15:11" rst="0x0">
        <comment>Red component of the Chroma Key</comment>
        <options><mask/></options>
    </bits>
    <bitgroup name="chroma key color">
        <entry ref="chroma key b"/>
        <entry ref="chroma key g"/>
        <entry ref="chroma key r"/>
    </bitgroup>
    <bits access="rw" name="chroma key enable" pos="16" rst="0x0">
        <comment>Enables the Chroma Keying</comment>
        <options><mask/></options>
    </bits>
    <bits access="rw" name="chroma key mask" pos="19:17" rst="0x0">
        <comment>Allows a range of color for the Chroma Keying:
            <br />000b: exact color match
            <br />001b: disregard 1 LSBit of each color component for matching
            <br />011b: disregard 2 LSBit of each color component for matching
            <br />111b: disregard 3 LSBit of each color component for matching
        </comment>
        <options><mask/></options>
    </bits>
    <bits access="rw" name="alpha" pos="27:20" rst="0x0">
        <comment>Layer Alpha blending coefficient</comment>
        <options><mask/></options>
    </bits>
    <bits access="rw" name="rotation" pos="29:28" rst="0x0">
        <comment>Layer rotation selection
            <br />00b: No rotation
            <br />01b: 90  degrees rotation (clockwise)
            <br />10b: reserved
            <br />11b: reserved
        </comment>
        <options><mask/></options>
    </bits>
    <bits access="rw" name="depth" pos="31:30" rst="0x0">
        <comment>Layer depth
            <br />00b: Video layer behind all Overlay layers
            <br />01b: Video layer between Overlay layers 1 and 0
            <br />10b: Video layer between Overlay layers 2 and 1
            <br />11b: Video layer on top of all Overlay layers
        </comment>
        <options><mask/></options>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_y_src">
    <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
        <comment>Dword-aligned address of the Y component (or RGB) of the source image</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_u_src">
    <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
        <comment>Dword-aligned address of the U component of the source image</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_v_src">
    <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
        <comment>Dword-aligned address of the V component of the source image</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_resc_ratio">
    <bits access="rw" name="xPitch" pos="GD_FIXEDPOINT_SIZE-1:0" rst="0x0">
        <comment>Video layer rescaling ratio upon x-axis. This is a 2.8 fixed point number representing the input/output width ratio.</comment>
    </bits>
    <bits access="rw" name="yPitch" pos="GD_FIXEDPOINT_SIZE+15:16" rst="0x0">
        <comment>Video layer rescaling ratio upon y-axis. This is a 2.8 fixed point number representing the input/output height ratio.</comment>
    </bits>
    <bits access="w" name="pre_fetch_en" pos="29" rst="0x0">
        <comment>Video layer rescaling ratio upon y-axis. This is a 2.8 fixed point number representing the input/output height ratio.</comment>
    </bits>
    <bits access="rw" name="iy_dctenable" pos="30" rst="0x0">
        <comment>Video layer rescaling ratio upon y-axis. This is a 2.8 fixed point number representing the input/output height ratio.</comment>
    </bits>
    <bits access="rw" name="ypitch_scale_enable" pos="31" rst="0x0">
        <comment>Video layer rescaling ratio upon y-axis. This is a 2.8 fixed point number representing the input/output height ratio.</comment>
    </bits>
  </reg>

  
  <struct count="3" name="Overlay_Layer">
    <comment>
        The Overlay layers have a fixed depth relative to their index. Overlay layer 0 is the first to be drawn (thus the deepest), overlay layer 2 is the last to be drawn.
    </comment>
  <reg protect="rw" name="gd_ol_input_fmt">
    <bits access="rw" name="format" pos="1:0" rst="0x0">
        <comment>Input image format
            <br />0: RGB565 pixel packed
            <br />1: ARGB8888 pixel packed
            <br />others: reserved
        </comment>
    </bits>
    <bits access="rw" name="stride" pos="GD_NB_BITS_STRIDE+1:2" rst="0x0">
        <comment>Image stride in 16-bits word.
            <br />This is the length from the beginning of a line to the beginning of the next line (can be different from image width * pixel size).
        </comment>
    </bits>
    <bits access="rw" name="prefetch" pos="18" rst="0x1">
        <comment>Image stride in 16-bits word.
            <br />This is the length from the beginning of a line to the beginning of the next line (can be different from image width * pixel size).
        </comment>
    </bits>
      
    <bits access="rw" name="active" pos="31" rst="0x0">
        <comment>Defines Layer's activity:
            <br />0: Layer disabled
            <br />1: Layer active
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_ol_tl_ppos">
    <bits access="rw" name="x0" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>Overlay Layer (layer X+1) Top-Left pixel x-axis position</comment>
    </bits>
    <bits access="rw" name="y0" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>Overlay Layer (layer X+1) Top-Left pixel y-axis position</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_ol_br_ppos">
    <bits access="rw" name="x1" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>Overlay Layer (layer X+1) Bottom-Right pixel x-axis position</comment>
    </bits>
    <bits access="rw" name="y1" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>Overlay Layer (layer X+1) Bottom-Right pixel y-axis position</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_ol_blend_opt">
    <bits access="rw" name="chroma key b" pos="4:0" rst="0x0">
        <comment>Blue component of the Chroma Key</comment>
    </bits>
    <bits access="rw" name="chroma key g" pos="10:5" rst="0x0">
        <comment>Green component of the Chroma Key</comment>
    </bits>
    <bits access="rw" name="chroma key r" pos="15:11" rst="0x0">
        <comment>Red component of the Chroma Key</comment>
    </bits>
    <bitgroup name="chroma key color">
        <entry ref="chroma key b"/>
        <entry ref="chroma key g"/>
        <entry ref="chroma key r"/>
    </bitgroup>
    <bits access="rw" name="chroma key enable" pos="16" rst="0x0">
        <comment>Enables the Chroma Keying</comment>
    </bits>
    <bits access="rw" name="chroma key mask" pos="19:17" rst="0x0">
        <comment>Allows a range of color for the Chroma Keying:
            <br />000b: exact color match
            <br />001b: disregard 1 LSBit of each color component for matching
            <br />011b: disregard 2 LSBit of each color component for matching
            <br />111b: disregard 3 LSBit of each color component for matching
        </comment>
    </bits>
    <bits access="rw" name="alpha" pos="27:20" rst="0x0">
        <comment>Layer Alpha blending coefficient</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_ol_rgb_src">
    <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
        <comment>Dword-aligned address of the source image</comment>
    </bits>
  </reg>
  </struct>

  
  <reg protect="rw" name="gd_lcd_ctrl">
    <bits access="rw" name="Destination" pos="1:0" rst="0x0">
        <comment>Destination Selection
        </comment>
        <options>
            <option name="LCD CS 0" value ="0"></option>
            <option name="LCD CS 1" value ="1"></option>
            <option name="Memory LCD type" value ="2"></option>
            <option name="Memory RAM" value ="3"></option>
        </options>
    </bits>
    <bits access="rw" name="Output Format" pos="6:4" rst="0x0">
       <comment>Output format
            <br />000b:  8-bit - RGB3:3:2 - 1cycle/1pixel - RRRGGGBB
            <br />001b:  8-bit - RGB4:4:4 - 3cycle/2pixel - RRRRGGGG/BBBBRRRR/GGGGBBBB
            <br />010b:  8-bit - RGB5:6:5 - 2cycle/1pixel - RRRRRGGG/GGGBBBBB
            <br />011b:  reserved
            <br />100b: 16-bit - RGB3:3:2 - 1cycle/2pixel - RRRGGGBBRRRGGGBB
            <br />101b: 16-bit - RGB4:4:4 - 1cycle/1pixel - XXXXRRRRGGGGBBBB
            <br />110b: 16-bit - RGB5:6:5 - 1cycle/1pixel - RRRRRGGGGGGBBBBB
            <br />111b:  reserved
            <br />
            <br /> The MSB select also the AHB access size (8-bit or 16-bit) when Memory destination is selected.
            <br /> Must set to RGB565 when RAM type destination selected
        </comment>
        <options>
            <option name="8-bit;RGB332" value ="0"></option>
            <option name="8-bit;RGB444" value ="1"></option>
            <option name="8-bit;RGB565" value ="2"></option>
            <option name="16-bit;RGB332" value ="4"></option>
            <option name="16-bit;RGB444" value ="5"></option>
            <option name="16-bit;RGB565" value ="6"></option>
        </options>
      </bits>
    <bits access="rw" name="high byte" pos="7" rst="0x0">
    </bits>
    <bits access="rw" name="CS0 Polarity" pos="8" rst="0x0">
       <comment>Change Polarity of CS0 signal
            <br /> 0: no change
            <br /> 1: Inverted
        </comment>
    </bits>
    <bits access="rw" name="CS1 Polarity" pos="9" rst="0x0">
       <comment>Change Polarity of CS1 signal
            <br /> 0: no change
            <br /> 1: Inverted
        </comment>
    </bits>
    <bits access="rw" name="RS Polarity" pos="10" rst="0x0">
       <comment>Change Polarity of RS signal
            <br /> 0: no change
            <br /> 1: Inverted
        </comment>
    </bits>
    <bits access="rw" name="WR Polarity" pos="11" rst="0x0">
       <comment>Change Polarity of WR signal
            <br /> 0: no change
            <br /> 1: Inverted
        </comment>
    </bits>
    <bits access="rw" name="RD Polarity" pos="12" rst="0x0">
       <comment>Change Polarity of RD signal
            <br /> 0: no change
            <br /> 1: Inverted
        </comment>
    </bits>

    <bits access="rw" name="Nb Command" pos="21:16" rst="0x0">
       <comment>Number of command to be send to the LCD command (up to 31)
        </comment>
    </bits>
    <bits access="w" name="Start command" pos="24" rst="0x0">
       <comment>Start command transfer only. Autoreset
       </comment>
    </bits>
    <bits access="rw" name="LCD Resetb" pos="25" rst="0x1">
       <comment>LCD reset signal. Low active
        </comment>
    </bits>
  </reg>
  <reg protect="rw" name="gd_lcd_timing">
        <comment>All value are in cycle number of system clock
        </comment>
    <bits access="rw" name="TAS" pos="2:0" rst="0x0">
        <comment>Address setup time (RS to WR, RS to RD)
        </comment>
    </bits>
    <bits access="rw" name="TAH" pos="6:4" rst="0x0">
        <comment>Adress hold time
        </comment>
    </bits>
    <bits access="rw" name="PWL" pos="13:8" rst="0x0">
        <comment>Pulse Width Low level, between 2 and 63.
        </comment>
    </bits>
    <bits access="rw" name="PWH" pos="21:16" rst="0x0">
        <comment>Pulse Width High level, between 2 and 63 (must be > (TAH+TAS) ).
        </comment>
    </bits>
  </reg>
  <reg protect="rw" name="gd_lcd_mem_address">
    <bits access="rw" name="addr_dst" pos="NB_BITS_ADDR-1:2" rst="all0">
        <comment>Address destination pointer when memory destination is selected.
                 <br />The addr_dst[1] which correspond to the M_A[0] on the memory interface is used to select between command/data.
        </comment>
    </bits>
  </reg>
  <reg protect="rw" name="gd_lcd_stride_offset">
    <bits access="rw" name="stride_offset" pos="9:0" rst="all0">
        <comment>Address offset (in Bytes) skipped at the end of each line when memory destination is selected.
                 <br />This 2D feature allows for in-memory image compositing. 
        </comment>
    </bits>
  </reg>
  <reg protect="rw" name="gd_lcd_single_access">
    <bits access="rw" name="lcd_data" pos="15:0" rst="all0">
        <comment>data to write or data readen (the readen data is ready when the lcd is not busy)
        </comment>
    </bits>
    <bits access="rw" name="type" pos="16" rst="0x0">
        <comment>Acesss type selection
            <br />0: Command
            <br />1: Data
        </comment>
    </bits>
    <bits access="w" name="start_write" pos="17" rst="0x0">
        <comment>Start a single write access. Autoreset
       </comment>
    </bits>
    <bits access="w" name="start_read" pos="18" rst="0x0">
        <comment>Start a single read access (only when LCD output selected). Autoreset.
       </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_spilcd_config">
    <bits access="rw" name="spi_lcd_select" pos="0" rst="0"> </bits>
    <bits access="rw" name="spi_device_id" pos="6:1" rst="all0">
        <options><mask/><shift/></options>
    </bits>
    <bits access="rw" name="spi_clk_divider" pos="14:7" rst="0a"> 
        <options><mask/><shift/></options>
    </bits>
    <bits access="rw" name="spi_dummy_cycle" pos="17:15" rst="all0"> 
        <options><mask/><shift/></options>
    </bits>
    <bits access="rw" name="spi_line" pos="19:18" rst="all0"> 
          <comment>0:4 line mode 
                   1:3 line mode
                   2:command mode
                   3:3 line 2 lane mode tx
          </comment>
          <options>
              <mask/>
              <option name="4" value ="0"></option>
              <option name="3" value ="1"></option>
              <option name="4_Start_Byte" value ="2"></option>
              <option name="3_Two_Lane" value ="3"></option>
          </options>
    </bits>
    <bits access="rw" name="spi_rx_byte" pos="22:20" rst="all0">
          <options><mask/><shift/></options>
    </bits>
    <bits access="rw" name="spi_rw" pos="23" rst="0"> 
         <options>
              <option name="Write" value ="0"></option>
              <option name="Read" value ="1"></option>
          </options>
    </bits>
  </reg>
  <reg protect="r" name="gd_spilcd_rd">
    <bits access="r" name="spi_lcd_rd" pos="31:0" rst="all0">
        <comment>
        </comment>
    </bits>
  </reg>
  <reg name="gd_vl_fix_ratio" protect="rw">
      <bits name="reg_vl_only_sel" pos="19" access="rw" rst="0x0">
          <comment>
          </comment>
      </bits>
        <bits name="mirror" pos="18" access="rw" rst="0x0">
            <comment>Mirror enable.
            </comment>
        </bits>
        <bits name="l_yfixen" pos="17" access="rw" rst="0x0">
            <comment>.
            </comment>
        </bits>
        <bits name="l_xfixen" pos="16" access="rw" rst="0x0">
            <comment>.
            </comment>
        </bits>
        <bits name="l_yratio" pos="15:8" access="rw" rst="0x0">
            <comment>.
            </comment>
        </bits>
        <bits name="l_xratio" pos="7:0" access="rw" rst="0x0">
            <comment>.
            </comment>
        </bits>
    </reg>
   
   
    <reg name="TECON" protect="rw">
        <bits name="te_count2" pos="27:16" access="rw" rst="0x0">
            <comment>Count value to detect vsync pulse
            </comment>
        </bits>
        <bits name="te_mode" pos="2" access="rw" rst="0x0">
            <comment>0:vsync te only 1:vsync and hsync te
            </comment>
        </bits>
        <bits name="te_edge_sel" pos="1" access="rw" rst="0x0">
            <comment>Pol select
            </comment>
        </bits>
        <bits name="te_en" pos="0" access="rw" rst="0x0">
            <comment>Te enable.
            </comment>
        </bits>
    </reg>
    <reg name="TECON2" protect="rw">
        <bits name="te_count1" pos="28:0" access="rw" rst="0x0">
            <comment>Te counter value
            </comment>
        </bits>
    </reg>

<hole size="(256-81-1)*32"/>

</module>




<module name="gouda_sram" category="System">
  <var name="GD_NB_WORKBUF_WORDS"  value="5856" />
  <var name="GD_NB_LCD_CMD_WORDS"  value="64" />
  <var name="GD_SRAM_SIZE"  value="(GD_NB_WORKBUF_WORDS+GD_NB_LCD_CMD_WORDS)*2" />
  <var name="GD_SRAM_ADDR_WIDTH"  value="13" />

    <memory name="sram_array" size="GD_SRAM_SIZE">
        <comment>Gouda internal Sram space
        </comment>
    </memory>
</module>

</archive>

<archive relative = "gpio.xml">

  
  <include file="gallite_generic_config.xml"/>

  
  <var name="IDX_GPIO_DCON" value="0" />
  <var name="IDX_GPO_CHG" value="0" />


<module name="gpio" category="Periph">

  
  
  <reg protect="rw" name="gpio_oen_val_l">
    <bits access="rw" name="oen_val_l" pos="31:0" rst="0xffffffff" display="hex">
      <options>
        <option name="INPUT" value="1" />

        <option name="OUTPUT" value="0" />

        <default />
      </options>

      <comment>Set the direction of the GPIO n.<br />0 = output<br />1 =
      input</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_out_l">
    <bits access="rc" name="oen_set_out_l" pos="31:0" rst="0xffffffff">
      <comment>'Write '1' sets the corresponding GPIO pin as output.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_in_l">
    <bits access="rs" name="oen_set_in_l" pos="31:0" rst="0xffffffff" display="hex">
      <comment>'Write '1' sets the corresponding GPIO pin as input.</comment>
    </bits>
  </reg>

  

  <reg protect="rw" name="gpio_val_l">
    <bits access="rw" name="gpio_val_l" pos="31:0" rst="0xffffffff" display="hex">
      <comment>When write, update the output value. When read, get the input
      value. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_set_l">
    <bits access="rs" name="gpio_set_l" pos="31:0" rst="0xffffffff">
      <comment>Write '1' will set GPIO output value. When read, get the GPIO
      output value.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_clr_l">
    <bits access="rc" name="gpio_clr_l" pos="31:0" rst="0xffffffff">
      <comment>'Write '1' clears corresponding GPIO output value. When read, get the GPIO
      output value. </comment>
    </bits>
  </reg>


   <reg protect="rw" name="gpint_r_set_l">
     <bits access="rs" name="gpint_r_set_l" pos="31:0" rst="0">
       <comment>Write '1' will set GPIO interrupt mask for rising edge and
       level high. When read, get the GPIO interrupt mask for rising edge and
       level high. </comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_r_set_h">
     <bits access="rs" name="gpint_r_set_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will set GPIO interrupt mask for rising edge and
       level high. When read, get the GPIO interrupt mask for rising edge and
       level high. </comment>
     </bits>
   </reg>

  <reg protect="w" name="int_clr_l">
    <bits access="c" name="gpint_clr_l" pos="31:0" rst="0">
      <comment>'Write '1' will clear GPIO interrupt.</comment>
    </bits>
  </reg>

  <reg protect="r" name="int_status_l">
    <bits access="r" name="gpint_status_l" pos="31:0" rst="0">
      <comment>Each bit represents if there is a GPIO interrupt
      pending.</comment>
      <options>
        <default/>
        <mask/>
        <shift/>
      </options>
    </bits>
  </reg>

  <reg protect="rw" name="chg_ctrl">
    <bits access="rw" name="out_time" pos="3:0" rst="0xf" display="hex">
        <comment>time for which GPIO0 is set to output mode, after a start read
            DCON command is issued.<br />The output time = (OUT_TIME+1)*30.5us.
        </comment>
    </bits>

    <bits access="rw" name="wait_time" pos="9:4" rst="0x3f" display="hex">
        <comment>time for which GPIO0 should wait before reading DC_ON, after
            a start read DCON command is issued.<br />The wait time = (WAIT_TIME+1)*30.5us.
            <br/>NOTE: wait_time must be strictly greater than out_time;
        </comment>
    </bits>

    <bits access="rw" name="int_mode" pos="17:16" rst="0x3" display="hex">
        <comment>interruption mode of GPIO0 in mode DC_ON detection.<br />
        </comment>
            <options>
                <option name="L2H" value="0">
                    <comment>
                        "00" = send IRQ if last read DCON is '0' and now is '1'. 
                    </comment>
                </option>
                <option name="H2L" value="1">
                    <comment>
                        "01" = send IRQ if last read DCON is '1' and now is '0'.
                    </comment>
                </option>
                <option name="RR" value="3">
                    <comment>
                        "11" = send IRQ every time read is ready.
                    </comment>
                </option>
            </options>
    </bits>
  </reg>

  <reg protect="w" name="chg_cmd">
    <bits access="s" name="dcon_mode_set" pos="0" rst="0">
      <comment>Write '1' to set GPIO0 to charger DCON detect mode.</comment>
    </bits>
      
    <bits access="s" name="chg_mode_set" pos="4" rst="0">
      <comment>Write '1' to set GPO0 to charger watchdog mode.</comment>
    </bits>

    <bits access="c" name="dcon_mode_clr" pos="8" rst="0">
      <comment>Write '1' to clear charger DCON detect mode of GPIO0.</comment>
    </bits>

    <bits access="c" name="chg_mode_clr" pos="12" rst="0">
      <comment>Write '1' to clear the charger watchdog mode of GPO0.</comment>
    </bits>

    <bits access="s" name="chg_down" pos="24" rst="0">
      <comment>Write '1' to generate a pulse of '0' on GPO0 for 16 CLK_OSC cycles.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpo_set">
    <bits access="rs" name="gpo_set" pos="NB_GPO-1:0" rst="0x2aa" display="hex">
      <comment>'Write '1' will set GPO output value. When read, get the GPO
      output value.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpo_clr">
    <bits access="rc" name="gpo_clr" pos="NB_GPO-1:0" rst="0x2aa" display="hex">
      <comment>'Write '1' will clear GPO output value. When read, get the GPO
      output value.</comment>
    </bits>
  </reg>

  
  <reg protect="rw" name="gpio_oen_val_h">
    <bits access="rw" name="oen_val_h" pos="NB_GPIO-33:0" rst="0xffffffff" display="hex">
      <options>
        <option name="INPUT" value="1" />

        <option name="OUTPUT" value="0" />

        <default />
      </options>

      <comment>Set the direction of the GPIO n.<br />0 = output<br />1 =
      input</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_out_h">
    <bits access="rc" name="oen_set_out_h" pos="NB_GPIO-33:0" rst="0xffffffff">
      <comment>'Write '1' sets the corresponding GPIO pin as output.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_in_h">
    <bits access="rs" name="oen_set_in_h" pos="NB_GPIO-33:0" rst="0xffffffff" display="hex">
      <comment>'Write '1' sets the corresponding GPIO pin as input.</comment>
    </bits>
  </reg>

  

  <reg protect="rw" name="gpio_val_h">
    <bits access="rw" name="gpio_val_h" pos="NB_GPIO-33:0" rst="0xffffffff" display="hex">
      <comment>When write, update the output value. When read, get the input
      value. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_set_h">
    <bits access="rs" name="gpio_set_h" pos="NB_GPIO-33:0" rst="0xffffffff">
      <comment>Write '1' will set GPIO output value. When read, get the GPIO
      output value.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_clr_h">
    <bits access="rc" name="gpio_clr_h" pos="NB_GPIO-33:0" rst="0xffffffff">
      <comment>'Write '1' clears corresponding GPIO output value. When read, get the GPIO
      output value. </comment>
    </bits>
  </reg>

  
  
   <reg protect="rw" name="gpint_r_clr_l">
     <bits access="rs" name="gpint_r_clr_l" pos="31:0" rst="0">
       <comment>'Write '1' will clear GPIO interrupt mask for rising edge and
       level high.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_r_clr_h">
     <bits access="rs" name="gpint_r_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>'Write '1' will clear GPIO interrupt mask for rising edge and
       level high.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_f_set_l">
     <bits access="rs" name="gpint_f_set_l" pos="31:0" rst="0">
       <comment>Write '1' will set GPIO interrupt mask for rising edge and
       level high. When read, get the GPIO interrupt mask for rising edge and
       level high. </comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_f_set_h">
     <bits access="rs" name="gpint_f_set_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will set GPIO interrupt mask for falling edge and
       level low. When read, get the GPIO interrupt mask for falling edge and
       level low.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_f_clr_l">
     <bits access="rs" name="gpint_f_clr_l" pos="31:0" rst="0">
       <comment>Write '1' will clear GPIO interrupt mask for falling edge and
       level low.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_f_clr_h">
     <bits access="rs" name="gpint_f_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will clear GPIO interrupt mask for falling edge and
       level low.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_dbn_en_set_l">
     <bits access="rs" name="dbn_en_set_l" pos="31:0" rst="0">
       <comment>Write '1' will enable debounce mechanism.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_dbn_en_set_h">
     <bits access="rs" name="dbn_en_set_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will enable debounce mechanism.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_dbn_en_clr_l">
     <bits access="rs" name="dbn_en_clr_l" pos="31:0" rst="0">
       <comment>Write '1' will disable debounce mechanism.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_dbn_en_clr_h">
     <bits access="rs" name="dbn_en_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will disable debounce mechanism.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_mode_set_l">
     <bits access="rs" name="gpint_mode_set_l" pos="31:0" rst="0">
       <comment>Write '1' will set interruption mode to level.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_mode_set_h">
     <bits access="rs" name="gpint_mode_set_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will set interruption mode to level.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_mode_clr_l">
     <bits access="rs" name="gpint_mode_clr_l" pos="31:0" rst="0">
       <comment>Write '1' will set interruption mode to edge
       triggered.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_mode_clr_h">
     <bits access="rs" name="gpint_mode_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will set interruption mode to edge
       triggered.</comment>
     </bits>
   </reg>

  <reg protect="r" name="int_status_h">
    <bits access="r" name="gpint_status_h" pos="NB_GPIO_INT-33:0" rst="0">
      <comment>Each bit represents if there is a GPIO interrupt
      pending.</comment>
      <options>
        <default/>
        <mask/>
        <shift/>
      </options>
    </bits>
  </reg>

  <reg protect="w" name="int_clr_h">
    <bits access="c" name="gpint_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
      <comment>'Write '1' will clear GPIO interrupt.</comment>
    </bits>
  </reg>


</module>


</archive>

<archive relative = "i2c_master.xml">

<module name="i2c_master" category="Periph">
    
    <reg protect="rw" name="CTRL">
        
 		<bits access="rw" name="EN" pos="0" rst="0">
			<comment> I2C master enable, high active. 
			</comment>
		</bits>
        
		<bits access="rw" name="IRQ_MASK" pos="8" rst="0">
			<comment> I2C master interrupt enable, high active. 
			</comment>
		</bits>
        
		<bits access="rw" name="Clock_Prescale" pos="31:16" rst="0xFFFF">
            <comment> This register is used to prescale the SCL clock line. Due to the structure of I2C interface, this module uses a 5*SCL clock frequency. Clock_Prescale must be programmed to this 5*SCL clock frequency (minus 1). Change the value of Clock_Prescale only when bit EN is cleared. <br /> <br /> Example:<br /> PCLK_MOD is 52 MHz, desired SCL is 100 KHz. <br /> Prescale = 52MHz / (5 * 100KHz) -1 = 103.
			</comment>
            <options><mask/></options>
		</bits>
	</reg>

    <reg protect="r" name="STATUS">
        
        <bits access="r" name="IRQ_Cause" pos="0" rst="0">
			<comment> IRQ Cause bit. This bit is set when one byte transfer has been completed or arbitration is lost, this bit is generated by bit IRQ_Status AND bit IRQ_MASK.
			</comment>
        </bits>
        
		<bits access="r" name="IRQ_Status" pos="4" rst="0">
			<comment> IRQ status bit. 
			</comment>
        </bits>
        
		<bits access="r" name="TIP" pos="8" rst="0">
			<comment> TIP, Transfer in progress.
				'1' when transferring data. '0' when transfer complete.
			</comment>
		</bits>
        
		<bits access="r" name="AL" pos="12" rst="0">
			<comment> AL,Arbitration lost.
				This bit is set when the I2C master lost arbitration.
			</comment>
		</bits>
        
		<bits access="r" name="Busy" pos="16" rst="0">
			<comment> Busy,I2C bus busy.
				'1' after START signal detected.
				'0' after STOP signal detected.
			</comment>
		</bits>
        
		<bits access="r" name="RxACK" pos="20" rst="0">
			<comment> RxACK, Received acknowledge from slave.
				'1'= "No ACK" received.
				'0'= ACK received.
			</comment>
		</bits>
    </reg>
    
	<reg protect="rw" name="TXRX_BUFFER">
        
		<bits access="w" name="TX_DATA" pos="7:0" rst="-">
			<comment> Byte to transmit via I2C. <br /> for Bit 0, In case of a data transfer this bit represents the data's LSB. In case of a slave address transfer this bit represents the RW bit. <br /> '1' = reading from slave. <br /> '0' = writing to slave.   
			</comment>
		</bits>

 		<bits access="r" name="RX_DATA" pos="7:0" rst="-">
			<comment> Last byte received via I2C. 
			</comment>
		</bits>
        
	</reg>

	<reg protect="w" name="CMD">

		<bits access="w" name="ACK" pos="0" rst="0">
			<comment> ACK,when master works as a receiver,sent ACK(ACK='0') or NACK(ACK='1').
			</comment>
		</bits>

		<bits access="w" name="RD" pos="4" rst="0">
			<comment> RD,read from slave, this bit is auto cleared.
			</comment>
		</bits>

		<bits access="w" name="STO" pos="8" rst="0">
			<comment> STO,generate stop condition, this bit is auto cleared.
			</comment>
		</bits>
        
		<bits access="w" name="WR" pos="12" rst="0">
			<comment> WR,write to slave, this bit is auto cleared.
			</comment>
		</bits>

		<bits access="w" name="STA" pos="16" rst="0">
			<comment> STA,generate (repeated) start condition, this bit is auto cleared.
			</comment>
		</bits>
    </reg>

  	<reg protect="rw" name="IRQ_CLR">  
        
		<bits access="c" name="IRQ_Clr" pos="0" rst="0">
			<comment> When write '1', clears a pending I2C interrupt.
			</comment>
        </bits>
    </reg>
    

</module>
</archive>
<archive relative = "iomux.xml">
<module name="iomux" category="System">
  
 

  <reg name="pad_M_DQ_0_cfg" protect="rw">
     <bits name="pad_M_DQ_0_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_DQ_0 force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_DQ_0_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_DQ_0 force output value for output. </comment>
         </bits>
     <bits name="pad_M_DQ_0_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_DQ_0 pin output value. </comment>
         </bits>
     <bits name="pad_M_DQ_0_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_DQ_0_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_DQ_0 force outoen value. </comment>
         </bits>
     <bits name="pad_M_DQ_0_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_DQ_0 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_DQ_0_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_DQ_0 PUll up</comment>
         </bits>
     <bits name="pad_M_DQ_0_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_DQ_0 PUll down</comment>
         </bits>
     <bits name="pad_M_DQ_0_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_DQ_0 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_DQ_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_0 select</comment>
     <options>
            <option name="fun_M_DQ_0_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_DQ_1_cfg" protect="rw">
     <bits name="pad_M_DQ_1_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_DQ_1 force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_DQ_1_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_DQ_1 force output value for output. </comment>
         </bits>
     <bits name="pad_M_DQ_1_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_DQ_1 pin output value. </comment>
         </bits>
     <bits name="pad_M_DQ_1_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_DQ_1_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_DQ_1 force outoen value. </comment>
         </bits>
     <bits name="pad_M_DQ_1_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_DQ_1 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_DQ_1_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_DQ_1 PUll up</comment>
         </bits>
     <bits name="pad_M_DQ_1_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_DQ_1 PUll down</comment>
         </bits>
     <bits name="pad_M_DQ_1_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_DQ_1 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_DQ_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_1 select</comment>
     <options>
            <option name="fun_M_DQ_1_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_DQ_2_cfg" protect="rw">
     <bits name="pad_M_DQ_2_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_DQ_2 force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_DQ_2_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_DQ_2 force output value for output. </comment>
         </bits>
     <bits name="pad_M_DQ_2_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_DQ_2 pin output value. </comment>
         </bits>
     <bits name="pad_M_DQ_2_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_DQ_2_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_DQ_2 force outoen value. </comment>
         </bits>
     <bits name="pad_M_DQ_2_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_DQ_2 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_DQ_2_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_DQ_2 PUll up</comment>
         </bits>
     <bits name="pad_M_DQ_2_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_DQ_2 PUll down</comment>
         </bits>
     <bits name="pad_M_DQ_2_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_DQ_2 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_DQ_2_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_2 select</comment>
     <options>
            <option name="fun_M_DQ_2_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_DQ_3_cfg" protect="rw">
     <bits name="pad_M_DQ_3_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_DQ_3 force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_DQ_3_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_DQ_3 force output value for output. </comment>
         </bits>
     <bits name="pad_M_DQ_3_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_DQ_3 pin output value. </comment>
         </bits>
     <bits name="pad_M_DQ_3_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_DQ_3_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_DQ_3 force outoen value. </comment>
         </bits>
     <bits name="pad_M_DQ_3_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_DQ_3 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_DQ_3_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_DQ_3 PUll up</comment>
         </bits>
     <bits name="pad_M_DQ_3_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_DQ_3 PUll down</comment>
         </bits>
     <bits name="pad_M_DQ_3_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_DQ_3 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_DQ_3_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_3 select</comment>
     <options>
            <option name="fun_M_DQ_3_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_DQ_4_cfg" protect="rw">
     <bits name="pad_M_DQ_4_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_DQ_4 force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_DQ_4_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_DQ_4 force output value for output. </comment>
         </bits>
     <bits name="pad_M_DQ_4_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_DQ_4 pin output value. </comment>
         </bits>
     <bits name="pad_M_DQ_4_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_DQ_4_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_DQ_4 force outoen value. </comment>
         </bits>
     <bits name="pad_M_DQ_4_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_DQ_4 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_DQ_4_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_DQ_4 PUll up</comment>
         </bits>
     <bits name="pad_M_DQ_4_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_DQ_4 PUll down</comment>
         </bits>
     <bits name="pad_M_DQ_4_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_DQ_4 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_DQ_4_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_4 select</comment>
     <options>
            <option name="fun_M_DQ_4_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_DQ_5_cfg" protect="rw">
     <bits name="pad_M_DQ_5_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_DQ_5 force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_DQ_5_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_DQ_5 force output value for output. </comment>
         </bits>
     <bits name="pad_M_DQ_5_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_DQ_5 pin output value. </comment>
         </bits>
     <bits name="pad_M_DQ_5_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_DQ_5_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_DQ_5 force outoen value. </comment>
         </bits>
     <bits name="pad_M_DQ_5_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_DQ_5 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_DQ_5_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_DQ_5 PUll up</comment>
         </bits>
     <bits name="pad_M_DQ_5_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_DQ_5 PUll down</comment>
         </bits>
     <bits name="pad_M_DQ_5_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_DQ_5 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_DQ_5_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_5 select</comment>
     <options>
            <option name="fun_M_DQ_5_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_DQ_6_cfg" protect="rw">
     <bits name="pad_M_DQ_6_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_DQ_6 force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_DQ_6_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_DQ_6 force output value for output. </comment>
         </bits>
     <bits name="pad_M_DQ_6_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_DQ_6 pin output value. </comment>
         </bits>
     <bits name="pad_M_DQ_6_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_DQ_6_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_DQ_6 force outoen value. </comment>
         </bits>
     <bits name="pad_M_DQ_6_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_DQ_6 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_DQ_6_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_DQ_6 PUll up</comment>
         </bits>
     <bits name="pad_M_DQ_6_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_DQ_6 PUll down</comment>
         </bits>
     <bits name="pad_M_DQ_6_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_DQ_6 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_DQ_6_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_6 select</comment>
     <options>
            <option name="fun_M_DQ_6_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_DQ_7_cfg" protect="rw">
     <bits name="pad_M_DQ_7_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_DQ_7 force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_DQ_7_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_DQ_7 force output value for output. </comment>
         </bits>
     <bits name="pad_M_DQ_7_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_DQ_7 pin output value. </comment>
         </bits>
     <bits name="pad_M_DQ_7_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_DQ_7_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_DQ_7 force outoen value. </comment>
         </bits>
     <bits name="pad_M_DQ_7_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_DQ_7 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_DQ_7_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_DQ_7 PUll up</comment>
         </bits>
     <bits name="pad_M_DQ_7_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_DQ_7 PUll down</comment>
         </bits>
     <bits name="pad_M_DQ_7_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_DQ_7 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_DQ_7_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQ_7 select</comment>
     <options>
            <option name="fun_M_DQ_7_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_CS_cfg" protect="rw">
     <bits name="pad_M_CS_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_CS force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_CS_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_CS force output value for output. </comment>
         </bits>
     <bits name="pad_M_CS_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_CS pin output value. </comment>
         </bits>
     <bits name="pad_M_CS_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_CS_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_CS force outoen value. </comment>
         </bits>
     <bits name="pad_M_CS_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_CS force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_CS_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_CS PUll up</comment>
         </bits>
     <bits name="pad_M_CS_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_CS PUll down</comment>
         </bits>
     <bits name="pad_M_CS_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_CS ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_CS_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_CS select</comment>
     <options>
            <option name="fun_M_CS_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_DM_cfg" protect="rw">
     <bits name="pad_M_DM_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_DM force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_DM_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_DM force output value for output. </comment>
         </bits>
     <bits name="pad_M_DM_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_DM pin output value. </comment>
         </bits>
     <bits name="pad_M_DM_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_DM_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_DM force outoen value. </comment>
         </bits>
     <bits name="pad_M_DM_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_DM force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_DM_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_DM PUll up</comment>
         </bits>
     <bits name="pad_M_DM_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_DM PUll down</comment>
         </bits>
     <bits name="pad_M_DM_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_DM ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_DM_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DM select</comment>
     <options>
            <option name="fun_M_DM_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_CLK_cfg" protect="rw">
     <bits name="pad_M_CLK_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_CLK force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_CLK_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_CLK force output value for output. </comment>
         </bits>
     <bits name="pad_M_CLK_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_CLK pin output value. </comment>
         </bits>
     <bits name="pad_M_CLK_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_CLK_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_CLK force outoen value. </comment>
         </bits>
     <bits name="pad_M_CLK_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_CLK force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_CLK_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_CLK PUll up</comment>
         </bits>
     <bits name="pad_M_CLK_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_CLK PUll down</comment>
         </bits>
     <bits name="pad_M_CLK_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_CLK ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_CLK_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_CLK select</comment>
     <options>
            <option name="fun_M_CLK_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_CLKB_cfg" protect="rw">
     <bits name="pad_M_CLKB_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_CLKB force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_CLKB_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_CLKB force output value for output. </comment>
         </bits>
     <bits name="pad_M_CLKB_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_CLKB pin output value. </comment>
         </bits>
     <bits name="pad_M_CLKB_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_CLKB_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_CLKB force outoen value. </comment>
         </bits>
     <bits name="pad_M_CLKB_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_CLKB force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_CLKB_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_CLKB PUll up</comment>
         </bits>
     <bits name="pad_M_CLKB_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_CLKB PUll down</comment>
         </bits>
     <bits name="pad_M_CLKB_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_CLKB ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_CLKB_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_CLKB select</comment>
     <options>
            <option name="fun_M_CLKB_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_DQS_cfg" protect="rw">
     <bits name="pad_M_DQS_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_DQS force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_DQS_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_DQS force output value for output. </comment>
         </bits>
     <bits name="pad_M_DQS_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_DQS pin output value. </comment>
         </bits>
     <bits name="pad_M_DQS_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_DQS_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_DQS force outoen value. </comment>
         </bits>
     <bits name="pad_M_DQS_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_DQS force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_DQS_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_DQS PUll up</comment>
         </bits>
     <bits name="pad_M_DQS_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_DQS PUll down</comment>
         </bits>
     <bits name="pad_M_DQS_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_DQS ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_DQS_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_DQS select</comment>
     <options>
            <option name="fun_M_DQS_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_SPI_CLK_cfg" protect="rw">
     <bits name="pad_M_SPI_CLK_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_SPI_CLK force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_SPI_CLK_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_SPI_CLK force output value for output. </comment>
         </bits>
     <bits name="pad_M_SPI_CLK_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_SPI_CLK pin output value. </comment>
         </bits>
     <bits name="pad_M_SPI_CLK_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_SPI_CLK_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_SPI_CLK force outoen value. </comment>
         </bits>
     <bits name="pad_M_SPI_CLK_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_SPI_CLK force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_SPI_CLK_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_SPI_CLK PUll up</comment>
         </bits>
     <bits name="pad_M_SPI_CLK_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_SPI_CLK PUll down</comment>
         </bits>
     <bits name="pad_M_SPI_CLK_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_SPI_CLK ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_SPI_CLK_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_SPI_CLK select</comment>
     <options>
            <option name="fun_M_SPI_CLK_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_SPI_CS_cfg" protect="rw">
     <bits name="pad_M_SPI_CS_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_SPI_CS force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_SPI_CS_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_SPI_CS force output value for output. </comment>
         </bits>
     <bits name="pad_M_SPI_CS_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_SPI_CS pin output value. </comment>
         </bits>
     <bits name="pad_M_SPI_CS_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_SPI_CS_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_SPI_CS force outoen value. </comment>
         </bits>
     <bits name="pad_M_SPI_CS_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_SPI_CS force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_SPI_CS_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_SPI_CS PUll up</comment>
         </bits>
     <bits name="pad_M_SPI_CS_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_SPI_CS PUll down</comment>
         </bits>
     <bits name="pad_M_SPI_CS_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_SPI_CS ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_SPI_CS_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_SPI_CS select</comment>
     <options>
            <option name="fun_M_SPI_CS_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_SPI_D_0_cfg" protect="rw">
     <bits name="pad_M_SPI_D_0_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_SPI_D_0 force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_SPI_D_0_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_SPI_D_0 force output value for output. </comment>
         </bits>
     <bits name="pad_M_SPI_D_0_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_SPI_D_0 pin output value. </comment>
         </bits>
     <bits name="pad_M_SPI_D_0_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_SPI_D_0_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_SPI_D_0 force outoen value. </comment>
         </bits>
     <bits name="pad_M_SPI_D_0_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_SPI_D_0 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_SPI_D_0_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_SPI_D_0 PUll up</comment>
         </bits>
     <bits name="pad_M_SPI_D_0_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_SPI_D_0 PUll down</comment>
         </bits>
     <bits name="pad_M_SPI_D_0_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_SPI_D_0 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_SPI_D_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_SPI_D_0 select</comment>
     <options>
            <option name="fun_M_SPI_D_0_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_SPI_D_1_cfg" protect="rw">
     <bits name="pad_M_SPI_D_1_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_SPI_D_1 force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_SPI_D_1_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_SPI_D_1 force output value for output. </comment>
         </bits>
     <bits name="pad_M_SPI_D_1_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_SPI_D_1 pin output value. </comment>
         </bits>
     <bits name="pad_M_SPI_D_1_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_SPI_D_1_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_SPI_D_1 force outoen value. </comment>
         </bits>
     <bits name="pad_M_SPI_D_1_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_SPI_D_1 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_SPI_D_1_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_SPI_D_1 PUll up</comment>
         </bits>
     <bits name="pad_M_SPI_D_1_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_SPI_D_1 PUll down</comment>
         </bits>
     <bits name="pad_M_SPI_D_1_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_SPI_D_1 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_SPI_D_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_SPI_D_1 select</comment>
     <options>
            <option name="fun_M_SPI_D_1_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_SPI_D_2_cfg" protect="rw">
     <bits name="pad_M_SPI_D_2_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_SPI_D_2 force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_SPI_D_2_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_SPI_D_2 force output value for output. </comment>
         </bits>
     <bits name="pad_M_SPI_D_2_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_SPI_D_2 pin output value. </comment>
         </bits>
     <bits name="pad_M_SPI_D_2_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_SPI_D_2_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_SPI_D_2 force outoen value. </comment>
         </bits>
     <bits name="pad_M_SPI_D_2_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_SPI_D_2 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_SPI_D_2_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_SPI_D_2 PUll up</comment>
         </bits>
     <bits name="pad_M_SPI_D_2_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_SPI_D_2 PUll down</comment>
         </bits>
     <bits name="pad_M_SPI_D_2_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_SPI_D_2 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_SPI_D_2_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_SPI_D_2 select</comment>
     <options>
            <option name="fun_M_SPI_D_2_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_M_SPI_D_3_cfg" protect="rw">
     <bits name="pad_M_SPI_D_3_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>M_SPI_D_3 force enable for outoen. </comment>
         </bits>
     <bits name="pad_M_SPI_D_3_out_frc" pos="24" access="rw" rst="0"> 
         <comment>M_SPI_D_3 force output value for output. </comment>
         </bits>
     <bits name="pad_M_SPI_D_3_out_reg" pos="20" access="rw" rst="0"> 
         <comment>M_SPI_D_3 pin output value. </comment>
         </bits>
     <bits name="pad_M_SPI_D_3_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_M_SPI_D_3_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>M_SPI_D_3 force outoen value. </comment>
         </bits>
     <bits name="pad_M_SPI_D_3_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>M_SPI_D_3 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_M_SPI_D_3_pull_up" pos="9" access="rw" rst="0"> 
         <comment>M_SPI_D_3 PUll up</comment>
         </bits>
     <bits name="pad_M_SPI_D_3_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>M_SPI_D_3 PUll down</comment>
         </bits>
     <bits name="pad_M_SPI_D_3_ana" pos="7:4" access="rw" rst="0"> 
         <comment>M_SPI_D_3 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_M_SPI_D_3_sel" pos="3:0" access="rw" rst="0"> 
         <comment>M_SPI_D_3 select</comment>
     <options>
            <option name="fun_M_SPI_D_3_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_SDMMC_CLK_cfg" protect="rw">
     <bits name="pad_SDMMC_CLK_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>SDMMC_CLK force enable for outoen. </comment>
         </bits>
     <bits name="pad_SDMMC_CLK_out_frc" pos="24" access="rw" rst="0"> 
         <comment>SDMMC_CLK force output value for output. </comment>
         </bits>
     <bits name="pad_SDMMC_CLK_out_reg" pos="20" access="rw" rst="0"> 
         <comment>SDMMC_CLK pin output value. </comment>
         </bits>
     <bits name="pad_SDMMC_CLK_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_SDMMC_CLK_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>SDMMC_CLK force outoen value. </comment>
         </bits>
     <bits name="pad_SDMMC_CLK_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>SDMMC_CLK force enable for pu/pd </comment>
         </bits>
     <bits name="pad_SDMMC_CLK_pull_up" pos="9" access="rw" rst="0"> 
         <comment>SDMMC_CLK PUll up</comment>
         </bits>
     <bits name="pad_SDMMC_CLK_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>SDMMC_CLK PUll down</comment>
         </bits>
     <bits name="pad_SDMMC_CLK_ana" pos="7:4" access="rw" rst="0"> 
         <comment>SDMMC_CLK ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_SDMMC_CLK_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SDMMC_CLK select</comment>
     <options>
            <option name="fun_SDMMC_CLK_sel" value ="0"></option>
            <option name="fun_GPIO_8_sel" value ="1"></option>
            <option name="fun_SPI1_CLK_sel" value ="2"></option>
            <option name="fun_I2C1_SCL_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_SDMMC_CMD_cfg" protect="rw">
     <bits name="pad_SDMMC_CMD_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>SDMMC_CMD force enable for outoen. </comment>
         </bits>
     <bits name="pad_SDMMC_CMD_out_frc" pos="24" access="rw" rst="0"> 
         <comment>SDMMC_CMD force output value for output. </comment>
         </bits>
     <bits name="pad_SDMMC_CMD_out_reg" pos="20" access="rw" rst="0"> 
         <comment>SDMMC_CMD pin output value. </comment>
         </bits>
     <bits name="pad_SDMMC_CMD_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_SDMMC_CMD_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>SDMMC_CMD force outoen value. </comment>
         </bits>
     <bits name="pad_SDMMC_CMD_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>SDMMC_CMD force enable for pu/pd </comment>
         </bits>
     <bits name="pad_SDMMC_CMD_pull_up" pos="9" access="rw" rst="0"> 
         <comment>SDMMC_CMD PUll up</comment>
         </bits>
     <bits name="pad_SDMMC_CMD_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>SDMMC_CMD PUll down</comment>
         </bits>
     <bits name="pad_SDMMC_CMD_ana" pos="7:4" access="rw" rst="0"> 
         <comment>SDMMC_CMD ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_SDMMC_CMD_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SDMMC_CMD select</comment>
     <options>
            <option name="fun_SDMMC_CMD_sel" value ="0"></option>
            <option name="fun_GPIO_9_sel" value ="1"></option>
            <option name="fun_SPI1_CS_0_sel" value ="2"></option>
            <option name="fun_I2C1_SDA_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_SDMMC_DATA_0_cfg" protect="rw">
     <bits name="pad_SDMMC_DATA_0_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>SDMMC_DATA_0 force enable for outoen. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_0_out_frc" pos="24" access="rw" rst="0"> 
         <comment>SDMMC_DATA_0 force output value for output. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_0_out_reg" pos="20" access="rw" rst="0"> 
         <comment>SDMMC_DATA_0 pin output value. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_0_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_0_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>SDMMC_DATA_0 force outoen value. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_0_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>SDMMC_DATA_0 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_0_pull_up" pos="9" access="rw" rst="0"> 
         <comment>SDMMC_DATA_0 PUll up</comment>
         </bits>
     <bits name="pad_SDMMC_DATA_0_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>SDMMC_DATA_0 PUll down</comment>
         </bits>
     <bits name="pad_SDMMC_DATA_0_ana" pos="7:4" access="rw" rst="0"> 
         <comment>SDMMC_DATA_0 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_SDMMC_DATA_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SDMMC_DATA_0 select</comment>
     <options>
            <option name="fun_SDMMC_DATA_0_sel" value ="0"></option>
            <option name="fun_GPIO_10_sel" value ="1"></option>
            <option name="fun_SPI1_CS_1_sel" value ="2"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_SDMMC_DATA_1_cfg" protect="rw">
     <bits name="pad_SDMMC_DATA_1_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>SDMMC_DATA_1 force enable for outoen. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_1_out_frc" pos="24" access="rw" rst="0"> 
         <comment>SDMMC_DATA_1 force output value for output. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_1_out_reg" pos="20" access="rw" rst="0"> 
         <comment>SDMMC_DATA_1 pin output value. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_1_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_1_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>SDMMC_DATA_1 force outoen value. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_1_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>SDMMC_DATA_1 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_1_pull_up" pos="9" access="rw" rst="0"> 
         <comment>SDMMC_DATA_1 PUll up</comment>
         </bits>
     <bits name="pad_SDMMC_DATA_1_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>SDMMC_DATA_1 PUll down</comment>
         </bits>
     <bits name="pad_SDMMC_DATA_1_ana" pos="7:4" access="rw" rst="0"> 
         <comment>SDMMC_DATA_1 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_SDMMC_DATA_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SDMMC_DATA_1 select</comment>
     <options>
            <option name="fun_SDMMC_DATA_1_sel" value ="0"></option>
            <option name="fun_GPIO_11_sel" value ="1"></option>
            <option name="fun_SPI1_DI_0_sel" value ="2"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_SDMMC_DATA_2_cfg" protect="rw">
     <bits name="pad_SDMMC_DATA_2_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>SDMMC_DATA_2 force enable for outoen. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_2_out_frc" pos="24" access="rw" rst="0"> 
         <comment>SDMMC_DATA_2 force output value for output. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_2_out_reg" pos="20" access="rw" rst="0"> 
         <comment>SDMMC_DATA_2 pin output value. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_2_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_2_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>SDMMC_DATA_2 force outoen value. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_2_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>SDMMC_DATA_2 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_2_pull_up" pos="9" access="rw" rst="0"> 
         <comment>SDMMC_DATA_2 PUll up</comment>
         </bits>
     <bits name="pad_SDMMC_DATA_2_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>SDMMC_DATA_2 PUll down</comment>
         </bits>
     <bits name="pad_SDMMC_DATA_2_ana" pos="7:4" access="rw" rst="0"> 
         <comment>SDMMC_DATA_2 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_SDMMC_DATA_2_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SDMMC_DATA_2 select</comment>
     <options>
            <option name="fun_SDMMC_DATA_2_sel" value ="0"></option>
            <option name="fun_GPIO_12_sel" value ="1"></option>
            <option name="fun_SPI1_DI_1_sel" value ="2"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_SDMMC_DATA_3_cfg" protect="rw">
     <bits name="pad_SDMMC_DATA_3_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>SDMMC_DATA_3 force enable for outoen. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_3_out_frc" pos="24" access="rw" rst="0"> 
         <comment>SDMMC_DATA_3 force output value for output. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_3_out_reg" pos="20" access="rw" rst="0"> 
         <comment>SDMMC_DATA_3 pin output value. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_3_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_3_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>SDMMC_DATA_3 force outoen value. </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_3_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>SDMMC_DATA_3 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_SDMMC_DATA_3_pull_up" pos="9" access="rw" rst="0"> 
         <comment>SDMMC_DATA_3 PUll up</comment>
         </bits>
     <bits name="pad_SDMMC_DATA_3_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>SDMMC_DATA_3 PUll down</comment>
         </bits>
     <bits name="pad_SDMMC_DATA_3_ana" pos="7:4" access="rw" rst="0"> 
         <comment>SDMMC_DATA_3 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_SDMMC_DATA_3_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SDMMC_DATA_3 select</comment>
     <options>
            <option name="fun_SDMMC_DATA_3_sel" value ="0"></option>
            <option name="fun_GPIO_13_sel" value ="1"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_LCD_RSTB_cfg" protect="rw">
     <bits name="pad_LCD_RSTB_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>LCD_RSTB force enable for outoen. </comment>
         </bits>
     <bits name="pad_LCD_RSTB_out_frc" pos="24" access="rw" rst="0"> 
         <comment>LCD_RSTB force output value for output. </comment>
         </bits>
     <bits name="pad_LCD_RSTB_out_reg" pos="20" access="rw" rst="0"> 
         <comment>LCD_RSTB pin output value. </comment>
         </bits>
     <bits name="pad_LCD_RSTB_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_LCD_RSTB_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>LCD_RSTB force outoen value. </comment>
         </bits>
     <bits name="pad_LCD_RSTB_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>LCD_RSTB force enable for pu/pd </comment>
         </bits>
     <bits name="pad_LCD_RSTB_pull_up" pos="9" access="rw" rst="0"> 
         <comment>LCD_RSTB PUll up</comment>
         </bits>
     <bits name="pad_LCD_RSTB_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>LCD_RSTB PUll down</comment>
         </bits>
     <bits name="pad_LCD_RSTB_ana" pos="7:4" access="rw" rst="0"> 
         <comment>LCD_RSTB ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_LCD_RSTB_sel" pos="3:0" access="rw" rst="0"> 
         <comment>LCD_RSTB select</comment>
     <options>
            <option name="fun_LCD_RSTB_sel" value ="0"></option>
            <option name="fun_GPIO_14_sel" value ="1"></option>
            <option name="fun_DAI_RST_sel" value ="2"></option>
            <option name="fun_I2S_BCK_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_SPI_LCD_CS_cfg" protect="rw">
     <bits name="pad_SPI_LCD_CS_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>SPI_LCD_CS force enable for outoen. </comment>
         </bits>
     <bits name="pad_SPI_LCD_CS_out_frc" pos="24" access="rw" rst="0"> 
         <comment>SPI_LCD_CS force output value for output. </comment>
         </bits>
     <bits name="pad_SPI_LCD_CS_out_reg" pos="20" access="rw" rst="0"> 
         <comment>SPI_LCD_CS pin output value. </comment>
         </bits>
     <bits name="pad_SPI_LCD_CS_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_SPI_LCD_CS_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>SPI_LCD_CS force outoen value. </comment>
         </bits>
     <bits name="pad_SPI_LCD_CS_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>SPI_LCD_CS force enable for pu/pd </comment>
         </bits>
     <bits name="pad_SPI_LCD_CS_pull_up" pos="9" access="rw" rst="0"> 
         <comment>SPI_LCD_CS PUll up</comment>
         </bits>
     <bits name="pad_SPI_LCD_CS_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>SPI_LCD_CS PUll down</comment>
         </bits>
     <bits name="pad_SPI_LCD_CS_ana" pos="7:4" access="rw" rst="0"> 
         <comment>SPI_LCD_CS ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_SPI_LCD_CS_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SPI_LCD_CS select</comment>
     <options>
            <option name="fun_SPI_LCD_CS_sel" value ="0"></option>
            <option name="fun_GPIO_15_sel" value ="1"></option>
            <option name="fun_DAI_CLK_sel" value ="2"></option>
            <option name="fun_I2S_LRCK_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_SPI_LCD_SCK_cfg" protect="rw">
     <bits name="pad_SPI_LCD_SCK_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>SPI_LCD_SCK force enable for outoen. </comment>
         </bits>
     <bits name="pad_SPI_LCD_SCK_out_frc" pos="24" access="rw" rst="0"> 
         <comment>SPI_LCD_SCK force output value for output. </comment>
         </bits>
     <bits name="pad_SPI_LCD_SCK_out_reg" pos="20" access="rw" rst="0"> 
         <comment>SPI_LCD_SCK pin output value. </comment>
         </bits>
     <bits name="pad_SPI_LCD_SCK_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_SPI_LCD_SCK_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>SPI_LCD_SCK force outoen value. </comment>
         </bits>
     <bits name="pad_SPI_LCD_SCK_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>SPI_LCD_SCK force enable for pu/pd </comment>
         </bits>
     <bits name="pad_SPI_LCD_SCK_pull_up" pos="9" access="rw" rst="0"> 
         <comment>SPI_LCD_SCK PUll up</comment>
         </bits>
     <bits name="pad_SPI_LCD_SCK_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>SPI_LCD_SCK PUll down</comment>
         </bits>
     <bits name="pad_SPI_LCD_SCK_ana" pos="7:4" access="rw" rst="0"> 
         <comment>SPI_LCD_SCK ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_SPI_LCD_SCK_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SPI_LCD_SCK select</comment>
     <options>
            <option name="fun_SPI_LCD_SCK_sel" value ="0"></option>
            <option name="fun_GPIO_16_sel" value ="1"></option>
            <option name="fun_DAI_DI_sel" value ="2"></option>
            <option name="fun_I2S_DI_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_SPI_LCD_DIO_cfg" protect="rw">
     <bits name="pad_SPI_LCD_DIO_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>SPI_LCD_DIO force enable for outoen. </comment>
         </bits>
     <bits name="pad_SPI_LCD_DIO_out_frc" pos="24" access="rw" rst="0"> 
         <comment>SPI_LCD_DIO force output value for output. </comment>
         </bits>
     <bits name="pad_SPI_LCD_DIO_out_reg" pos="20" access="rw" rst="0"> 
         <comment>SPI_LCD_DIO pin output value. </comment>
         </bits>
     <bits name="pad_SPI_LCD_DIO_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_SPI_LCD_DIO_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>SPI_LCD_DIO force outoen value. </comment>
         </bits>
     <bits name="pad_SPI_LCD_DIO_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>SPI_LCD_DIO force enable for pu/pd </comment>
         </bits>
     <bits name="pad_SPI_LCD_DIO_pull_up" pos="9" access="rw" rst="0"> 
         <comment>SPI_LCD_DIO PUll up</comment>
         </bits>
     <bits name="pad_SPI_LCD_DIO_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>SPI_LCD_DIO PUll down</comment>
         </bits>
     <bits name="pad_SPI_LCD_DIO_ana" pos="7:4" access="rw" rst="0"> 
         <comment>SPI_LCD_DIO ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_SPI_LCD_DIO_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SPI_LCD_DIO select</comment>
     <options>
            <option name="fun_SPI_LCD_DIO_sel" value ="0"></option>
            <option name="fun_GPIO_17_sel" value ="1"></option>
            <option name="fun_DAI_DO_sel" value ="2"></option>
            <option name="fun_I2S_DO_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_SPI_LCD_SDC_cfg" protect="rw">
     <bits name="pad_SPI_LCD_SDC_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>SPI_LCD_SDC force enable for outoen. </comment>
         </bits>
     <bits name="pad_SPI_LCD_SDC_out_frc" pos="24" access="rw" rst="0"> 
         <comment>SPI_LCD_SDC force output value for output. </comment>
         </bits>
     <bits name="pad_SPI_LCD_SDC_out_reg" pos="20" access="rw" rst="0"> 
         <comment>SPI_LCD_SDC pin output value. </comment>
         </bits>
     <bits name="pad_SPI_LCD_SDC_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_SPI_LCD_SDC_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>SPI_LCD_SDC force outoen value. </comment>
         </bits>
     <bits name="pad_SPI_LCD_SDC_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>SPI_LCD_SDC force enable for pu/pd </comment>
         </bits>
     <bits name="pad_SPI_LCD_SDC_pull_up" pos="9" access="rw" rst="0"> 
         <comment>SPI_LCD_SDC PUll up</comment>
         </bits>
     <bits name="pad_SPI_LCD_SDC_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>SPI_LCD_SDC PUll down</comment>
         </bits>
     <bits name="pad_SPI_LCD_SDC_ana" pos="7:4" access="rw" rst="0"> 
         <comment>SPI_LCD_SDC ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_SPI_LCD_SDC_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SPI_LCD_SDC select</comment>
     <options>
            <option name="fun_SPI_LCD_SDC_sel" value ="0"></option>
            <option name="fun_GPIO_18_sel" value ="1"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_CAM_PWDN_cfg" protect="rw">
     <bits name="pad_CAM_PWDN_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>CAM_PWDN force enable for outoen. </comment>
         </bits>
     <bits name="pad_CAM_PWDN_out_frc" pos="24" access="rw" rst="0"> 
         <comment>CAM_PWDN force output value for output. </comment>
         </bits>
     <bits name="pad_CAM_PWDN_out_reg" pos="20" access="rw" rst="0"> 
         <comment>CAM_PWDN pin output value. </comment>
         </bits>
     <bits name="pad_CAM_PWDN_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_CAM_PWDN_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>CAM_PWDN force outoen value. </comment>
         </bits>
     <bits name="pad_CAM_PWDN_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>CAM_PWDN force enable for pu/pd </comment>
         </bits>
     <bits name="pad_CAM_PWDN_pull_up" pos="9" access="rw" rst="0"> 
         <comment>CAM_PWDN PUll up</comment>
         </bits>
     <bits name="pad_CAM_PWDN_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>CAM_PWDN PUll down</comment>
         </bits>
     <bits name="pad_CAM_PWDN_ana" pos="7:4" access="rw" rst="0"> 
         <comment>CAM_PWDN ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_CAM_PWDN_sel" pos="3:0" access="rw" rst="0"> 
         <comment>CAM_PWDN select</comment>
     <options>
            <option name="fun_CAM_PWDN_sel" value ="0"></option>
            <option name="fun_GPIO_19_sel" value ="1"></option>
            <option name="fun_I2C2_SCL_sel" value ="2"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_CAM_RSTB_cfg" protect="rw">
     <bits name="pad_CAM_RSTB_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>CAM_RSTB force enable for outoen. </comment>
         </bits>
     <bits name="pad_CAM_RSTB_out_frc" pos="24" access="rw" rst="0"> 
         <comment>CAM_RSTB force output value for output. </comment>
         </bits>
     <bits name="pad_CAM_RSTB_out_reg" pos="20" access="rw" rst="0"> 
         <comment>CAM_RSTB pin output value. </comment>
         </bits>
     <bits name="pad_CAM_RSTB_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_CAM_RSTB_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>CAM_RSTB force outoen value. </comment>
         </bits>
     <bits name="pad_CAM_RSTB_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>CAM_RSTB force enable for pu/pd </comment>
         </bits>
     <bits name="pad_CAM_RSTB_pull_up" pos="9" access="rw" rst="0"> 
         <comment>CAM_RSTB PUll up</comment>
         </bits>
     <bits name="pad_CAM_RSTB_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>CAM_RSTB PUll down</comment>
         </bits>
     <bits name="pad_CAM_RSTB_ana" pos="7:4" access="rw" rst="0"> 
         <comment>CAM_RSTB ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_CAM_RSTB_sel" pos="3:0" access="rw" rst="0"> 
         <comment>CAM_RSTB select</comment>
     <options>
            <option name="fun_CAM_RSTB_sel" value ="0"></option>
            <option name="fun_GPIO_20_sel" value ="1"></option>
            <option name="fun_I2C2_SDA_sel" value ="2"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_CAM_CLK_cfg" protect="rw">
     <bits name="pad_CAM_CLK_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>CAM_CLK force enable for outoen. </comment>
         </bits>
     <bits name="pad_CAM_CLK_out_frc" pos="24" access="rw" rst="0"> 
         <comment>CAM_CLK force output value for output. </comment>
         </bits>
     <bits name="pad_CAM_CLK_out_reg" pos="20" access="rw" rst="0"> 
         <comment>CAM_CLK pin output value. </comment>
         </bits>
     <bits name="pad_CAM_CLK_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_CAM_CLK_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>CAM_CLK force outoen value. </comment>
         </bits>
     <bits name="pad_CAM_CLK_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>CAM_CLK force enable for pu/pd </comment>
         </bits>
     <bits name="pad_CAM_CLK_pull_up" pos="9" access="rw" rst="0"> 
         <comment>CAM_CLK PUll up</comment>
         </bits>
     <bits name="pad_CAM_CLK_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>CAM_CLK PUll down</comment>
         </bits>
     <bits name="pad_CAM_CLK_ana" pos="7:4" access="rw" rst="0"> 
         <comment>CAM_CLK ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_CAM_CLK_sel" pos="3:0" access="rw" rst="0"> 
         <comment>CAM_CLK select</comment>
     <options>
            <option name="fun_CAM_CLK_sel" value ="0"></option>
            <option name="fun_GPIO_21_sel" value ="1"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_SPI_CAM_SCK_cfg" protect="rw">
     <bits name="pad_SPI_CAM_SCK_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>SPI_CAM_SCK force enable for outoen. </comment>
         </bits>
     <bits name="pad_SPI_CAM_SCK_out_frc" pos="24" access="rw" rst="0"> 
         <comment>SPI_CAM_SCK force output value for output. </comment>
         </bits>
     <bits name="pad_SPI_CAM_SCK_out_reg" pos="20" access="rw" rst="0"> 
         <comment>SPI_CAM_SCK pin output value. </comment>
         </bits>
     <bits name="pad_SPI_CAM_SCK_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_SPI_CAM_SCK_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>SPI_CAM_SCK force outoen value. </comment>
         </bits>
     <bits name="pad_SPI_CAM_SCK_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>SPI_CAM_SCK force enable for pu/pd </comment>
         </bits>
     <bits name="pad_SPI_CAM_SCK_pull_up" pos="9" access="rw" rst="0"> 
         <comment>SPI_CAM_SCK PUll up</comment>
         </bits>
     <bits name="pad_SPI_CAM_SCK_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>SPI_CAM_SCK PUll down</comment>
         </bits>
     <bits name="pad_SPI_CAM_SCK_ana" pos="7:4" access="rw" rst="0"> 
         <comment>SPI_CAM_SCK ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_SPI_CAM_SCK_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SPI_CAM_SCK select</comment>
     <options>
            <option name="fun_SPI_CAM_SCK_sel" value ="0"></option>
            <option name="fun_GPIO_22_sel" value ="1"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_SPI_CAM_DI_0_cfg" protect="rw">
     <bits name="pad_SPI_CAM_DI_0_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_0 force enable for outoen. </comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_0_out_frc" pos="24" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_0 force output value for output. </comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_0_out_reg" pos="20" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_0 pin output value. </comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_0_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_0_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_0 force outoen value. </comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_0_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_0 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_0_pull_up" pos="9" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_0 PUll up</comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_0_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_0 PUll down</comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_0_ana" pos="7:4" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_0 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_0 select</comment>
     <options>
            <option name="fun_SPI_CAM_DI_0_sel" value ="0"></option>
            <option name="fun_GPIO_23_sel" value ="1"></option>
            <option name="fun_SPI_CAM_DI_1_sel" value ="2"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_SPI_CAM_DI_1_cfg" protect="rw">
     <bits name="pad_SPI_CAM_DI_1_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_1 force enable for outoen. </comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_1_out_frc" pos="24" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_1 force output value for output. </comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_1_out_reg" pos="20" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_1 pin output value. </comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_1_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_1_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_1 force outoen value. </comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_1_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_1 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_1_pull_up" pos="9" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_1 PUll up</comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_1_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_1 PUll down</comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_1_ana" pos="7:4" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_1 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_SPI_CAM_DI_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SPI_CAM_DI_1 select</comment>
     <options>
            <option name="fun_SPI_CAM_DI_1_sel" value ="0"></option>
            <option name="fun_GPIO_24_sel" value ="1"></option>
            <option name="fun_SPI_CAM_DI_0_sel" value ="2"></option>
            <option name="fun_SPI_CAM_SSN_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_GPIO_0_cfg" protect="rw">
     <bits name="pad_GPIO_0_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>GPIO_0 force enable for outoen. </comment>
         </bits>
     <bits name="pad_GPIO_0_out_frc" pos="24" access="rw" rst="0"> 
         <comment>GPIO_0 force output value for output. </comment>
         </bits>
     <bits name="pad_GPIO_0_out_reg" pos="20" access="rw" rst="0"> 
         <comment>GPIO_0 pin output value. </comment>
         </bits>
     <bits name="pad_GPIO_0_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_GPIO_0_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>GPIO_0 force outoen value. </comment>
         </bits>
     <bits name="pad_GPIO_0_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>GPIO_0 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_GPIO_0_pull_up" pos="9" access="rw" rst="0"> 
         <comment>GPIO_0 PUll up</comment>
         </bits>
     <bits name="pad_GPIO_0_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>GPIO_0 PUll down</comment>
         </bits>
     <bits name="pad_GPIO_0_ana" pos="7:4" access="rw" rst="0"> 
         <comment>GPIO_0 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_GPIO_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_0 select</comment>
     <options>
            <option name="fun_GPIO_0_sel" value ="0"></option>
            <option name="fun_UART1_RXD_sel" value ="1"></option>
            <option name="fun_SPI2_CLK_sel" value ="2"></option>
            <option name="fun_SEGOUT_0_sel" value ="4"></option>
            <option name="fun_DBG_DO_0_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_GPIO_1_cfg" protect="rw">
     <bits name="pad_GPIO_1_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>GPIO_1 force enable for outoen. </comment>
         </bits>
     <bits name="pad_GPIO_1_out_frc" pos="24" access="rw" rst="0"> 
         <comment>GPIO_1 force output value for output. </comment>
         </bits>
     <bits name="pad_GPIO_1_out_reg" pos="20" access="rw" rst="0"> 
         <comment>GPIO_1 pin output value. </comment>
         </bits>
     <bits name="pad_GPIO_1_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_GPIO_1_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>GPIO_1 force outoen value. </comment>
         </bits>
     <bits name="pad_GPIO_1_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>GPIO_1 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_GPIO_1_pull_up" pos="9" access="rw" rst="0"> 
         <comment>GPIO_1 PUll up</comment>
         </bits>
     <bits name="pad_GPIO_1_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>GPIO_1 PUll down</comment>
         </bits>
     <bits name="pad_GPIO_1_ana" pos="7:4" access="rw" rst="0"> 
         <comment>GPIO_1 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_GPIO_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_1 select</comment>
     <options>
            <option name="fun_GPIO_1_sel" value ="0"></option>
            <option name="fun_UART1_TXD_sel" value ="1"></option>
            <option name="fun_SPI2_CS_0_sel" value ="2"></option>
            <option name="fun_SEGOUT_1_sel" value ="4"></option>
            <option name="fun_DBG_DO_1_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_GPIO_2_cfg" protect="rw">
     <bits name="pad_GPIO_2_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>GPIO_2 force enable for outoen. </comment>
         </bits>
     <bits name="pad_GPIO_2_out_frc" pos="24" access="rw" rst="0"> 
         <comment>GPIO_2 force output value for output. </comment>
         </bits>
     <bits name="pad_GPIO_2_out_reg" pos="20" access="rw" rst="0"> 
         <comment>GPIO_2 pin output value. </comment>
         </bits>
     <bits name="pad_GPIO_2_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_GPIO_2_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>GPIO_2 force outoen value. </comment>
         </bits>
     <bits name="pad_GPIO_2_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>GPIO_2 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_GPIO_2_pull_up" pos="9" access="rw" rst="0"> 
         <comment>GPIO_2 PUll up</comment>
         </bits>
     <bits name="pad_GPIO_2_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>GPIO_2 PUll down</comment>
         </bits>
     <bits name="pad_GPIO_2_ana" pos="7:4" access="rw" rst="0"> 
         <comment>GPIO_2 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_GPIO_2_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_2 select</comment>
     <options>
            <option name="fun_GPIO_2_sel" value ="0"></option>
            <option name="fun_UART1_CTS_sel" value ="1"></option>
            <option name="fun_SPI2_CS_1_sel" value ="2"></option>
            <option name="fun_PWL_1_sel" value ="3"></option>
            <option name="fun_SEGOUT_2_sel" value ="4"></option>
            <option name="fun_DBG_DO_2_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_GPIO_3_cfg" protect="rw">
     <bits name="pad_GPIO_3_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>GPIO_3 force enable for outoen. </comment>
         </bits>
     <bits name="pad_GPIO_3_out_frc" pos="24" access="rw" rst="0"> 
         <comment>GPIO_3 force output value for output. </comment>
         </bits>
     <bits name="pad_GPIO_3_out_reg" pos="20" access="rw" rst="0"> 
         <comment>GPIO_3 pin output value. </comment>
         </bits>
     <bits name="pad_GPIO_3_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_GPIO_3_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>GPIO_3 force outoen value. </comment>
         </bits>
     <bits name="pad_GPIO_3_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>GPIO_3 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_GPIO_3_pull_up" pos="9" access="rw" rst="0"> 
         <comment>GPIO_3 PUll up</comment>
         </bits>
     <bits name="pad_GPIO_3_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>GPIO_3 PUll down</comment>
         </bits>
     <bits name="pad_GPIO_3_ana" pos="7:4" access="rw" rst="0"> 
         <comment>GPIO_3 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_GPIO_3_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_3 select</comment>
     <options>
            <option name="fun_GPIO_3_sel" value ="0"></option>
            <option name="fun_UART1_RTS_sel" value ="1"></option>
            <option name="fun_SPI2_DI_0_sel" value ="2"></option>
            <option name="fun_LPSCO_1_sel" value ="3"></option>
            <option name="fun_SEGOUT_3_sel" value ="4"></option>
            <option name="fun_DBG_DO_3_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_GPIO_4_cfg" protect="rw">
     <bits name="pad_GPIO_4_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>GPIO_4 force enable for outoen. </comment>
         </bits>
     <bits name="pad_GPIO_4_out_frc" pos="24" access="rw" rst="0"> 
         <comment>GPIO_4 force output value for output. </comment>
         </bits>
     <bits name="pad_GPIO_4_out_reg" pos="20" access="rw" rst="0"> 
         <comment>GPIO_4 pin output value. </comment>
         </bits>
     <bits name="pad_GPIO_4_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_GPIO_4_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>GPIO_4 force outoen value. </comment>
         </bits>
     <bits name="pad_GPIO_4_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>GPIO_4 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_GPIO_4_pull_up" pos="9" access="rw" rst="0"> 
         <comment>GPIO_4 PUll up</comment>
         </bits>
     <bits name="pad_GPIO_4_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>GPIO_4 PUll down</comment>
         </bits>
     <bits name="pad_GPIO_4_ana" pos="7:4" access="rw" rst="0"> 
         <comment>GPIO_4 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_GPIO_4_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_4 select</comment>
     <options>
            <option name="fun_GPIO_4_sel" value ="0"></option>
            <option name="fun_UART2_RXD_sel" value ="1"></option>
            <option name="fun_SPI2_DI_1_sel" value ="2"></option>
            <option name="fun_LPG_sel" value ="3"></option>
            <option name="fun_SEGOUT_4_sel" value ="4"></option>
            <option name="fun_DBG_DO_4_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_GPIO_5_cfg" protect="rw">
     <bits name="pad_GPIO_5_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>GPIO_5 force enable for outoen. </comment>
         </bits>
     <bits name="pad_GPIO_5_out_frc" pos="24" access="rw" rst="0"> 
         <comment>GPIO_5 force output value for output. </comment>
         </bits>
     <bits name="pad_GPIO_5_out_reg" pos="20" access="rw" rst="0"> 
         <comment>GPIO_5 pin output value. </comment>
         </bits>
     <bits name="pad_GPIO_5_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_GPIO_5_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>GPIO_5 force outoen value. </comment>
         </bits>
     <bits name="pad_GPIO_5_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>GPIO_5 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_GPIO_5_pull_up" pos="9" access="rw" rst="0"> 
         <comment>GPIO_5 PUll up</comment>
         </bits>
     <bits name="pad_GPIO_5_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>GPIO_5 PUll down</comment>
         </bits>
     <bits name="pad_GPIO_5_ana" pos="7:4" access="rw" rst="0"> 
         <comment>GPIO_5 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_GPIO_5_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_5 select</comment>
     <options>
            <option name="fun_GPIO_5_sel" value ="0"></option>
            <option name="fun_UART2_TXD_sel" value ="1"></option>
            <option name="fun_LCD_TE_sel" value ="2"></option>
            <option name="fun_PWT_sel" value ="3"></option>
            <option name="fun_SEGOUT_5_sel" value ="4"></option>
            <option name="fun_DBG_DO_5_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_GPIO_6_cfg" protect="rw">
     <bits name="pad_GPIO_6_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>GPIO_6 force enable for outoen. </comment>
         </bits>
     <bits name="pad_GPIO_6_out_frc" pos="24" access="rw" rst="0"> 
         <comment>GPIO_6 force output value for output. </comment>
         </bits>
     <bits name="pad_GPIO_6_out_reg" pos="20" access="rw" rst="0"> 
         <comment>GPIO_6 pin output value. </comment>
         </bits>
     <bits name="pad_GPIO_6_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_GPIO_6_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>GPIO_6 force outoen value. </comment>
         </bits>
     <bits name="pad_GPIO_6_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>GPIO_6 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_GPIO_6_pull_up" pos="9" access="rw" rst="0"> 
         <comment>GPIO_6 PUll up</comment>
         </bits>
     <bits name="pad_GPIO_6_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>GPIO_6 PUll down</comment>
         </bits>
     <bits name="pad_GPIO_6_ana" pos="7:4" access="rw" rst="0"> 
         <comment>GPIO_6 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_GPIO_6_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_6 select</comment>
     <options>
            <option name="fun_GPIO_6_sel" value ="0"></option>
            <option name="fun_UART2_CTS_sel" value ="1"></option>
            <option name="fun_I2C3_SCL_sel" value ="2"></option>
            <option name="fun_TCO_3_sel" value ="3"></option>
            <option name="fun_SEGOUT_6_sel" value ="4"></option>
            <option name="fun_DBG_DO_6_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_GPIO_7_cfg" protect="rw">
     <bits name="pad_GPIO_7_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>GPIO_7 force enable for outoen. </comment>
         </bits>
     <bits name="pad_GPIO_7_out_frc" pos="24" access="rw" rst="0"> 
         <comment>GPIO_7 force output value for output. </comment>
         </bits>
     <bits name="pad_GPIO_7_out_reg" pos="20" access="rw" rst="0"> 
         <comment>GPIO_7 pin output value. </comment>
         </bits>
     <bits name="pad_GPIO_7_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_GPIO_7_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>GPIO_7 force outoen value. </comment>
         </bits>
     <bits name="pad_GPIO_7_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>GPIO_7 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_GPIO_7_pull_up" pos="9" access="rw" rst="0"> 
         <comment>GPIO_7 PUll up</comment>
         </bits>
     <bits name="pad_GPIO_7_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>GPIO_7 PUll down</comment>
         </bits>
     <bits name="pad_GPIO_7_ana" pos="7:4" access="rw" rst="0"> 
         <comment>GPIO_7 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_GPIO_7_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_7 select</comment>
     <options>
            <option name="fun_GPIO_7_sel" value ="0"></option>
            <option name="fun_UART2_RTS_sel" value ="1"></option>
            <option name="fun_I2C3_SDA_sel" value ="2"></option>
            <option name="fun_TCO_4_sel" value ="3"></option>
            <option name="fun_SEGOUT_7_sel" value ="4"></option>
            <option name="fun_DBG_DO_7_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_KEYIN_0_cfg" protect="rw">
     <bits name="pad_KEYIN_0_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>KEYIN_0 force enable for outoen. </comment>
         </bits>
     <bits name="pad_KEYIN_0_out_frc" pos="24" access="rw" rst="0"> 
         <comment>KEYIN_0 force output value for output. </comment>
         </bits>
     <bits name="pad_KEYIN_0_out_reg" pos="20" access="rw" rst="0"> 
         <comment>KEYIN_0 pin output value. </comment>
         </bits>
     <bits name="pad_KEYIN_0_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_KEYIN_0_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>KEYIN_0 force outoen value. </comment>
         </bits>
     <bits name="pad_KEYIN_0_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>KEYIN_0 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_KEYIN_0_pull_up" pos="9" access="rw" rst="0"> 
         <comment>KEYIN_0 PUll up</comment>
         </bits>
     <bits name="pad_KEYIN_0_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>KEYIN_0 PUll down</comment>
         </bits>
     <bits name="pad_KEYIN_0_ana" pos="7:4" access="rw" rst="0"> 
         <comment>KEYIN_0 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_KEYIN_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>KEYIN_0 select</comment>
     <options>
            <option name="fun_KEYIN_0_sel" value ="0"></option>
            <option name="fun_GPIO_25_sel" value ="1"></option>
            <option name="fun_SEGOUT_8_sel" value ="4"></option>
            <option name="fun_DBG_DO_8_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_KEYIN_1_cfg" protect="rw">
     <bits name="pad_KEYIN_1_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>KEYIN_1 force enable for outoen. </comment>
         </bits>
     <bits name="pad_KEYIN_1_out_frc" pos="24" access="rw" rst="0"> 
         <comment>KEYIN_1 force output value for output. </comment>
         </bits>
     <bits name="pad_KEYIN_1_out_reg" pos="20" access="rw" rst="0"> 
         <comment>KEYIN_1 pin output value. </comment>
         </bits>
     <bits name="pad_KEYIN_1_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_KEYIN_1_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>KEYIN_1 force outoen value. </comment>
         </bits>
     <bits name="pad_KEYIN_1_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>KEYIN_1 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_KEYIN_1_pull_up" pos="9" access="rw" rst="0"> 
         <comment>KEYIN_1 PUll up</comment>
         </bits>
     <bits name="pad_KEYIN_1_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>KEYIN_1 PUll down</comment>
         </bits>
     <bits name="pad_KEYIN_1_ana" pos="7:4" access="rw" rst="0"> 
         <comment>KEYIN_1 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_KEYIN_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>KEYIN_1 select</comment>
     <options>
            <option name="fun_KEYIN_1_sel" value ="0"></option>
            <option name="fun_GPIO_26_sel" value ="1"></option>
            <option name="fun_SEGOUT_9_sel" value ="4"></option>
            <option name="fun_DBG_DO_9_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_KEYIN_2_cfg" protect="rw">
     <bits name="pad_KEYIN_2_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>KEYIN_2 force enable for outoen. </comment>
         </bits>
     <bits name="pad_KEYIN_2_out_frc" pos="24" access="rw" rst="0"> 
         <comment>KEYIN_2 force output value for output. </comment>
         </bits>
     <bits name="pad_KEYIN_2_out_reg" pos="20" access="rw" rst="0"> 
         <comment>KEYIN_2 pin output value. </comment>
         </bits>
     <bits name="pad_KEYIN_2_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_KEYIN_2_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>KEYIN_2 force outoen value. </comment>
         </bits>
     <bits name="pad_KEYIN_2_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>KEYIN_2 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_KEYIN_2_pull_up" pos="9" access="rw" rst="0"> 
         <comment>KEYIN_2 PUll up</comment>
         </bits>
     <bits name="pad_KEYIN_2_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>KEYIN_2 PUll down</comment>
         </bits>
     <bits name="pad_KEYIN_2_ana" pos="7:4" access="rw" rst="0"> 
         <comment>KEYIN_2 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_KEYIN_2_sel" pos="3:0" access="rw" rst="0"> 
         <comment>KEYIN_2 select</comment>
     <options>
            <option name="fun_KEYIN_2_sel" value ="0"></option>
            <option name="fun_GPIO_27_sel" value ="1"></option>
            <option name="fun_SEGOUT_10_sel" value ="4"></option>
            <option name="fun_DBG_DO_10_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_KEYIN_3_cfg" protect="rw">
     <bits name="pad_KEYIN_3_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>KEYIN_3 force enable for outoen. </comment>
         </bits>
     <bits name="pad_KEYIN_3_out_frc" pos="24" access="rw" rst="0"> 
         <comment>KEYIN_3 force output value for output. </comment>
         </bits>
     <bits name="pad_KEYIN_3_out_reg" pos="20" access="rw" rst="0"> 
         <comment>KEYIN_3 pin output value. </comment>
         </bits>
     <bits name="pad_KEYIN_3_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_KEYIN_3_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>KEYIN_3 force outoen value. </comment>
         </bits>
     <bits name="pad_KEYIN_3_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>KEYIN_3 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_KEYIN_3_pull_up" pos="9" access="rw" rst="0"> 
         <comment>KEYIN_3 PUll up</comment>
         </bits>
     <bits name="pad_KEYIN_3_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>KEYIN_3 PUll down</comment>
         </bits>
     <bits name="pad_KEYIN_3_ana" pos="7:4" access="rw" rst="0"> 
         <comment>KEYIN_3 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_KEYIN_3_sel" pos="3:0" access="rw" rst="0"> 
         <comment>KEYIN_3 select</comment>
     <options>
            <option name="fun_KEYIN_3_sel" value ="0"></option>
            <option name="fun_GPIO_28_sel" value ="1"></option>
            <option name="fun_SEGOUT_11_sel" value ="4"></option>
            <option name="fun_DBG_DO_11_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_KEYIN_4_cfg" protect="rw">
     <bits name="pad_KEYIN_4_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>KEYIN_4 force enable for outoen. </comment>
         </bits>
     <bits name="pad_KEYIN_4_out_frc" pos="24" access="rw" rst="0"> 
         <comment>KEYIN_4 force output value for output. </comment>
         </bits>
     <bits name="pad_KEYIN_4_out_reg" pos="20" access="rw" rst="0"> 
         <comment>KEYIN_4 pin output value. </comment>
         </bits>
     <bits name="pad_KEYIN_4_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_KEYIN_4_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>KEYIN_4 force outoen value. </comment>
         </bits>
     <bits name="pad_KEYIN_4_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>KEYIN_4 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_KEYIN_4_pull_up" pos="9" access="rw" rst="0"> 
         <comment>KEYIN_4 PUll up</comment>
         </bits>
     <bits name="pad_KEYIN_4_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>KEYIN_4 PUll down</comment>
         </bits>
     <bits name="pad_KEYIN_4_ana" pos="7:4" access="rw" rst="0"> 
         <comment>KEYIN_4 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_KEYIN_4_sel" pos="3:0" access="rw" rst="0"> 
         <comment>KEYIN_4 select</comment>
     <options>
            <option name="fun_KEYIN_4_sel" value ="0"></option>
            <option name="fun_GPIO_29_sel" value ="1"></option>
            <option name="fun_SEGOUT_12_sel" value ="4"></option>
            <option name="fun_DBG_DO_12_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_KEYOUT_0_cfg" protect="rw">
     <bits name="pad_KEYOUT_0_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>KEYOUT_0 force enable for outoen. </comment>
         </bits>
     <bits name="pad_KEYOUT_0_out_frc" pos="24" access="rw" rst="0"> 
         <comment>KEYOUT_0 force output value for output. </comment>
         </bits>
     <bits name="pad_KEYOUT_0_out_reg" pos="20" access="rw" rst="0"> 
         <comment>KEYOUT_0 pin output value. </comment>
         </bits>
     <bits name="pad_KEYOUT_0_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_KEYOUT_0_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>KEYOUT_0 force outoen value. </comment>
         </bits>
     <bits name="pad_KEYOUT_0_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>KEYOUT_0 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_KEYOUT_0_pull_up" pos="9" access="rw" rst="0"> 
         <comment>KEYOUT_0 PUll up</comment>
         </bits>
     <bits name="pad_KEYOUT_0_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>KEYOUT_0 PUll down</comment>
         </bits>
     <bits name="pad_KEYOUT_0_ana" pos="7:4" access="rw" rst="0"> 
         <comment>KEYOUT_0 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_KEYOUT_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>KEYOUT_0 select</comment>
     <options>
            <option name="fun_KEYOUT_0_sel" value ="0"></option>
            <option name="fun_GPIO_30_sel" value ="1"></option>
            <option name="fun_SEGOUT_13_sel" value ="4"></option>
            <option name="fun_DBG_DO_13_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_KEYOUT_1_cfg" protect="rw">
     <bits name="pad_KEYOUT_1_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>KEYOUT_1 force enable for outoen. </comment>
         </bits>
     <bits name="pad_KEYOUT_1_out_frc" pos="24" access="rw" rst="0"> 
         <comment>KEYOUT_1 force output value for output. </comment>
         </bits>
     <bits name="pad_KEYOUT_1_out_reg" pos="20" access="rw" rst="0"> 
         <comment>KEYOUT_1 pin output value. </comment>
         </bits>
     <bits name="pad_KEYOUT_1_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_KEYOUT_1_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>KEYOUT_1 force outoen value. </comment>
         </bits>
     <bits name="pad_KEYOUT_1_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>KEYOUT_1 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_KEYOUT_1_pull_up" pos="9" access="rw" rst="0"> 
         <comment>KEYOUT_1 PUll up</comment>
         </bits>
     <bits name="pad_KEYOUT_1_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>KEYOUT_1 PUll down</comment>
         </bits>
     <bits name="pad_KEYOUT_1_ana" pos="7:4" access="rw" rst="0"> 
         <comment>KEYOUT_1 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_KEYOUT_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>KEYOUT_1 select</comment>
     <options>
            <option name="fun_KEYOUT_1_sel" value ="0"></option>
            <option name="fun_GPIO_31_sel" value ="1"></option>
            <option name="fun_SEGOUT_14_sel" value ="4"></option>
            <option name="fun_DBG_DO_14_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_KEYOUT_2_cfg" protect="rw">
     <bits name="pad_KEYOUT_2_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>KEYOUT_2 force enable for outoen. </comment>
         </bits>
     <bits name="pad_KEYOUT_2_out_frc" pos="24" access="rw" rst="0"> 
         <comment>KEYOUT_2 force output value for output. </comment>
         </bits>
     <bits name="pad_KEYOUT_2_out_reg" pos="20" access="rw" rst="0"> 
         <comment>KEYOUT_2 pin output value. </comment>
         </bits>
     <bits name="pad_KEYOUT_2_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_KEYOUT_2_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>KEYOUT_2 force outoen value. </comment>
         </bits>
     <bits name="pad_KEYOUT_2_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>KEYOUT_2 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_KEYOUT_2_pull_up" pos="9" access="rw" rst="0"> 
         <comment>KEYOUT_2 PUll up</comment>
         </bits>
     <bits name="pad_KEYOUT_2_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>KEYOUT_2 PUll down</comment>
         </bits>
     <bits name="pad_KEYOUT_2_ana" pos="7:4" access="rw" rst="0"> 
         <comment>KEYOUT_2 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_KEYOUT_2_sel" pos="3:0" access="rw" rst="0"> 
         <comment>KEYOUT_2 select</comment>
     <options>
            <option name="fun_KEYOUT_2_sel" value ="0"></option>
            <option name="fun_GPIO_32_sel" value ="1"></option>
            <option name="fun_SEGOUT_15_sel" value ="4"></option>
            <option name="fun_DBG_DO_15_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_KEYOUT_3_cfg" protect="rw">
     <bits name="pad_KEYOUT_3_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>KEYOUT_3 force enable for outoen. </comment>
         </bits>
     <bits name="pad_KEYOUT_3_out_frc" pos="24" access="rw" rst="0"> 
         <comment>KEYOUT_3 force output value for output. </comment>
         </bits>
     <bits name="pad_KEYOUT_3_out_reg" pos="20" access="rw" rst="0"> 
         <comment>KEYOUT_3 pin output value. </comment>
         </bits>
     <bits name="pad_KEYOUT_3_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_KEYOUT_3_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>KEYOUT_3 force outoen value. </comment>
         </bits>
     <bits name="pad_KEYOUT_3_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>KEYOUT_3 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_KEYOUT_3_pull_up" pos="9" access="rw" rst="0"> 
         <comment>KEYOUT_3 PUll up</comment>
         </bits>
     <bits name="pad_KEYOUT_3_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>KEYOUT_3 PUll down</comment>
         </bits>
     <bits name="pad_KEYOUT_3_ana" pos="7:4" access="rw" rst="0"> 
         <comment>KEYOUT_3 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_KEYOUT_3_sel" pos="3:0" access="rw" rst="0"> 
         <comment>KEYOUT_3 select</comment>
     <options>
            <option name="fun_KEYOUT_3_sel" value ="0"></option>
            <option name="fun_GPIO_33_sel" value ="1"></option>
            <option name="fun_SEGOUT_16_sel" value ="4"></option>
            <option name="fun_DBG_CLK_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_KEYOUT_4_cfg" protect="rw">
     <bits name="pad_KEYOUT_4_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>KEYOUT_4 force enable for outoen. </comment>
         </bits>
     <bits name="pad_KEYOUT_4_out_frc" pos="24" access="rw" rst="0"> 
         <comment>KEYOUT_4 force output value for output. </comment>
         </bits>
     <bits name="pad_KEYOUT_4_out_reg" pos="20" access="rw" rst="0"> 
         <comment>KEYOUT_4 pin output value. </comment>
         </bits>
     <bits name="pad_KEYOUT_4_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_KEYOUT_4_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>KEYOUT_4 force outoen value. </comment>
         </bits>
     <bits name="pad_KEYOUT_4_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>KEYOUT_4 force enable for pu/pd </comment>
         </bits>
     <bits name="pad_KEYOUT_4_pull_up" pos="9" access="rw" rst="0"> 
         <comment>KEYOUT_4 PUll up</comment>
         </bits>
     <bits name="pad_KEYOUT_4_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>KEYOUT_4 PUll down</comment>
         </bits>
     <bits name="pad_KEYOUT_4_ana" pos="7:4" access="rw" rst="0"> 
         <comment>KEYOUT_4 ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_KEYOUT_4_sel" pos="3:0" access="rw" rst="0"> 
         <comment>KEYOUT_4 select</comment>
     <options>
            <option name="fun_KEYOUT_4_sel" value ="0"></option>
            <option name="fun_GPIO_34_sel" value ="1"></option>
            <option name="fun_SEGOUT_17_sel" value ="4"></option>
            <option name="fun_HST_CLK_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_HST_RXD_cfg" protect="rw">
     <bits name="pad_HST_RXD_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>HST_RXD force enable for outoen. </comment>
         </bits>
     <bits name="pad_HST_RXD_out_frc" pos="24" access="rw" rst="0"> 
         <comment>HST_RXD force output value for output. </comment>
         </bits>
     <bits name="pad_HST_RXD_out_reg" pos="20" access="rw" rst="0"> 
         <comment>HST_RXD pin output value. </comment>
         </bits>
     <bits name="pad_HST_RXD_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_HST_RXD_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>HST_RXD force outoen value. </comment>
         </bits>
     <bits name="pad_HST_RXD_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>HST_RXD force enable for pu/pd </comment>
         </bits>
     <bits name="pad_HST_RXD_pull_up" pos="9" access="rw" rst="0"> 
         <comment>HST_RXD PUll up</comment>
         </bits>
     <bits name="pad_HST_RXD_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>HST_RXD PUll down</comment>
         </bits>
     <bits name="pad_HST_RXD_ana" pos="7:4" access="rw" rst="0"> 
         <comment>HST_RXD ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_HST_RXD_sel" pos="3:0" access="rw" rst="0"> 
         <comment>HST_RXD select</comment>
     <options>
            <option name="fun_HST_RXD_sel" value ="0"></option>
            <option name="fun_GPIO_35_sel" value ="1"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
  <reg name="pad_HST_TXD_cfg" protect="rw">
     <bits name="pad_HST_TXD_oen_frc" pos="28" access="rw" rst="0"> 
         <comment>HST_TXD force enable for outoen. </comment>
         </bits>
     <bits name="pad_HST_TXD_out_frc" pos="24" access="rw" rst="0"> 
         <comment>HST_TXD force output value for output. </comment>
         </bits>
     <bits name="pad_HST_TXD_out_reg" pos="20" access="rw" rst="0"> 
         <comment>HST_TXD pin output value. </comment>
         </bits>
     <bits name="pad_HST_TXD_drv_strength" pos="19:18" access="rsv" rst="0"> 
         <comment>not used as driving strength. </comment>
         </bits>
     <bits name="pad_HST_TXD_oen_reg" pos="17" access="rw" rst="0"> 
         <comment>HST_TXD force outoen value. </comment>
         </bits>
     <bits name="pad_HST_TXD_pull_frc" pos="16" access="rw" rst="0"> 
         <comment>HST_TXD force enable for pu/pd </comment>
         </bits>
     <bits name="pad_HST_TXD_pull_up" pos="9" access="rw" rst="0"> 
         <comment>HST_TXD PUll up</comment>
         </bits>
     <bits name="pad_HST_TXD_pull_dn" pos="8" access="rw" rst="0"> 
         <comment>HST_TXD PUll down</comment>
         </bits>
     <bits name="pad_HST_TXD_ana" pos="7:4" access="rw" rst="0"> 
         <comment>HST_TXD ANA_Alter_SEL</comment>
         </bits>
     <bits name="pad_HST_TXD_sel" pos="3:0" access="rw" rst="0"> 
         <comment>HST_TXD select</comment>
     <options>
            <option name="fun_HST_TXD_sel" value ="0"></option>
            <option name="fun_GPIO_36_sel" value ="1"></option>
            <mask/><shift/><default/>
     </options>
         </bits>
         </reg>
   </module>
</archive>


<archive relative = "itlv.xml">

<include file="globals.xml"/>

<module name="itlv" category="Baseband">
  <reg name="command" protect="rw">
    <bits access="rw" name="nb_bits" pos="30:20" rst="0x0">
      <comment>Number of bits to be (De)Interleaved.</comment>
    </bits>

    <bits access="rw" name="burst_offset" pos="12:8" rst="0x0">
      <comment>This value gives the write offset (in number of bursts) to be
      added to a Burst Base address (ignored for Type 1b). For normal
      operation, this offset should be even (lsb will be ignored).</comment>
    </bits>

    <bits access="rw" name="itlv_type" pos="7:4" rst="0x0">
      <comment>Selects (de-)interleaving type.</comment>
            <options>
                <option name="TYPE_1A" value="0">
                    <comment>TCH/FS, TCH/EFS, FACCH/F, TCH/F2.4, TCH/AFS (speech, ratscch, sid_first)</comment>
                </option>
                <option name="TYPE_1B" value="1">
                    <comment>SACCH, TCH/AFS(sid_update), PDTCH(CS-1 to CS-4), BCCH, PCH, AGCH, PACCH, PBCCH, PAGCH, PPCH, PNCH, PTCCH/D</comment>
                </option>
                <option name="TYPE_1C" value="2">
                    <comment>FACCH/H</comment>
                </option>
                <option name="TYPE_2A" value="3">
                    <comment>TCH/HS and TCH/AHS</comment>
                </option>
                <option name="TYPE_2B" value="4">
                    <comment>TCH/HS and TCH/AHS</comment>
                </option>
                <option name="TYPE_3" value="5">
                    <comment>TCH/F14.4, TCH/F9.6, TCH/F4.8, TCH/H4.8, and TCH/H2.4</comment>
                </option>
                <default/>
                <mask/>
                <shift/>
            </options>
    </bits>

    <bits access="rw" name="int_mask" pos="3" rst="0x0">
      <comment>Sets the interrupt mask ('1': interruption enabled)</comment>
    </bits>

    <bits access="rw" name="ditlv_start" pos="1" rst="0x0">
      <comment>Starts the de-interleaving process.</comment>
    </bits>

    <bits access="rw" name="itlv_start" pos="0" rst="0x0">
      <comment>Starts the interleaving process.</comment>
    </bits>
  </reg>

  <reg name="status" protect="r">
    <bits access="r" name="busy" pos="0" rst="0x0">
      <comment>This bit is high when a (de-)interleaving process is ongoing. It
      stays high if the module is stalled during operation.</comment>
    </bits>
  </reg>

  <reg name="burst_base" protect="rw">
    <bits access="rw" name="burst_base" pos="BB_SRAM_ADDR_WIDTH+1:4" rst="0x0">
      <comment>This is the start address of the burst buffer in SRAM
      </comment>
    </bits>
  </reg>

  <reg name="frame_base" protect="rw">
    <bits access="rw" name="frame_base" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>This is the start address of the frame buffer in
      SRAM.</comment>
    </bits>
  </reg>

  <reg name="int_status" protect="r">
    <bits access="r" name="it_status" pos="16" rst="0x0">
      <comment>This bit is the unmasked version of the IT_CAUSE bit.</comment>
    </bits>

    <bits access="r" name="it_cause" pos="0" rst="0x0">
      <comment>This bit is set when the ITLV module finishes an ongoing
      operation. It can be masked by setting ITLV_CMD(IT_MASK) to '1'.
      Resetting this bit is done by writing in IT_CLEAR register. IT_CAUSE is
      the image of the ITLV_DONE_H interrupt line to the CPU. </comment>
    </bits>
  </reg>

  <reg name="int_clear" protect="w">
    <bits access="w" name="it_clear" pos="0" rst="0x0">
      <comment>Setting this bit to '1' resets the Interleaver's
      interrupt.</comment>
    </bits>
  </reg>
</module>

</archive>

<archive relative = "keypad.xml">
<module name="keypad" category="Periph">
  <var name="KEY_NB" value="64">
    <comment> Number of key in the keypad
    </comment>
  </var>
  <var name="LOW_KEY_NB" value="32">
    <comment> Number of key in the low data register 
    </comment>
  </var>
  <var name="HIGH_KEY_NB" value="32">
    <comment> Number of key in the high data register
    </comment>
  </var>

  <reg protect="r" name="KP_DATA_L">
    <bits access="r" name="KP_DATA_L" pos="31:0" rst="0">
      <comment>For keys in column Idx_KeyOut(from 0 to 3) and in line Idx_KeyIn(from 0 to 7), the pressing status are stored in KP_DATA_L(Idx_KeyOut*8+Idx_KeyIn) :<br />0 = Released<br />1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
    </bits>

  </reg>

  <reg protect="r" name="KP_DATA_H">
    <bits access="r" name="KP_DATA_H" pos="31:0" rst="0">
      <comment>For keys in column Idx_KeyOut(from 4 to 7) and line Idx_KeyIn(from 0 to 7), the pressing status are stored in KP_DATA_H(Idx_KeyIn*8-32+Idx_KeyIn):<br />0 = Released<br />1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
    </bits>

  </reg>

  <reg protect="r" name="KP_STATUS">

    <bits access="r" name="KEYIN_STATUS" pos="7:0" rst="0x08">
      <comment>For keys in lines status <br />0 = Released<br />1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
  </bits>

    <bits access="r" name="KP_ON" pos="31" rst="0">
      <comment>Indicate Key ON pressing status :<br />0 = Release<br />1 = Pressed
      </comment>
      <options><default/><mask/><shift/></options>
    </bits>

  </reg>

  
  <reg protect="rw" name="KP_CTRL">
    <bits access="rw" name="KP_En" pos="0" rst="0">
        <comment>This bit enables key detection. If this bit is '0', the key detection function 
            is disabled. Key ON is an exception, it can be still detected and generate key interrupt
            even if KP_En = '0', however in this case, the debouncing time configuration in key
            control register is ignored and the key ON state is considerred to be stable if it keeps
            same in consecutive 2 cycles of 16KHz clock.<br />
        <br />0 = keypad disable<br />1 = keypad enable  
      </comment>
    </bits>
   
    <bits access="rw" name="KP_DBN_Time" pos="9:2" rst="0">
      <comment>De-bounce time = (KP_DBN_TIME + 1) * SCAN_TIME, SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_DBN_TIME = 7, KP_OUT_MASK = "111111", then De-bounce time = (7+1)*0.3125*6=15 ms. The maximum debounce time is 480 ms.
      </comment>
    </bits>

   <bits access="rw" name="KP_ITV_Time" pos="15:10" rst="0">
      <comment>Configure interval of generating an IRQ if one key or several keys are pressed long time. Interval of IRQ generation = (KP_ITV_Time + 1) * (KP_DBN_TIME + 1) * SCAN_TIME. SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_ITV_TIME = 7, KP_DBN_TIME = 7, KP_OUT_MASK = "111111", then De-bounce time = (7+1)*(7+1)*0.3125*6=120 ms. 
      </comment>
    </bits>
    
    <bits access="rw" name="KP_IN_MASK" pos="23:16" rst="0xff">
        <comment>each bit masks one input lines.<br />
            '1' = enabled <br /> '0' = disabled
            
            <br/>The Key In pins 0 to 5 are muxed with the boot mode pins, latched during Reset.
                <br/> Key_In 0: BOOT_MODE_NO_AUTO_PU.
                <br/> Key_In 1: BOOT_MODE_FORCE_MONITOR.
                <br/> Key_In 2: BOOT_MODE_UART_MONITOR_ENABLE.
                <br/> Key_In 3: BOOT_MODE_USB_MONITOR_DISABLE.
                <br/> Key_In 4: reserved

        </comment>
    </bits>

    <bits access="rw" name="KP_OUT_MASK" pos="31:24" rst="0xff">
        <comment>each bit masks one output lines.<br />
            '1' = enabled <br /> '0' = disabled </comment>
    </bits>

  </reg>

  <reg protect="rw" name="KP_IRQ_MASK">
    <bits access="rw" name="KP_EVT0_IRQ_MASK" pos="0" rst="0">
      <comment>This bit mask keypad irq generated by event0 (key press or key release event, not including all keys release event which is event1). 
        <br />0 = keypad event irq disable<br />1 = keypad event irq enable  
      </comment>
    </bits>
    
    <bits access="rw" name="KP_EVT1_IRQ_MASK" pos="1" rst="0">
      <comment>This bit mask keypad irq generated by event1 (all keys release event). 
        <br />0 = keypad event irq disable<br />1 = keypad event irq enable  
      </comment>
    </bits>
    
    <bits access="rw" name="KP_ITV_IRQ_MASK" pos="2" rst="0">
      <comment>This bit mask keypad irq generated by key pressed long time (generated each interval configured in KP_ITV_Time. 
        <br />0 = keypad interval irq disable<br />1 = keypad interval irq enable  
      </comment>
    </bits>

  </reg>

  <reg protect="r" name="KP_IRQ_CAUSE">
    <bits access="r" name="KP_EVT0_IRQ_CAUSE" pos="0" rst="0">
      <comment>keypad event0(key press or key release event, not including all keys release which is event1) IRQ cause. 
      </comment>
    </bits>

    <bits access="r" name="KP_EVT1_IRQ_CAUSE" pos="1" rst="0">
      <comment>keypad event1(all keys release event) IRQ cause. 
      </comment>
    </bits>

    <bits access="r" name="KP_ITV_IRQ_CAUSE" pos="2" rst="0">
      <comment>keypad interval irq cause. 
      </comment>
    </bits>
    
    <bits access="r" name="KP_EVT0_IRQ_STATUS" pos="16" rst="0">
      <comment>keypad event0(key press or key release event, not including all keys release which is event1) irq status. 
      </comment>
    </bits>

    <bits access="r" name="KP_EVT1_IRQ_STATUS" pos="17" rst="0">
      <comment>keypad event1(all keys release event) irq status. 
      </comment>
    </bits>
  
    <bits access="r" name="KP_ITV_IRQ_STATUS" pos="18" rst="0">
      <comment>keypad interval irq status. 
      </comment>
    </bits>

  </reg>
  
  <reg protect="rw" name="KP_IRQ_CLR">
    <bits access="c" name="KP_IRQ_CLR" pos="0" rst="0">
      <comment>Write '1' to this bit clears key IRQ. </comment>
    </bits>
  </reg>

</module>
</archive>
<archive relative = "mem_bridge.xml">

<include file="globals.xml"/>
<include file="gallite_generic_config.xml"/>

    <var    name="EBC_NB_BITS_CS" value="3" />
    <var    name="EBC_NB_CS" value="5" /> 
    <var    name="FIRST_CS_WITH_POLARITY" value="2" />

    <var    name="NB_BITS_EXTADDR" value="EBC_NB_BITS_ADDR+1" /> 

    <var    name="NB_BITS_MAXSPACE" value="25" />
    <var    name="NB_BITS_CS4" value="23" />
    <var    name="EBC_CS0_SIZE" value="exp2(NB_BITS_MAXSPACE)" /> 
    <var    name="EBC_CS1_SIZE" value="exp2(NB_BITS_MAXSPACE-1)" /> 
    <var    name="EBC_CS2_SIZE" value="exp2(19)" /> 
    <var    name="EBC_CS3_SIZE" value="exp2(18)" /> 
    <var    name="EBC_CS4_SIZE" value="exp2(NB_BITS_CS4)" /> 
    
    <var    name="INT_RAM_NB_BITS" value="17" /> 
    <var    name="INT_RAM_NB_BLOCK" value="MEMBRIDGE_RAM_NB_BLOCK" /> 
    <var    name="INT_RAM_SIZE" value="32768*INT_RAM_NB_BLOCK" /> 

    <var    name="INT_ROM_NB_BITS" value="17" /> 
    <var    name="INT_ROM_SIZE" value="80*1024" /> 

    <var    name="NB_BIT_ROM_PACHT" value="4" />
    <var    name="NB_ROM_PACHT" value="16" />
    <var    name="BCPU_ROM_SIZE" value="32*1024*3" /> 


<module name="mem_bridge" category="System">

    
    <reg name="FIFO_Ctrl" protect="rw">
        <bits name="Lock"         pos="0"     access="rw" rst="0">
            <comment>Lock mode: when locked the FIFO only accept requests from the XCPU, other masters receive the Split response until the lock mode is disabled. (If blocked in debug, use host internal reg reset+xcpu hold).

            </comment>
            <options>
                <option name="Enable" value="1"/>
                <option name="Disable" value="0"/>
            </options>
        </bits>
        <bits name="AHB_Cmd_Full_Shift"  pos="4" access="rw" rst="0">
            <comment>In order to solve the possible AHBC arbitration bug, a delay is put to the AHB_Cmd_Full signal. 
By default, when a slot is freed in the FIFO a master can come and take this slot before the previously splitted masters are even unsplitted.
There is a 5 clock delay between the freed spot and the HSLIT signal that this shifter will compentiate only when a slot is freed 
(falling edge of AHB_Cmd_Full) not when the FIFO is full (rising edge of AHB_Cmd_Full).

This option has to be set as well as the New arbitration feature in the AHBC module in order be effective.
            </comment>
            <options>
                <option name="Enable" value="0"/>
                <option name="Disable" value="1"/>
            </options>
        </bits>
    </reg>
    <reg name="FIFO_Status" protect="rw">
        <bits name="FIFO_A_Level"      pos="5:4"     access="r" rst="0">
            <comment>Number of requests pending in System fifo.
            </comment>
            <options><default/><mask/><shift/></options>
        </bits>
        <bits name="FIFO_B_Level"      pos="9:8"     access="r" rst="0">
            <comment>Number of requests pending in Baseband FIFO
            </comment>
            <options><default/><mask/><shift/></options>
        </bits>
    </reg>
    <reg name="Monitor_Ctrl" protect="rw">
        <bits name="Monitor_Sel"    pos="0"     access="rw" rst="0">
            <comment>Monitor signal selection
            </comment>
            <options>
                <option name="Side_by_Side" value="0"><comment>Select FIFO Data access used by each side</comment></option>
                <option name="Data_vs_External" value="1"><comment>Select FIFO Data used by both side against Cycle used on External interface</comment></option>
            </options>
        </bits>
    </reg>

    
    <reg name="Rom_Bist" protect="rw">
        <bits name="Ctrl"    pos="0"     access="rw" rst="0">
            <comment>Write 1 to start the CRC Computation on the Rom, Read to get the status
            </comment>
            <options>
                <option name="Done" value="0"/>
                <option name="Running" value="1"/>
            </options>
        </bits>
        <bits name="CRC"    pos="31:16" access="r"  rst="0">
            <comment>The Computed CRC
            </comment>
        </bits>
    </reg>
    <reg name="SRam_Bist" protect="rw">
        <bits name="Ctrl"    pos="0"     access="w" rst="0">
            <comment>Write 1 to start the BIST on the selected SRam block, Read to get the status
            </comment>
            <options>
                <option name="Done" value="0"/>
                <option name="Running" value="1"/>
            </options>
          </bits>
        <bits name="P_status"  pos="3"  access="rw" rst="0">
            <comment>The Bock of 32k on which to run the March C- algorithm
            </comment>
        </bits>
        <bits name="Block_Sel"  pos="INT_RAM_NB_BITS-1:15"  access="rw" rst="0">
            <comment>The Bock of 32k on which to run the March C- algorithm
            </comment>
        </bits>
        <bits name="Status"    pos="31" access="r"  rst="0">
            <comment>The Bist Status (valid when Done)
            </comment>
            <options>
                <option name="Bad" value="1"/>
                <option name="OK" value="0"/>
            </options>
        </bits>
    </reg>

    <hole size="1888"/> 

    
    <reg name="Rom_Patch" count="NB_ROM_PACHT" protect="rw">
        <bits name="block_addr" pos="INT_RAM_NB_BITS-1:4" rst = "0">
            <comment>Base address of block in int_Rom patched (corresponding data are read from int_SRam)
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Patch"  pos="31"    access="rw" rst="0">
            <options>
                <option name="Enable" value="1"/>
                <option name="Disable" value="0"/>
            </options>
        </bits>
    </reg>
    
 
    <hole size="1536"/> 
    
    <hole size="2048"/>
    <hole size="2048"/>

    
    <reg name="EBC_Ctrl" protect="rw">
        <bits name="Enable"         pos="0"     access="rw" rst="1">
            <comment>Enable the ebc
                <br/>1 = Enable
                <br/>0 = Disable (will finish current transfer anyway)
            </comment>
        </bits>
        <bits name="IdleDrive"      pos="12"    access="rw" rst="0">
            <comment>This bit select wether (1) or not (0) the EBC drives the data bus lines during idle (ie: between tranfers)
            </comment>
        </bits>
    </reg>
    <reg name="EBC_Status" protect="r">
        <bits name="Enable"         pos="0"     access="r" rst="1">
            <comment>Enable status of the module (as reading EBC_Ctrl will return the written value)
            </comment>
        </bits>
        <bits name="Update_CS"      pos="4"     access="r" rst="0">
            <comment>This bit shows that a CS update is in progress. It reads as 1 when a chip select register has been written but not yet updated in the actual configuration. This is to ensure the configuration does not change during an access.
            </comment>
        </bits>
    </reg>
    <hole size="32"/> 
    <reg name="CS_Time_Write" protect="rw">
        <comment>This register is used to program the CS_Time register of One CS_Config at the same time as the CS_Mode regiter is set (so the two registers are always synchronized with each other).
            <br/>To update Chip Select n configuration, first write the timing value in this register, then write the CS_Mode configuration in the corresponding CS_Config[n].CS_Mode.
        </comment>
        <bits name="RdLatHalfMode" pos="0" access="rw" rst="1">
            <comment>Read access Latency Half cycle Mode:
                <br/>when 1 reduce the cycle latency by half a cycle between 2 consecutive half word access.
                <br/>In burst mode, when 1 extend the cycle latency by half a cycle for all half word access.
            </comment>
        </bits>
        <bits name="RdLat" pos="5:1" access="rw" rst="all1">
            <comment>Read access Latency: Access time for read.
                <br/>Access time in clock cycle is the value of this field +1.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="OEDlyHalfMode" pos="8" access="rw" rst="1">
            <comment>Chip select to Output enable Setup half mode:
                <br/>1 add one half cycle to the time
            </comment>
        </bits>
        <bits name="OEDly" pos="11:9" access="rw" rst="all1">
            <comment>Chip select to Output enable Setup time:
                <br/>The time in clock cycle is the value of this field.

            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="PageLat" pos="15:13" access="rw" rst="all1">
            <comment>Page mode Latency value: Page mode access time (for read or write page mode)
                <br/>Access time in clock cycle is the value of this field +1.
                <br/>Note: if Half cycle mode is enabled it also applies to the page mode.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="WrLatHalfMode" pos="16" access="rw" rst="1">
            <comment>Write access Latency Half cycle Mode:
                <br/>when 1 reduce the cycle latency by half a cycle between 2 consecutive half word access.
            </comment>
        </bits>
        <bits name="WrLat" pos="21:17" access="rw" rst="all1">
            <comment>Write access Latency: Access time for write.
                <br/>Access time in clock cycle is the value of this field +1.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="WEDlyHalfMode" pos="24" access="rw" rst="1">
            <comment>Chip select to Write enable Setup half mode:
                <br/>1 add one half cycle to the time
            </comment>
        </bits>
        <bits name="WEDly" pos="27:25" access="rw" rst="all1">
            <comment>Chip select to Write enable Setup time:
                <br/>The time in clock cycle is the value of this field.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="Relax" pos="30:28" access="rw" rst="all1">
            <comment>Relaxation delay between sequence of access (all read or all write) to the same chip select and any new sequence or idle state.
                <br/>The delay in number of clock cycle is the value of this field.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="ForceRelax" pos="31" access="rw" rst="1">
            <comment>Force Relaxation cycles to be inserted between any access. (same page or same burst consecutive access are considered a single access)
            </comment>
        </bits>
    </reg>
    <struct name="CS_Config" count="EBC_NB_CS">
        <reg name="CS_Mode" protect="rw">
            <comment>Writing this register will also copy the content of CS_Time_Write to the CS_Time register.
            </comment>
            <bits name="CSEn" pos="0" access="rw" rst="1">
                <comment>Enable the chip select.
                </comment>
            </bits>
            <bits name="Polarity" pos="1" access="w" rst="0">
                <comment>Chip Select polarity: 1 active High, '0' active Low.
                    <br/>CS0 and CS1 are always active low (0) so this bit is not writable for them.
                </comment>
                <options>
                    <option name="ActiveHigh" value="1"/>
                    <option name="ActiveLow" value="0"/>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="ADMuxMode" pos="2" access="rw" rst="0">
                <comment>1 use Address/Data Mux for 16 lower address bits.
                </comment>
            </bits>
            <bits name="WriteAllow" pos="4" access="rw" rst="0">
                <comment>1 to allow write, else a write to the memory of this chip select will be dropped from the controller without notice.
                </comment>
            </bits>
            <bits name="WBEMode" pos="5" access="rw" rst="0">
                <comment>1 to use BE as WE for each byte (to use two 8bits chips)
                </comment>
            </bits>
            <bits name="BEDlyMode" pos="6" access="rw" rst="0">
                <comment>0: BE active after OEDly/WEDly
                    <br/>1: BE active during full access
                </comment>
            </bits>
            <bits name="WaitMode" pos="8" access="rw" rst="0">
                <comment>1 to use the wait input to delay end of a read access.
                    <br/>(RdLat min 4)
                </comment>
            </bits>
            <bits name="WriteWaitMode" pos="9" access="rw" rst="0">
                <comment>1 to use the wait input to delay end of a write access.
                    <br/>(WrLAt min 4)
                </comment>
            </bits>
            <bits name="PageSize" pos="14:12" access="rw" rst="all1">
                <options>
                    <option name="4HW" value="0"><comment>4 half words </comment></option>
                    <option name="8HW" value="1"><comment>8 half words </comment></option>
                    <option name="16HW" value="2"><comment>16 half words </comment></option>
                    <option name="32HW" value="3"><comment>32 half words </comment></option>
                    <option name="64HW" value="4"><comment>64 half words </comment></option>
                    <option name="128HW" value="5"><comment>128 half words </comment></option>
                    <option name="256HW" value="6"><comment>256 half words </comment></option>
                    <option name="FULL" value="7"><comment>Full page (in burst mode, else reserved)</comment></option>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
                <comment>Page size for page or bursts access.
                </comment>
            </bits>
            <bits name="PageMode" pos="16" access="rw" rst="0">
                <comment>1 enable page mode for read access:
                    <br/>only address changes, chip select keeps enabled while address keeps in a page (defined by PageSize). 
                </comment>
            </bits>
            <bits name="WritePageMode" pos="17" access="rw" rst="0">
                <comment>1 enable page mode for write access.
                </comment>
            </bits>
            <bits name="BurstMode" pos="20" access="rw" rst="0">
                <comment>1 enable burst mode for read access.
                    <br/>Use PageSize.
                    <br/>Require the use of the M_ADV and M_CLK pins.
                </comment>
            </bits>
            <bits name="WriteBurstMode" pos="21" access="rw" rst="0">
                <comment>1 enable burst mode for write access.
                </comment>
            </bits>
            <bits name="ADVAsync" pos="24" access="rw" rst="0">
                <comment>1 the M_ADV pin is low only during the first cycle of an asynchronous access (for asynchronous modes on burst capable chips)
                </comment>
            </bits>
            <bits name="ADVWEPulse" pos="25" access="rw" rst="0">
                <comment>1 the M_WE is valid only during the M_ADV pulse.
                </comment>
            </bits>
            <bits name="ADMuxDly" pos="27:26" access="rw" rst="0">
                <comment>Address/Data Mux timing
                </comment>
                <options>
                    <option name="normal" value="0"><comment>ADV signal as in burst mode</comment></option>
                    <option name="F1" value="1"><comment>ADV signal fall a half cycle after CS for 1 cycle</comment></option>
                    <option name="F1_5" value="2"><comment>ADV signal fall a half cycle after CS for 1.5 cycle</comment></option>
                    <option name="F2" value="3"><comment>ADV signal fall a half cycle after CS for 2 cycle</comment></option>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="WriteSingle" pos="28" access="rw" rst="0">
                <comment>1 the Write Burst mode PageSize is replaced by 1 to do synchronous single write access. (while PageSize is still used for Read burst access)
                </comment>
            </bits>
            <bits name="WriteHold" pos="29" access="rw" rst="1">
                <comment>1 the data remains driven during Relaxation time.
                </comment>
            </bits>
        </reg>
        <reg name="CS_Time" protect="r">
            <comment>This register cannot be written direclty. To update it, write to the CS_Time_write register, then to the CS_Mode register.
            </comment>
            <bits name="RdLatHalfMode" pos="0" access="r" rst="0">
                <comment>Read access Latency Half cycle Mode:
                    <br/>when 1 reduce the cycle latency by half a cycle between 2 consecutive half word access.
                    <br/>In burst mode, when 1 extend the cycle latency by half a cycle for all half word access.
                </comment>
            </bits>
            <bits name="RdLat" pos="5:1" access="r" rst="all1">
                <comment>Read access Latency: Access time for read.
                    <br/>Access time in clock cycle is the value of this field +1.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="OEDlyHalfMode" pos="8" access="r" rst="0">
                <comment>Chip select to Output enable Setup half mode:
                    <br/>1 add one half cycle to the time
                </comment>
            </bits>
            <bits name="OEDly" pos="11:9" access="r" rst="all1">
                <comment>Chip select to Output enable Setup time:
                    <br/>The time in clock cycle is the value of this field.

                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="PageLat" pos="15:13" access="r" rst="all1">
                <comment>Page mode Latency value: Page mode access time (for read or write page mode)
                    <br/>Access time in clock cycle is the value of this field +1.
                    <br/>Note: if Half cycle mode is enabled it also applies to the page mode.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="WrLatHalfMode" pos="16" access="r" rst="1">
                <comment>Write access Latency Half cycle Mode:
                    <br/>when 1 reduce the cycle latency by half a cycle between 2 consecutive half word access.
                </comment>
            </bits>
            <bits name="WrLat" pos="21:17" access="r" rst="all1">
                <comment>Write access Latency: Access time for write.
                    <br/>Access time in clock cycle is the value of this field +1.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="WEDlyHalfMode" pos="24" access="r" rst="1">
                <comment>Chip select to Write enable Setup half mode:
                    <br/>1 add one half cycle to the time
                </comment>
            </bits>
            <bits name="WEDly" pos="27:25" access="r" rst="all1">
                <comment>Chip select to Write enable Setup time:
                    <br/>The time in clock cycle is the value of this field.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="Relax" pos="30:28" access="r" rst="all1">
                <comment>Relaxation delay between sequence of access (all read or all write) to the same chip select and any new sequence or idle state. (burst reaching end of page in non Full Page mode also insert a Relaxation delay)
                    <br/>The delay in number of clock cycle is the value of this field.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="ForceRelax" pos="31" access="r" rst="1">
                <comment>Force Relaxation cycles to be inserted between any access. (same page or same burst consecutive access are considered a single access)
                </comment>
            </bits>
        </reg>
    </struct>
    <hole size="1600"/> 

    
    <reg name="AHBM_Ctrl" protect="rw">
        <bits name="Enable"         pos="0"     access="rw" rst="1">
            <comment>Enable the AHB Master
                <br/>1 = Enable
                <br/>0 = Disable (will finish current transfer anyway)
            </comment>
        </bits>
    </reg>
    <reg name="AHBM_Status" protect="r">
        <bits name="Enable"         pos="0"     access="r" rst="1">
            <comment>Enable status of the module (as reading AHBM_Ctrl will return the written value)
            </comment>
        </bits>
        <bits name="Update_SB"      pos="4"     access="r" rst="0">
            <comment>This bits shows that a SpaceBase update is in progress. It reads as 1 when a SpaceBase register has been written but not yet updated in the actual configuration. This is to ensure the configuration does not change during an access.
            </comment>
        </bits>
    </reg>
    <hole size="64"/>
    <reg name="SpaceBase" protect="rw" count="EBC_NB_CS">
        <bits name="BaseAddr" pos="31:4" access="rw" rst="all1" display="hex">
            <comment>Base address added to the lower bits of address from FIFO.
            </comment>
        </bits>
    </reg>


</module>


<module name="mem_FIFO" category="System">

    <reg name="Flush" protect="rw">
        <comment>Reading this register ensure the previous write command are all done (any read would do anyway) but this does not access external controller. When changing CS Config it will only work if the baseband is off (boot...) ! Poll CS_Update in reg CS Status instead.
        </comment>
        <bits name="Flush"         pos="0"     access="r" rst="0">
        </bits>
    </reg>
    <reg name="EBC_CRE" protect="rw">
        <bits name="CRE"         pos="0"     access="rw" rst="0">
            <comment>Write here the desired state of the M_CRE pin. 
                <br/>As this register is placed in the FIFO with the memory commands, it ensure the sequence of memory access and change to this register will be kept in sequence.
            </comment>
        </bits>
    </reg>
    <reg name="EBC_CS4_Block_Remap" protect="rw">
        <bits name="Block_Remap"         pos="NB_BITS_EXTADDR-2:NB_BITS_CS4"     access="rw" rst="all0">
            <comment>When the CS4 is accessed the adress is extended by the bits in this register and the MSB is set to 1.
                <br/>As this register is placed in the FIFO with the memory commands, it ensure the sequence of memory access and change to this register will be kept in order.
            </comment>
            <options><default/><mask/><shift/></options>
        </bits>
    </reg>
    <reg name="Side_Id" protect="r">
        <bits name="Side_Id"         pos="0"     access="r" rst="no">
            <comment>Read as 0 on System side, as 1 on BaseBand Side.
            </comment>
            <options>
                <option name="System" value="0"/>
                <option name="Baseband" value="1"/>
            </options>
        </bits>
    </reg>
</module>

<module name="ebc_cs0" category="System">
    <memory name="ram_array" size="EBC_CS0_SIZE">
        <comment>EBC Chip select 0 memory space.
            <br/>Space accessed by M_CS_0 line.
            <br/>This chip select is dedicated to Flash access, the CPU will boot from here.
        </comment>
    </memory>
</module>
<module name="ebc_cs1" category="System">
    <memory name="ram_array" size="EBC_CS1_SIZE">
        <comment>EBC Chip select 1 memory space.
            <br/>Space accessed by M_CS_1 line.
            <br/>This chip select is dedicated to ram access.
        </comment>
    </memory>
</module>
<module name="ebc_cs2" category="System">
    <memory name="ram_array" size="EBC_CS2_SIZE">
        <comment>EBC Chip select 2 memory space.
            <br/>Space accessed by M_CS_2 line
        </comment>
    </memory>
</module>
<module name="ebc_cs3" category="System">
    <memory name="ram_array" size="EBC_CS3_SIZE">
        <comment>EBC Chip select 3 memory space.
            <br/>Space accessed by M_CS_3 line
        </comment>
    </memory>
</module>
<module name="ebc_cs4" category="System">
    <memory name="ram_array" size="EBC_CS4_SIZE">
        <comment>EBC Chip select 4 memory space.
            <br/>Space accessed by M_CS_4 line
        </comment>
    </memory>
</module>


<module name="int_sram" category="System">
    <memory name="sram_array" size="INT_RAM_SIZE">
        <comment>Internal SRam Space
        </comment>
    </memory>
</module>

<module name="bb_patch" category="System">  </module>


<module name="int_rom" category="System">
    <memory name="rom_array" size="INT_ROM_SIZE">
        <comment>Internal Rom Space
            <br/>This rom is used for boot code.
        </comment>
    </memory>
</module>

<module name="bcpu_rom" category="System">
    <memory name="rom_array" size="BCPU_ROM_SIZE">
        <comment>Internal Rom Space
            <br/>This rom is used for boot code.
        </comment>
    </memory>
</module>


</archive>


<archive relative = "page_spy.xml">

<include file="globals.xml"/>


<module name="page_spy" category="Debug">

  <var name="PAGE_SPY_NB_PAGE" value="16"/>

  <reg protect="rw" name="enable">
    <bits access="rs" name="enable_page" pos="PAGE_SPY_NB_PAGE-1:0" rst="0" cut="1" cutprefix="enable_page">
      <comment>Writing '1' enable the page (n), writing '0' leave the page in
      it's current state. Reading returns '1' if the page is active (hit or
      not).</comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="status_page" pos="PAGE_SPY_NB_PAGE-1:0" rst="0" cut="1" cutprefix="status_page">
      <options>
        <option name="NOT_HIT" value="0" />

        <option name="HIT" value="1" />

        <default />
      </options>
      <comment>Status of the page.</comment>
    </bits>

  </reg>

  <reg protect="rw" name="disable">
    <bits access="rc" name="disable_page" pos="PAGE_SPY_NB_PAGE-1:0" rst="0" cut="1" cutprefix="disable_page">
      <comment>Writing '1' disable the page (n) and clears the hit status if
      any, writing '0' leave the page in it's current state. Reading returns
      '1' if the page is active (hit or not).</comment>
    </bits>
  </reg>

  <hole size="32" />

  <struct count="PAGE_SPY_NB_PAGE" name="page">
    <reg protect="rw" name="start">
      <bits access="rw" name="start_address" pos="NB_BITS_ADDR-1:0" rst="no">
        <comment>Start address of page (n) (included). </comment>
      </bits>

      <bits access="rw" name="detect_read" pos="30" rst="no">
        <comment>If '1' any read within the range will trigger the
        page.</comment>
      </bits>

      <bits access="rw" name="detect_write" pos="31" rst="no">
        <comment>If '1' any read within the range will trigger the
        page.</comment>
      </bits>
      <bitgroup name="mode">
        <entry ref="detect_read"/>
        <entry ref="detect_write"/>
      </bitgroup>  
    </reg>

    <reg protect="rw" name="end">
      <bits access="rw" name="end_address" pos="NB_BITS_ADDR-1:0" rst="no">
        <comment>End address of page (n) (excluded).</comment>
      </bits>
    </reg>

    <reg protect="r" name="master">
      <bits access="r" name="master" pos="2:0" rst="0">
        <options>
          <option name="NO_ACCESS" value="0" />
          <option name="BIST" value="1" />
          <option name="DMA" value="2" />
          <option name="SYS_XCPU" value="3" />
          <option name="AHB2AHB" value="4" />
          <option name="IFC" value="5" />
          <option name="USB" value="6" />
          <default />
        </options>

        <comment>The master that wrote in the page (n). </comment>
      </bits>
    </reg>

    <reg protect="r" name="addr">
      <bits access="r" name="hit_addr" pos="24:0" rst="no">
        <comment>Address that triggered page (n). </comment>
      </bits>

      <bits access="r" name="hit_read" pos="30" rst="no">
        <comment>If '1' a read has triggered the page.</comment>
      </bits>

      <bits access="r" name="hit_write" pos="31" rst="no">
        <comment>If '1' a write has triggered the page.</comment>
      </bits>
    </reg>
  </struct>
</module>

</archive>

<archive relative = "pmu.xml">

<include file='globals.xml'/>

<module name="pmu" category="Analog">
    <reg name="chip_id_00H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="chipid" pos="15:4" access="rw">
            <comment>chipid &#60;11:0&#62;
            </comment>
        </bits>
        <bits name="revid" pos="3:0" access="rw">
            <comment>revid &#60;3:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="revisionid_01H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="eomirq" pos="15" access="rw">
        </bits>
        <bits name="penirq" pos="14" access="rw">
        </bits>
        <bits name="penirq_key" pos="13" access="rw">
        </bits>
        <bits name="clear_penirq_key" pos="12" access="rw">
        </bits>
        <bits name="eomirq_clear" pos="11" access="rw">
        </bits>
        <bits name="penirq_clear" pos="10" access="rw">
        </bits>
        <bits name="eomirq_mask" pos="9" access="rw">
        </bits>
        <bits name="penirq_mask" pos="8" access="rw">
        </bits>
        <bits name="int_chr" pos="7" access="rw">
        </bits>
        <bits name="penirq_key_mask" pos="6" access="rw">
        </bits>
        <bits name="int_chr_clear" pos="5" access="rw">
        </bits>
        <bits name="int_chr_mask" pos="4" access="rw">
        </bits>
        <bits name="reserved1" pos="3" access="rw">
        </bits>
        <bits name="hold_precharger_efuse" pos="2" access="rw">
        </bits>
        <bits name="reserved2" pos="1" access="rw">
        </bits>
        <bits name="pd_mode_sel" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_settings_02H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="vsim1_enable" pos="15" access="rw">
        </bits>
        <bits name="vsim2_enable" pos="14" access="rw">
        </bits>
        <bits name="vsim3_enable" pos="13" access="rw">
        </bits>
        <bits name="vsim4_enable" pos="12" access="rw">
        </bits>
        <bits name="vmc_enable" pos="11" access="rw">
        </bits>
        <bits name="va_enable" pos="10" access="rw">
        </bits>
        <bits name="vasw_enable" pos="9" access="rw">
        </bits>
        <bits name="reserved" pos="8" access="rw">
        </bits>
        <bits name="vibr_enable" pos="7" access="rw">
        </bits>
        <bits name="vmic_enable" pos="6" access="rw">
        </bits>
        <bits name="vcam_enable" pos="5" access="rw">
        </bits>
        <bits name="vlcd_enable" pos="4" access="rw">
        </bits>
        <bits name="tsc_enable" pos="3" access="rw">
        </bits>
        <bits name="key_enable" pos="2" access="rw">
        </bits>
        <bits name="bt_enable" pos="1" access="rw">
        </bits>
        <bits name="fm_enable" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_active_setting_1_03H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pu_buck1_act" pos="15" access="rw">
        </bits>
        <bits name="pfm_mode_sel_buck1_act" pos="14" access="rw">
        </bits>
        <bits name="pd_buck1_ldo_act" pos="13" access="rw">
        </bits>
        <bits name="pd_vm_act" pos="12" access="rw">
        </bits>
        <bits name="pd_vio_act" pos="11" access="rw">
        </bits>
        <bits name="pd_va_act" pos="10" access="rw">
        </bits>
        <bits name="pd_vasw_act" pos="9" access="rw">
        </bits>
        <bits name="pd_vcam_act" pos="8" access="rw">
        </bits>
        <bits name="pd_vlcd_act" pos="7" access="rw">
        </bits>
        <bits name="pd_vmc_act" pos="6" access="rw">
        </bits>
        <bits name="pd_vibr_act" pos="5" access="rw">
        </bits>
        <bits name="pd_vusb_act" pos="4" access="rw">
        </bits>
        <bits name="pd_vmic_act" pos="3" access="rw">
        </bits>
        <bits name="pd_bl_led_act" pos="2" access="rw">
        </bits>
        <bits name="pd_spimem_act" pos="1" access="rw">
        </bits>
        <bits name="lp_mode_b_act" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_active_setting_2_04H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="vrtc_vbit_act" pos="15:13" access="rw">
            <comment>vrtc_vbit_act &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vio_vsel_act" pos="12" access="rw">
        </bits>
        <bits name="vasw_vsel_act" pos="11" access="rw">
        </bits>
        <bits name="vcam_vsel_act" pos="10" access="rw">
        </bits>
        <bits name="vlcd_vsel_act" pos="9" access="rw">
        </bits>
        <bits name="vmc_vsel_act" pos="8" access="rw">
        </bits>
        <bits name="vibr_vsel_act" pos="7" access="rw">
        </bits>
        <bits name="pd_vrf28_act" pos="6" access="rw">
        </bits>
        <bits name="pu_vboost_act" pos="5" access="rw">
        </bits>
        <bits name="pu_va24_act" pos="4" access="rw">
        </bits>
        <bits name="NC" pos="3" access="rw">
        </bits>
        <bits name="NC" pos="2" access="rw">
        </bits>
        <bits name="pd_rgb_led_act" pos="1" access="rw">
        </bits>
        <bits name="reserved" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_active_setting_3_05H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved1" pos="15" access="rw">
        </bits>
        <bits name="vbackup_vbit_act" pos="14:12" access="rw">
            <comment>vbackup_vbit_act &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vspimem_ibit_act" pos="11:9" access="rw">
            <comment>vspimem_ibit_act &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vmem_ibit_act" pos="8:6" access="rw">
            <comment>vmem_ibit_act &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vio_ibit_act" pos="5:3" access="rw">
            <comment>vio_ibit_act &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="reserved2" pos="2" access="rw">
        </bits>
        <bits name="vrtc_dcdc1_en_act" pos="1" access="rw">
        </bits>
        <bits name="vrtc_dcdc2_en_act" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_active_setting_4_06H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15" access="rw">
        </bits>
        <bits name="vasw_ibit_act" pos="14:12" access="rw">
            <comment>vasw_ibit_act &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vcam_ibit_act" pos="11:9" access="rw">
            <comment>vcam_ibit_act &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vlcd_ibit_act" pos="8:6" access="rw">
            <comment>vlcd_ibit_act &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vmc_ibit_act" pos="5:3" access="rw">
            <comment>vmc_ibit_act &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vibr_ibit_act" pos="2:0" access="rw">
            <comment>vibr_ibit_act &#60;2:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="ldo_active_setting_5_07H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="vsim1_vsel_act" pos="15" access="rw">
        </bits>
        <bits name="vsim2_vsel_act" pos="14" access="rw">
        </bits>
        <bits name="vsim3_vsel_act" pos="13" access="rw">
        </bits>
        <bits name="vsim4_vsel_act" pos="12" access="rw">
        </bits>
        <bits name="vusb_ibit_act" pos="11:9" access="rw">
            <comment>vusb_ibit_act &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="va_ibit" pos="8:6" access="rw">
            <comment>va_ibit &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vrgb_led_vsel" pos="5:3" access="rw">
            <comment>vrgb_led_vsel &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vrgb_led_ibit" pos="2:0" access="rw">
            <comment>vrgb_led_ibit &#60;2:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="ldo_lp_setting_1_08H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pu_buck1_lp" pos="15" access="rw">
        </bits>
        <bits name="pfm_mode_sel_buck1_lp" pos="14" access="rw">
        </bits>
        <bits name="pd_buck1_ldo_lp" pos="13" access="rw">
        </bits>
        <bits name="pd_vm_lp" pos="12" access="rw">
        </bits>
        <bits name="pd_vio_lp" pos="11" access="rw">
        </bits>
        <bits name="pd_va_lp" pos="10" access="rw">
        </bits>
        <bits name="pd_vasw_lp" pos="9" access="rw">
        </bits>
        <bits name="pd_vcam_lp" pos="8" access="rw">
        </bits>
        <bits name="pd_vlcd_lp" pos="7" access="rw">
        </bits>
        <bits name="pd_vmc_lp" pos="6" access="rw">
        </bits>
        <bits name="pd_vibr_lp" pos="5" access="rw">
        </bits>
        <bits name="pd_vusb_lp" pos="4" access="rw">
        </bits>
        <bits name="pd_vmic_lp" pos="3" access="rw">
        </bits>
        <bits name="pd_bl_led_lp" pos="2" access="rw">
        </bits>
        <bits name="pd_spimem_lp" pos="1" access="rw">
        </bits>
        <bits name="lp_mode_b_lp" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_lp_setting_2_09H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="vrtc_vbit_lp" pos="15:13" access="rw">
            <comment>vrtc_vbit_lp &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vio_vsel_lp" pos="12" access="rw">
        </bits>
        <bits name="vasw_vsel_lp" pos="11" access="rw">
        </bits>
        <bits name="vcam_vsel_lp" pos="10" access="rw">
        </bits>
        <bits name="vlcd_vsel_lp" pos="9" access="rw">
        </bits>
        <bits name="vmc_vsel_lp" pos="8" access="rw">
        </bits>
        <bits name="vibr_vsel_lp" pos="7" access="rw">
        </bits>
        <bits name="pd_vrf28_lp" pos="6" access="rw">
        </bits>
        <bits name="pu_vboost_lp" pos="5" access="rw">
        </bits>
        <bits name="pu_va24_lp" pos="4" access="rw">
        </bits>
        <bits name="NC" pos="3" access="rw">
        </bits>
        <bits name="NC" pos="2" access="rw">
        </bits>
        <bits name="pd_rgb_led_lp" pos="1" access="rw">
        </bits>
        <bits name="reserved" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_lp_setting_3_0AH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved1" pos="15" access="rw">
        </bits>
        <bits name="vbackup_vbit_lp" pos="14:12" access="rw">
            <comment>vbackup_vbit_lp &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vspimem_ibit_lp" pos="11:9" access="rw">
            <comment>vspimem_ibit_lp &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vm_ibit_lp" pos="8:6" access="rw">
            <comment>vm_ibit_lp &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vio_ibit_lp" pos="5:3" access="rw">
            <comment>vio_ibit_lp &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="reserved2" pos="2" access="rw">
        </bits>
        <bits name="vrtc_dcdc1_en_lp" pos="1" access="rw">
        </bits>
        <bits name="vrtc_dcdc2_en_lp" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_lp_setting_4_0BH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:4" access="rw">
            <comment>reserved &#60;11:0&#62;
            </comment>
        </bits>
        <bits name="vrf28_vsel" pos="3" access="rw">
        </bits>
        <bits name="vrf28_ibit" pos="2:0" access="rw">
            <comment>vrf28_ibit &#60;2:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="ldo_lp_setting_5_0CH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="vsim1_vsel_lp" pos="15" access="rw">
        </bits>
        <bits name="vsim2_vsel_lp" pos="14" access="rw">
        </bits>
        <bits name="vsim3_vsel_lp" pos="13" access="rw">
        </bits>
        <bits name="vsim4_vsel_lp" pos="12" access="rw">
        </bits>
        <bits name="vusb_ibit_lp" pos="11:9" access="rw">
            <comment>vusb_ibit_lp &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="reserved" pos="8:7" access="rw">
            <comment>reserved &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="vsim1_vsel_pon" pos="6" access="rw">
        </bits>
        <bits name="vsim2_vsel_pon" pos="5" access="rw">
        </bits>
        <bits name="vsim3_vsel_pon" pos="4" access="rw">
        </bits>
        <bits name="vsim4_vsel_pon" pos="3" access="rw">
        </bits>
        <bits name="vusb_ibit_pon" pos="2:0" access="rw">
            <comment>vusb_ibit_pon &#60;2:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="ldo_power_on_setting_1_0DH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pu_buck1_pon" pos="15" access="rw">
        </bits>
        <bits name="pfm_mode_sel_buck1_pon" pos="14" access="rw">
        </bits>
        <bits name="pd_buck1_ldo_pon" pos="13" access="rw">
        </bits>
        <bits name="pd_vm_pon" pos="12" access="rw">
        </bits>
        <bits name="pd_vio_pon" pos="11" access="rw">
        </bits>
        <bits name="pd_va_pon" pos="10" access="rw">
        </bits>
        <bits name="pd_vasw_pon" pos="9" access="rw">
        </bits>
        <bits name="pd_vcam_pon" pos="8" access="rw">
        </bits>
        <bits name="pd_vlcd_pon" pos="7" access="rw">
        </bits>
        <bits name="pd_vmc_pon" pos="6" access="rw">
        </bits>
        <bits name="pd_vibr_pon" pos="5" access="rw">
        </bits>
        <bits name="pd_vusb_pon" pos="4" access="rw">
        </bits>
        <bits name="pd_vmic_pon" pos="3" access="rw">
        </bits>
        <bits name="pd_bl_led_pon" pos="2" access="rw">
        </bits>
        <bits name="pd_spimem_pon" pos="1" access="rw">
        </bits>
        <bits name="lp_mode_b_pon" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_power_on_setting_2_0EH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="vrtc_vbit_pon" pos="15:13" access="rw">
            <comment>vrtc_vbit_pon &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vio_vsel_pon" pos="12" access="rw">
        </bits>
        <bits name="vasw_vsel_pon" pos="11" access="rw">
        </bits>
        <bits name="vcam_vsel_pon" pos="10" access="rw">
        </bits>
        <bits name="vlcd_vsel_pon" pos="9" access="rw">
        </bits>
        <bits name="vmc_vsel_pon" pos="8" access="rw">
        </bits>
        <bits name="vibr_vsel_pon" pos="7" access="rw">
        </bits>
        <bits name="pd_vrf28_pon" pos="6" access="rw">
        </bits>
        <bits name="pu_vboost_pon" pos="5" access="rw">
        </bits>
        <bits name="pu_buck2_pon" pos="4" access="rw">
        </bits>
        <bits name="pfm_mode_sel_buck2_pon" pos="3" access="rw">
        </bits>
        <bits name="pd_buck2_ldo_pon" pos="2" access="rw">
        </bits>
        <bits name="pd_rgb_led_pon" pos="1" access="rw">
        </bits>
        <bits name="reserved" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_power_on_setting_3_0FH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved1" pos="15" access="rw">
        </bits>
        <bits name="vbackup_vbit_pon" pos="14:12" access="rw">
            <comment>vbackup_vbit_pon &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vd_spimem_ibit_pon" pos="11:9" access="rw">
            <comment>vd_spimem_ibit_pon &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vm_ibit_pon" pos="8:6" access="rw">
            <comment>vm_ibit_pon &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vio_ibit_pon" pos="5:3" access="rw">
            <comment>vio_ibit_pon &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="reserved2" pos="2" access="rw">
        </bits>
        <bits name="vrtc_dcdc1_en_pon" pos="1" access="rw">
        </bits>
        <bits name="vrtc_dcdc2_en_pon" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_power_on_setting_4_10H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="vs_sel_buck1" pos="15" access="rw">
        </bits>
        <bits name="reserved" pos="14:12" access="rw">
            <comment>reserved &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="asw_excap_en" pos="11" access="rw">
        </bits>
        <bits name="cam_excap_en" pos="10" access="rw">
        </bits>
        <bits name="io_excap_en" pos="9" access="rw">
        </bits>
        <bits name="lcd_excap_en" pos="8" access="rw">
        </bits>
        <bits name="mem_excap_en" pos="7" access="rw">
        </bits>
        <bits name="mc_excap_en" pos="6" access="rw">
        </bits>
        <bits name="spimem_excap_en" pos="5" access="rw">
        </bits>
        <bits name="vrf28_excap_en" pos="4" access="rw">
        </bits>
        <bits name="sim1_excap_en" pos="3" access="rw">
        </bits>
        <bits name="sim2_excap_en" pos="2" access="rw">
        </bits>
        <bits name="sim3_excap_en" pos="1" access="rw">
        </bits>
        <bits name="sim4_excap_en" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_power_on_setting_5_11H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:7" access="rw">
        </bits>
        <bits name="hp_detect" pos="6" access="rw">
        </bits>
        <bits name="hp_in" pos="5" access="rw">
        </bits>
        <bits name="hp_out" pos="4" access="rw">
        </bits>
        <bits name="clear_hp_in" pos="3" access="rw">
        </bits>
        <bits name="clear_hp_out" pos="2" access="rw">
        </bits>
        <bits name="hp_in_mask" pos="1" access="rw">
        </bits>
        <bits name="hp_out_mask" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="charger_setting_1_12H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="chr_always_cc" pos="15" access="rw">
        </bits>
        <bits name="chr_cv_lowgain" pos="14" access="rw">
        </bits>
        <bits name="chr_auxadc_sel" pos="13:12" access="rw">
            <comment>chr_auxadc_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="chr_bypass_chopper" pos="11" access="rw">
        </bits>
        <bits name="reserved" pos="10" access="rw">
        </bits>
        <bits name="uv_sel" pos="9:8" access="rw">
            <comment>uv_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="iref_ctl_bg_pmu" pos="7" access="rw">
        </bits>
        <bits name="bg__disable_chopper_filter" pos="6" access="rw">
        </bits>
        <bits name="bg__disable_chopper" pos="5" access="rw">
        </bits>
        <bits name="bg_cal_tc_bit1" pos="4:0" access="rw">
            <comment>bg_cal_tc_bit1 &#60;4:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="charger_setting_2_13H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:13" access="rw">
            <comment>reserved &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="chr_cc_i_bit_dr" pos="12" access="rw">
        </bits>
        <bits name="chr_pre_i_bit_dr" pos="11" access="rw">
        </bits>
        <bits name="chr_vfb_sel_dr" pos="10" access="rw">
        </bits>
        <bits name="chr_cc_i_bit_reg" pos="9:7" access="rw">
            <comment>chr_cc_i_bit_reg &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="chr_pre_i_bit_reg" pos="6:4" access="rw">
            <comment>chr_pre_i_bit_reg &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="chr_vfb_sel_reg" pos="3:0" access="rw">
            <comment>chr_vfb_sel_reg &#60;3:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="charger_status_14H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="over_temp" pos="15" access="rw">
        </bits>
        <bits name="bg_pmu_cal_out" pos="14" access="rw">
        </bits>
        <bits name="reserved" pos="13" access="rw">
        </bits>
        <bits name="reserved" pos="12" access="rw">
        </bits>
        <bits name="penirq_b" pos="11" access="rw">
        </bits>
        <bits name="tsc_sar_out" pos="10" access="rw">
        </bits>
        <bits name="gpadc_sar_out" pos="9" access="rw">
        </bits>
        <bits name="reserved" pos="8" access="rw">
        </bits>
        <bits name="chr_ac_on" pos="7" access="rw">
        </bits>
        <bits name="chr_bat_on" pos="6" access="rw">
        </bits>
        <bits name="low_bat" pos="5" access="rw">
        </bits>
        <bits name="reserved" pos="4" access="rw">
        </bits>
        <bits name="chr_creg" pos="3" access="rw">
        </bits>
        <bits name="chr_vreg" pos="2" access="rw">
        </bits>
        <bits name="reserved" pos="1" access="rw">
        </bits>
        <bits name="reserved" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="charger_control_15H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="chr_enable_dr" pos="15" access="rw">
        </bits>
        <bits name="chr_enable_reg" pos="14" access="rw">
        </bits>
        <bits name="chr_cc_mode_dr" pos="13" access="rw">
        </bits>
        <bits name="chr_cc_mode_reg" pos="12" access="rw">
        </bits>
        <bits name="reserved" pos="11:7" access="rw">
            <comment>reserved &#60;4:0&#62;
            </comment>
        </bits>
        <bits name="chr_en_freq" pos="6:5" access="rw">
            <comment>chr_en_freq &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="chr_en_duty_cycle" pos="4:3" access="rw">
            <comment>chr_en_duty_cycle &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="bat_monitor_enable" pos="2" access="rw">
        </bits>
        <bits name="bat_monitor_time_delay" pos="1:0" access="rw">
            <comment>bat_monitor_time_delay &#60;1:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="calibration_setting_1_16H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pmu_bgap_cal_bypass" pos="15" access="rw">
        </bits>
        <bits name="vbat_over_3p2_bypass" pos="14" access="rw">
        </bits>
        <bits name="pmu_bgap_cal_clock_inv" pos="13" access="rw">
        </bits>
        <bits name="pmu_bgap_cal_polarity" pos="12" access="rw">
        </bits>
        <bits name="lp_mode_bg_dr" pos="11" access="rw">
        </bits>
        <bits name="lp_mode_bg_reg" pos="10" access="rw">
        </bits>
        <bits name="reserved" pos="9" access="rw">
        </bits>
        <bits name="resetn_bgap_cal_dr" pos="8" access="rw">
        </bits>
        <bits name="resetn_bgap_cal_reg" pos="7" access="rw">
        </bits>
        <bits name="bgap_cal_bit_dr" pos="6" access="rw">
        </bits>
        <bits name="bgap_cal_bit_reg" pos="5:0" access="rw">
            <comment>bgap_cal_bit_reg &#60;5:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="calibration_setting_2_17H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pu_ts_battery" pos="15" access="rw">
        </bits>
        <bits name="ts_i_ctrl_battery" pos="14:11" access="rw">
            <comment>ts_i_ctrl_battery &#60;3:0&#62;
            </comment>
        </bits>
        <bits name="reserved" pos="10:1" access="rw">
            <comment>reserved &#60;9:0&#62;
            </comment>
        </bits>
        <bits name="pd_charge_ldo" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="misc_control_18H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:12" access="rw">
            <comment>reserved &#60;3:0&#62;
            </comment>
        </bits>
        <bits name="pu_clk_32k_dr" pos="11" access="rw">
        </bits>
        <bits name="pu_clk_32k_reg" pos="10" access="rw">
        </bits>
        <bits name="pu_clk_4m_dr" pos="9" access="rw">
        </bits>
        <bits name="pu_clk_4m_reg" pos="8" access="rw">
        </bits>
        <bits name="pd_ldo_avdd3_dr" pos="7" access="rw">
        </bits>
        <bits name="pd_ldo_avdd3_reg" pos="6" access="rw">
        </bits>
        <bits name="clk2m_ftun_bit" pos="5:3" access="rw">
            <comment>clk2m_ftun_bit &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="ldo_avdd3_bit" pos="2:0" access="rw">
            <comment>ldo_avdd3_bit &#60;2:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="led_setting_1_19H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pwm_rgb_freq" pos="15:12" access="rw">
            <comment>pwm_rgb_freq &#60;3:0&#62;
            </comment>
        </bits>
        <bits name="reserved" pos="11:10" access="rw">
            <comment>reserved &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="pwm_bl_enable" pos="9" access="rw">
        </bits>
        <bits name="pwm_rgb_pmu_mode" pos="8" access="rw">
        </bits>
        <bits name="dim_led_r_dr" pos="7" access="rw">
        </bits>
        <bits name="dim_led_r_reg" pos="6" access="rw">
        </bits>
        <bits name="dim_led_g_dr" pos="5" access="rw">
        </bits>
        <bits name="dim_led_g_reg" pos="4" access="rw">
        </bits>
        <bits name="dim_led_b_dr" pos="3" access="rw">
        </bits>
        <bits name="dim_led_b_reg" pos="2" access="rw">
        </bits>
        <bits name="dim_bl_dr" pos="1" access="rw">
        </bits>
        <bits name="dim_bl_reg" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="led_setting_2_1AH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="i_bit_bl_pon" pos="15:12" access="rw">
            <comment>i_bit_bl_pon &#60;3:0&#62;
            </comment>
        </bits>
        <bits name="i_bit_bl_act" pos="11:8" access="rw">
            <comment>i_bit_bl_act &#60;3:0&#62;
            </comment>
        </bits>
        <bits name="i_bit_bl_lp" pos="7:4" access="rw">
            <comment>i_bit_bl_lp &#60;3:0&#62;
            </comment>
        </bits>
        <bits name="pd_bl_pon" pos="3" access="rw">
        </bits>
        <bits name="pd_bl_act" pos="2" access="rw">
        </bits>
        <bits name="pd_bl_lp" pos="1" access="rw">
        </bits>
        <bits name="reserved" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="led_setting_3_1BH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15" access="rw">
        </bits>
        <bits name="pwm_bl_duty_cycle" pos="14:10" access="rw">
            <comment>pwm_bl_duty_cycle &#60;4:0&#62;
            </comment>
        </bits>
        <bits name="pwm_bl_freq" pos="9:6" access="rw">
            <comment>pwm_bl_freq &#60;3:0&#62;
            </comment>
        </bits>
        <bits name="pwm_bl_freq_sel" pos="5" access="rw">
        </bits>
        <bits name="reserved" pos="4:0" access="rw">
            <comment>reserved &#60;4:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="audio_control_1CH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="meas_wait_clr_penirq" pos="15" access="rw">
        </bits>
        <bits name="bypass_bb_read" pos="14" access="rw">
        </bits>
        <bits name="delay_before_samp" pos="13:12" access="rw">
            <comment>delay_before_samp &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="pwm_clk_div2_enable" pos="11" access="rw">
        </bits>
        <bits name="timer_penirq_stable" pos="10:8" access="rw">
            <comment>timer_penirq_stable &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="timer_int_to_x_sel" pos="7:5" access="rw">
            <comment>timer_int_to_x_sel &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="timer_x_to_y_sel" pos="4:3" access="rw">
            <comment>timer_x_to_y_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="timer_samp_pos_tsc" pos="2" access="rw">
        </bits>
        <bits name="timer_samp_neg_tsc" pos="1" access="rw">
        </bits>
        <bits name="reserved" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="touch_screen_control_1DH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="tsc_xp_xn_inv" pos="15" access="rw">
        </bits>
        <bits name="tsc_yp_yn_inv" pos="14" access="rw">
        </bits>
        <bits name="tsc_clk_div_en" pos="13" access="rw">
        </bits>
        <bits name="reserved" pos="12" access="rw">
        </bits>
        <bits name="tsc_sar_sel_r" pos="11:10" access="rw">
            <comment>tsc_sar_sel_r &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="sar_vref_bit" pos="9:8" access="rw">
            <comment>sar_vref_bit &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="wait_bb_read_timsel" pos="7:6" access="rw">
            <comment>wait_bb_read_timsel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="sar_out_polarity" pos="5" access="rw">
        </bits>
        <bits name="sar_adc_mode" pos="4" access="rw">
        </bits>
        <bits name="samp_clk_inv" pos="3" access="rw">
        </bits>
        <bits name="conv_clk_inv" pos="2" access="rw">
        </bits>
        <bits name="reserved" pos="1:0" access="rw">
            <comment>reserved &#60;1:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="touch_screen_results_1_1EH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:11" access="rw">
        </bits>
        <bits name="tsc_x_value_valid" pos="10" access="rw">
        </bits>
        <bits name="tsc_x_value_bit" pos="9:0" access="rw">
            <comment>tsc_x_value_bit &#60;9:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="touch_screen_results_2_1FH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:11" access="rw">
        </bits>
        <bits name="tsc_y_value_valid" pos="10" access="rw">
        </bits>
        <bits name="tsc_y_value_bit" pos="9:0" access="rw">
            <comment>tsc_y_value_bit &#60;9:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="touch_screen_results_3_20H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:11" access="rw">
        </bits>
        <bits name="gpadc_value_valid" pos="10" access="rw">
        </bits>
        <bits name="gpadc_value_bit" pos="9:0" access="rw">
            <comment>gpadc_value_bit &#60;9:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="efuse_and_otp_setting_1_21H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="efuse_sense_dr" pos="15" access="rw">
        </bits>
        <bits name="efuse_sense_reg" pos="14" access="rw">
        </bits>
        <bits name="efuse_sel_word_reg" pos="13:12" access="rw">
            <comment>efuse_sel_word_reg &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="efuse_sel_word_auto_1" pos="11:10" access="rw">
            <comment>efuse_sel_word_auto_1 &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="efuse_sel_word_auto_1" pos="9:8" access="rw">
            <comment>efuse_sel_word_auto_1 &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="reserved" pos="7:0" access="rw">
            <comment>reserved &#60;7:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="efuse_and_otp_setting_2_22H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="sw_pmos_ctrl_cp" pos="15:14" access="rw">
            <comment>sw_pmos_ctrl_cp &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="sw_nmos_ctrl_cp" pos="13:12" access="rw">
            <comment>sw_nmos_ctrl_cp &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="reserved" pos="11:3" access="rw">
            <comment>reserved &#60;8:0&#62;
            </comment>
        </bits>
        <bits name="lp_mode_dr" pos="2" access="rw">
        </bits>
        <bits name="lp_mode_reg" pos="1" access="rw">
        </bits>
        <bits name="pd_otp_reg" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="efuse_and_otp_setting_3_23H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="efuse_sel" pos="15:0" access="rw">
            <comment>efuse_sel &#60;15:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="efuse_and_otp_setting_4_24H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="efuse_out_read_1" pos="15:0" access="rw">
            <comment>efuse_out_read_1 &#60;15:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="efuse_and_otp_setting_5_25H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="efuse_out_read_2" pos="15:0" access="rw">
            <comment>efuse_out_read_2 &#60;15:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="sim_interface_26H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="chr_out_time_sel" pos="15:13" access="rw">
            <comment>chr_out_time_sel &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="chr_ac_on_time_sel" pos="12:10" access="rw">
            <comment>chr_ac_on_time_sel &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="time_clk_4m_stable" pos="9:8" access="rw">
            <comment>time_clk_4m_stable &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="reserved" pos="7:4" access="rw">
            <comment>reserved &#60;3:0&#62;
            </comment>
        </bits>
        <bits name="timer_bb_resetn_sel" pos="3:2" access="rw">
            <comment>timer_bb_resetn_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="bypass_clk_32k_gate" pos="1" access="rw">
        </bits>
        <bits name="bypass_clk_4m_gate" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="sim_interface_27H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="delay_bit_cp" pos="15:14" access="rw">
            <comment>delay_bit_cp &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="NC" pos="13:10" access="rw">
        </bits>
        <bits name="clk_sel_cp" pos="9" access="rw">
        </bits>
        <bits name="clg_det_out_pol" pos="8" access="rw">
        </bits>
        <bits name="clg_det_out_time" pos="7:6" access="rw">
            <comment>clg_det_out_time &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="vbp_ctrl_cp" pos="5:4" access="rw">
            <comment>vbp_ctrl_cp &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="NC" pos="3:0" access="rw">
        </bits>
    </reg>
    <reg name="sim_interface_28H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pd_vsim1_act" pos="15" access="rw">
        </bits>
        <bits name="pd_vsim2_act" pos="14" access="rw">
        </bits>
        <bits name="pd_vsim3_act" pos="13" access="rw">
        </bits>
        <bits name="pd_vsim4_act" pos="12" access="rw">
        </bits>
        <bits name="vsim1_ibit_act" pos="11:9" access="rw">
            <comment>vsim1_ibit_act &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vsim2_ibit_act" pos="8:6" access="rw">
            <comment>vsim2_ibit_act &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vsim3_ibit_act" pos="5:3" access="rw">
            <comment>vsim3_ibit_act &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vsim4_ibit_act" pos="2:0" access="rw">
            <comment>vsim4_ibit_act &#60;2:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="sim_interface_29H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pd_vsim1_lp" pos="15" access="rw">
        </bits>
        <bits name="pd_vsim2_lp" pos="14" access="rw">
        </bits>
        <bits name="pd_vsim3_lp" pos="13" access="rw">
        </bits>
        <bits name="pd_vsim4_lp" pos="12" access="rw">
        </bits>
        <bits name="vsim1_ibit_lp" pos="11:9" access="rw">
            <comment>vsim1_ibit_lp &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vsim2_ibit_lp" pos="8:6" access="rw">
            <comment>vsim2_ibit_lp &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vsim3_ibit_lp" pos="5:3" access="rw">
            <comment>vsim3_ibit_lp &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vsim4_ibit_lp" pos="2:0" access="rw">
            <comment>vsim4_ibit_lp &#60;2:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="sim_interface_2AH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pd_vsim1_pon" pos="15" access="rw">
        </bits>
        <bits name="pd_vsim2_pon" pos="14" access="rw">
        </bits>
        <bits name="pd_vsim3_pon" pos="13" access="rw">
        </bits>
        <bits name="pd_vsim4_pon" pos="12" access="rw">
        </bits>
        <bits name="vsim1_ibit_pon" pos="11:9" access="rw">
            <comment>vsim1_ibit_pon &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vsim2_ibit_pon" pos="8:6" access="rw">
            <comment>vsim2_ibit_pon &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vsim3_ibit_pon" pos="5:3" access="rw">
            <comment>vsim3_ibit_pon &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vsim4_ibit_pon" pos="2:0" access="rw">
            <comment>vsim4_ibit_pon &#60;2:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="sim_interface_2BH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pd_vsim1_poff" pos="15" access="rw">
        </bits>
        <bits name="pd_vsim2_poff" pos="14" access="rw">
        </bits>
        <bits name="pd_vsim3_poff" pos="13" access="rw">
        </bits>
        <bits name="pd_vsim4_poff" pos="12" access="rw">
        </bits>
        <bits name="vsim1_ibit_poff" pos="11:9" access="rw">
            <comment>vsim1_ibit_poff &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vsim2_ibit_poff" pos="8:6" access="rw">
            <comment>vsim2_ibit_poff &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vsim3_ibit_poff" pos="5:3" access="rw">
            <comment>vsim3_ibit_poff &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vsim4_ibit_poff" pos="2:0" access="rw">
            <comment>vsim4_ibit_poff &#60;2:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="pmu_8809_2CH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pa_on_bypass" pos="15" access="rw">
        </bits>
        <bits name="reserved" pos="14" access="rw">
        </bits>
        <bits name="transc_resetn_time_sel" pos="13:12" access="rw">
            <comment>transc_resetn_time_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="abb_resetn_time_sel" pos="11:10" access="rw">
            <comment>abb_resetn_time_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="resetn_transc_dr" pos="9" access="rw">
        </bits>
        <bits name="resetn_transc_reg" pos="8" access="rw">
        </bits>
        <bits name="resetn_abb_dr" pos="7" access="rw">
        </bits>
        <bits name="resetn_abb_reg" pos="6" access="rw">
        </bits>
        <bits name="reserved" pos="5:4" access="rw">
            <comment>reserved &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="pu_fm_dr" pos="3" access="rw">
        </bits>
        <bits name="pu_fm_reg" pos="2" access="rw">
        </bits>
        <bits name="pu_bt_dr" pos="1" access="rw">
        </bits>
        <bits name="pu_bt_reg" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_2DH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:13" access="rw">
        </bits>
        <bits name="pfm_mode_clk_prd_buck1" pos="12:11" access="rw">
            <comment>pfm_mode_clk_prd_buck1 &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="pfm_clk_disable_buck1_dr" pos="10" access="rw">
        </bits>
        <bits name="pfm_clk_disable_buck1_reg" pos="9" access="rw">
        </bits>
        <bits name="counter_disable_buck1" pos="8" access="rw">
        </bits>
        <bits name="pfm_buck1_threshold" pos="7:6" access="rw">
            <comment>pfm_buck1_threshold &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="osc_freq_buck1" pos="5:4" access="rw">
            <comment>osc_freq_buck1 &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="low_sense_buck1" pos="3" access="rw">
        </bits>
        <bits name="discharge_en_buck1" pos="2" access="rw">
        </bits>
        <bits name="heavy_load_buck1" pos="1" access="rw">
        </bits>
        <bits name="antiring_disable_buck1" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_2EH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="NC" pos="15:13" access="rw">
        </bits>
        <bits name="pfm_mode_clk_prd_buck2" pos="12:11" access="rw">
            <comment>pfm_mode_clk_prd_buck2 &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="pfm_clk_disable_buck2_dr" pos="10" access="rw">
        </bits>
        <bits name="pfm_clk_disable_buck2_reg" pos="9" access="rw">
        </bits>
        <bits name="counter_disable_buck2" pos="8" access="rw">
        </bits>
        <bits name="pfm_buck2_threshold" pos="7:6" access="rw">
            <comment>pfm_buck2_threshold &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="osc_freq_buck2" pos="5:4" access="rw">
            <comment>osc_freq_buck2 &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="low_sense_buck2" pos="3" access="rw">
        </bits>
        <bits name="discharge_en_buck2" pos="2" access="rw">
        </bits>
        <bits name="heavy_load_buck2" pos="1" access="rw">
        </bits>
        <bits name="ir_disable_en_buck2" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_2FH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="vbuck1_bit_nlp" pos="15:12" access="rw">
            <comment>vbuck1_bit_nlp &#60;3:0&#62;
            </comment>
        </bits>
        <bits name="vbuck1_bit_lp" pos="11:8" access="rw">
            <comment>vbuck1_bit_lp &#60;3:0&#62;
            </comment>
        </bits>
        <bits name="NC" pos="7:4" access="rw">
        </bits>
        <bits name="NC" pos="3:0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_30H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="register_resetn" pos="15" access="rw">
        </bits>
        <bits name="reserved" pos="14:1" access="rw">
        </bits>
        <bits name="soft_resetn" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_power_off_setting_1_31H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pu_buck1_poff" pos="15" access="rw">
        </bits>
        <bits name="pfm_mode_sel_buck1_poff" pos="14" access="rw">
        </bits>
        <bits name="pd_buck1_ldo_poff" pos="13" access="rw">
        </bits>
        <bits name="pd_vm_pfff" pos="12" access="rw">
        </bits>
        <bits name="pd_vio_poff" pos="11" access="rw">
        </bits>
        <bits name="pd_va_poff" pos="10" access="rw">
        </bits>
        <bits name="pd_vasw_poff" pos="9" access="rw">
        </bits>
        <bits name="pd_vcam_poff" pos="8" access="rw">
        </bits>
        <bits name="pd_vlcd_poff" pos="7" access="rw">
        </bits>
        <bits name="pd_vmc_poff" pos="6" access="rw">
        </bits>
        <bits name="pd_vibr_poff" pos="5" access="rw">
        </bits>
        <bits name="pd_vusb_poff" pos="4" access="rw">
        </bits>
        <bits name="pd_vmic_poff" pos="3" access="rw">
        </bits>
        <bits name="pd_bl_led_poff" pos="2" access="rw">
        </bits>
        <bits name="pd_spimem_poff" pos="1" access="rw">
        </bits>
        <bits name="lp_mode_b_poff" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_power_off_setting_2_32H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="vrtc_vbit_poff" pos="15:13" access="rw">
            <comment>vrtc_vbit_poff &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vio_vsel_poff" pos="12" access="rw">
        </bits>
        <bits name="vasw_vsel_poff" pos="11" access="rw">
        </bits>
        <bits name="vcam_vsel_poff" pos="10" access="rw">
        </bits>
        <bits name="vlcd_vsel_poff" pos="9" access="rw">
        </bits>
        <bits name="vmc_vsel_poff" pos="8" access="rw">
        </bits>
        <bits name="vibr_vsel_poff" pos="7" access="rw">
        </bits>
        <bits name="pd_vrf28_poff" pos="6" access="rw">
        </bits>
        <bits name="pu_vboost_poff" pos="5" access="rw">
        </bits>
        <bits name="pu_buck2_poff" pos="4" access="rw">
        </bits>
        <bits name="pfm_mode_sel_buck2_poff" pos="3" access="rw">
        </bits>
        <bits name="pd_buck2_ldo_poff" pos="2" access="rw">
        </bits>
        <bits name="pd_rgb_led_poff" pos="1" access="rw">
        </bits>
        <bits name="reserved" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_power_off_setting_3_33H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pd_bl_poff" pos="15" access="rw">
        </bits>
        <bits name="vbackup_vbit_poff" pos="14:12" access="rw">
            <comment>vbackup_vbit_poff &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vspimem_ibit_poff" pos="11:9" access="rw">
            <comment>vspimem_ibit_poff &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vm_ibit_poff" pos="8:6" access="rw">
            <comment>vm_ibit_poff &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vio_ibit_poff" pos="5:3" access="rw">
            <comment>vio_ibit_poff &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="reserved" pos="2" access="rw">
        </bits>
        <bits name="vrtc_dcdc1_en_poff" pos="1" access="rw">
        </bits>
        <bits name="vrtc_dcdc2_en_poff" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_power_off_setting_4_34H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="chopper_bg__4m_26m_sel" pos="15" access="rw">
        </bits>
        <bits name="chopper_chr_bg_s4m_sel" pos="14:13" access="rw">
            <comment>chopper_chr_bg_s4m_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="chopper_clk_bg_s26m_sel" pos="12:11" access="rw">
            <comment>chopper_clk_bg_s26m_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="chopper_chr_4m__26m_sel" pos="10" access="rw">
        </bits>
        <bits name="chopper_clk_chr__s4m_sel" pos="9:8" access="rw">
            <comment>chopper_clk_chr__s4m_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="chopper_clk_chr__s26m_sel" pos="7:6" access="rw">
            <comment>chopper_clk_chr__s26m_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="pd_led_r_pon" pos="5" access="rw">
        </bits>
        <bits name="pd_led_g_pon" pos="4" access="rw">
        </bits>
        <bits name="pd_led_b_pon" pos="3" access="rw">
        </bits>
        <bits name="pd_led_r_poff" pos="2" access="rw">
        </bits>
        <bits name="pd_led_g_poff" pos="1" access="rw">
        </bits>
        <bits name="pd_led_b_poff" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="ldo_power_off_setting_5_35H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="i_bit_bl_poff" pos="15:12" access="rw">
            <comment>i_bit_bl_poff &#60;3:0&#62;
            </comment>
        </bits>
        <bits name="vusb_ibit_poff" pos="11:9" access="rw">
            <comment>vusb_ibit_poff &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="reserved" pos="8:4" access="rw">
            <comment>reserved &#60;4:0&#62;
            </comment>
        </bits>
        <bits name="vsim1_vsel_poff" pos="3" access="rw">
        </bits>
        <bits name="vsim2_vsel_poff" pos="2" access="rw">
        </bits>
        <bits name="vsim3_vsel_poff" pos="1" access="rw">
        </bits>
        <bits name="vsim4_vsel_poff" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="thermal_calibration_36H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pd_vd_ldo" pos="15" access="rw">
        </bits>
        <bits name="pu_thermo_protect" pos="14" access="rw">
        </bits>
        <bits name="thermo_sel" pos="13:12" access="rw">
            <comment>thermo_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="calmode_en_bg_cal" pos="11" access="rw">
        </bits>
        <bits name="chr_calmode_en_noncal" pos="10" access="rw">
        </bits>
        <bits name="chr_calmode_en_bg_reg" pos="9" access="rw">
        </bits>
        <bits name="buck_heave_load" pos="8" access="rw">
        </bits>
        <bits name="reserved_analog" pos="7:2" access="rw">
            <comment>reserved_analog &#60;7:2&#62;
            </comment>
        </bits>
        <bits name="pu_xtal_32k" pos="1" access="rw">
        </bits>
        <bits name="reserved" pos="0" access="rw">
        </bits>

    </reg>
    <reg name="misc_37H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="resetn_tsc_dr" pos="15" access="rw">
        </bits>
        <bits name="resetn_tsc_reg" pos="14" access="rw">
        </bits>
        <bits name="resetn_bb_dr" pos="13" access="rw">
        </bits>
        <bits name="resetn_bb_reg" pos="12" access="rw">
        </bits>
        <bits name="pu_bgap_dr" pos="11" access="rw">
        </bits>
        <bits name="pu_bgap_reg" pos="10" access="rw">
        </bits>
        <bits name="over_temp_bypass" pos="9" access="rw">
        </bits>
        <bits name="reserved" pos="8" access="rw">
        </bits>
        <bits name="bt_resetn_time_sel" pos="7:6" access="rw">
            <comment>bt_resetn_time_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="resetn_bt_dr" pos="5" access="rw">
        </bits>
        <bits name="resetn_bt_reg" pos="4" access="rw">
        </bits>
        <bits name="fm_resetn_time_sel" pos="3:2" access="rw">
            <comment>fm_resetn_time_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="resetn_fm_dr" pos="1" access="rw">
        </bits>
        <bits name="resetn_fm_reg" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="misc_38H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pwm_r_duty_cycle" pos="15:11" access="rw">
            <comment>pwm_r_duty_cycle &#60;4:0&#62;
            </comment>
        </bits>
        <bits name="pwm_g_duty_cycle" pos="10:6" access="rw">
            <comment>pwm_g_duty_cycle &#60;4:0&#62;
            </comment>
        </bits>
        <bits name="pwm_b_duty_cycle" pos="5:1" access="rw">
            <comment>pwm_b_duty_cycle &#60;4:0&#62;
            </comment>
        </bits>
        <bits name="reserved" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="misc_39H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:11" access="rw">
        </bits>
        <bits name="bat_vol_max_dr" pos="10" access="rw">
        </bits>
        <bits name="bat_vol_max_reg" pos="9:0" access="rw">
            <comment>bat_vol_max_reg &#60;9:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="misc_3AH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="gpadc_start_phase_sel" pos="15" access="rw">
        </bits>
        <bits name="gpadc_eoc_phase_sel" pos="14" access="rw">
        </bits>
        <bits name="samp_clk_inv_gpadc" pos="13" access="rw">
        </bits>
        <bits name="conv_clk_inv_gpadc" pos="12" access="rw">
        </bits>
        <bits name="sar_adc_mode_gpadc" pos="11" access="rw">
        </bits>
        <bits name="sar_out_polarity_gpadc" pos="10" access="rw">
        </bits>
        <bits name="delay_before_samp_gpadc" pos="9:8" access="rw">
            <comment>delay_before_samp_gpadc &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="timer_sar_stable_sel" pos="7:6" access="rw">
            <comment>timer_sar_stable_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="time_samp_pos_gpadc" pos="5" access="rw">
        </bits>
        <bits name="time_samp_neg_gpadc" pos="4" access="rw">
        </bits>
        <bits name="gpadc_start_dr" pos="3" access="rw">
        </bits>
        <bits name="gpadc_start_reg" pos="2" access="rw">
        </bits>
        <bits name="resetn_gpadc_dr" pos="1" access="rw">
        </bits>
        <bits name="resetn_gpadc_reg" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="misc_3BH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="gpadc_start_time_sel" pos="15:13" access="rw">
            <comment>gpadc_start_time_sel &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="gpadc_clk_div_en" pos="12" access="rw">
        </bits>
        <bits name="reserved" pos="11" access="rw">
        </bits>
        <bits name="adc_vref_bit" pos="10:9" access="rw">
            <comment>adc_vref_bit &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="gpadc_en" pos="8:1" access="rw">
            <comment>gpadc_en &#60;7:0&#62;
            </comment>
        </bits>
        <bits name="gpadc_enable" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="misc_3CH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="vcore_pon_time_sel" pos="15:14" access="rw">
            <comment>vcore_pon_time_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="vcore_poff_time_sel" pos="13:12" access="rw">
            <comment>vcore_poff_time_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="vio_pon_time_sel" pos="11:10" access="rw">
            <comment>vio_pon_time_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="vio_poff_time_sel" pos="9:8" access="rw">
            <comment>vio_poff_time_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="vmem_pon_time_sel" pos="7:6" access="rw">
            <comment>vmem_pon_time_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="vmem_poff_time_sel" pos="5:4" access="rw">
            <comment>vmem_poff_time_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="vother1_pon_time_sel" pos="3:2" access="rw">
            <comment>vother1_pon_time_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="vother1_poff_time_sel" pos="1:0" access="rw">
            <comment>vother1_poff_time_sel &#60;1:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="misc_3DH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="vother2_pon_time_sel" pos="15:14" access="rw">
            <comment>vother2_pon_time_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="vother2_poff_time_sel" pos="13:12" access="rw">
            <comment>vother2_poff_time_sel &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="timer_thermo_check" pos="11:9" access="rw">
            <comment>timer_thermo_check &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="reserved" pos="8:6" access="rw">
            <comment>reserved &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="pu_dvdd_transc" pos="5" access="rw">
        </bits>
        <bits name="pu_dvdd_abb" pos="4" access="rw">
        </bits>
        <bits name="pu_dvdd_fm" pos="3" access="rw">
        </bits>
        <bits name="pu_dvdd_bt" pos="2" access="rw">
        </bits>
        <bits name="lv_detect_dr" pos="1" access="rw">
        </bits>
        <bits name="lv_detect_reg" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="misc_3EH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="gbit_abb_enable" pos="15" access="rw">
        </bits>
        <bits name="pd_led_r_act" pos="14" access="rw">
        </bits>
        <bits name="pd_led_g_act" pos="13" access="rw">
        </bits>
        <bits name="pd_led_b_act" pos="12" access="rw">
        </bits>
        <bits name="pd_led_r_lp" pos="11" access="rw">
        </bits>
        <bits name="pd_led_g_lp" pos="10" access="rw">
        </bits>
        <bits name="pd_led_b_lp" pos="9" access="rw">
        </bits>
        <bits name="i_bit_r" pos="8:6" access="rw">
            <comment>i_bit_r &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="i_bit_g" pos="5:3" access="rw">
            <comment>i_bit_g &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="i_bit_b" pos="2:0" access="rw">
            <comment>i_bit_b &#60;2:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="pmu_8809_3FH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_40H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="i_bit_clg" pos="15:14" access="rw">
            <comment>i_bit_clg &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="gbit_l_clg_reg" pos="13:11" access="rw">
            <comment>gbit_l_clg_reg &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="gbit_r_clg_reg" pos="10:8" access="rw">
            <comment>gbit_r_clg_reg &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="vncn_bit" pos="7:6" access="rw">
            <comment>vncn_bit &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="vclg_bit" pos="5:4" access="rw">
            <comment>vclg_bit &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="interface_mode_en" pos="3" access="rw">
        </bits>
        <bits name="no_detect_en" pos="2" access="rw">
        </bits>
        <bits name="ncn_en_l" pos="1" access="rw">
        </bits>
        <bits name="ncn_en_r" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_41H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reset_clg_delay_pos" pos="15:14" access="rw">
            <comment>reset_clg_delay_pos &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="reset_clg_delay_neg" pos="13:12" access="rw">
            <comment>reset_clg_delay_neg &#60;1:0&#62;
            </comment>
        </bits>
        <bits name="other_delay_pos" pos="11" access="rw">
        </bits>
        <bits name="other_delay_neg" pos="10" access="rw">
        </bits>
        <bits name="l_enable_clg" pos="9" access="rw">
        </bits>
        <bits name="r_enable_clg" pos="8" access="rw">
        </bits>
        <bits name="test_p_cp" pos="7" access="rw">
        </bits>
        <bits name="test_n_cp" pos="6" access="rw">
        </bits>
        <bits name="mono_l_r_sel" pos="5" access="rw">
        </bits>
        <bits name="dmode_en_clg" pos="4:2" access="rw">
            <comment>dmode_en_clg &#60;2:0&#62;
            </comment>
        </bits>
        <bits name="setup_tmctrl_bit" pos="1:0" access="rw">
            <comment>setup_tmctrl_bit &#60;1:0&#62;
            </comment>
        </bits>
    </reg>
    <reg name="pmu_8809_42H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pu_clg_dr" pos="15" access="rw">
        </bits>
        <bits name="pu_clg_reg" pos="14" access="rw">
        </bits>
        <bits name="pd_l_clg_dr" pos="13" access="rw">
        </bits>
        <bits name="pd_l_clg_reg" pos="12" access="rw">
        </bits>
        <bits name="pd_o_l_clg_dr" pos="11" access="rw">
        </bits>
        <bits name="pd_o_l_clg_reg" pos="10" access="rw">
        </bits>
        <bits name="pd_r_clg_dr" pos="9" access="rw">
        </bits>
        <bits name="pd_r_clg_reg" pos="8" access="rw">
        </bits>
        <bits name="pd_o_r_clg_dr" pos="7" access="rw">
        </bits>
        <bits name="pd_o_r_clg_reg" pos="6" access="rw">
        </bits>
        <bits name="reset_clg_dr" pos="5" access="rw">
        </bits>
        <bits name="reset_clg_reg" pos="4" access="rw">
        </bits>
        <bits name="reset_l_clg_dr" pos="3" access="rw">
        </bits>
        <bits name="reset_l_clg_reg" pos="2" access="rw">
        </bits>
        <bits name="reset_r_clg_dr" pos="1" access="rw">
        </bits>
        <bits name="reset_r_clg_reg" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_43H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:8" access="rw">
        </bits>
        <bits name="clg_l_det_out_h" pos="7" access="rw">
        </bits>
        <bits name="clg_r_det_out_h" pos="6" access="rw">
        </bits>
        <bits name="iov_l_det_out" pos="5" access="rw">
        </bits>
        <bits name="iov_r_det_out" pos="4" access="rw">
        </bits>
        <bits name="ncn_l_det_out" pos="3" access="rw">
        </bits>
        <bits name="ncn_r_det_out" pos="2" access="rw">
        </bits>
        <bits name="clg_l_det_out" pos="1" access="rw">
        </bits>
        <bits name="clg_r_det_out" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_44H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_45H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_46H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="pu_tsc_int_dr" pos="15" access="rw">
        </bits>
        <bits name="pu_tsc_int_reg" pos="14" access="rw">
        </bits>
        <bits name="pu_tsc_x_dr" pos="13" access="rw">
        </bits>
        <bits name="pu_tsc_x_reg" pos="12" access="rw">
        </bits>
        <bits name="pu_tsc_y_dr" pos="11" access="rw">
        </bits>
        <bits name="pu_tsc_y_reg" pos="10" access="rw">
        </bits>
        <bits name="key_int_en_dr" pos="9" access="rw">
        </bits>
        <bits name="key_int_en_reg" pos="8" access="rw">
        </bits>
        <bits name="key_en_dr" pos="7" access="rw">
        </bits>
        <bits name="key_en_reg" pos="6" access="rw">
        </bits>
        <bits name="tsc_enable_ana_dr" pos="5" access="rw">
        </bits>
        <bits name="tsc_enable_ana_reg" pos="4" access="rw">
        </bits>
        <bits name="pd_sar_dr" pos="3" access="rw">
        </bits>
        <bits name="pd_sar_reg" pos="2" access="rw">
        </bits>
        <bits name="sar_vref_ms_enable_tsc" pos="1" access="rw">
        </bits>
        <bits name="sar_vref_ms_enable_gpadc" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_47H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="reserved" pos="15:14" access="rw">
        </bits>
        <bits name="Nand_wp_out_dr" pos="13" access="rw">
        </bits>
        <bits name="nand_wp_en_reg" pos="12" access="rw">
        </bits>
        <bits name="nand_wp_vsel" pos="11:10" access="rw">
        </bits>
        <bits name="timer_rst_ext_sel" pos="9:8" access="rw">
        </bits>
        <bits name="vusb_pon_time_sel" pos="7:6" access="rw">
        </bits>
        <bits name="vusb_poff_time_sel" pos="5:4" access="rw">
        </bits>
        <bits name="reserved" pos="3:2" access="rw">
        </bits>
        <bits name="pa_en_dr" pos="1" access="rw">
        </bits>
        <bits name="pa_en_reg" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_48H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="Nand_wp_out_b_reg" pos="15" access="rw">
        </bits>
        <bits name="reserved" pos="14" access="rw">
        </bits>
        <bits name="Cnt_en_without_battery" pos="13" access="rw">
        </bits>
        <bits name="Vpad_vsel_efuse" pos="12" access="rw">
        </bits>
        <bits name="Va24_vsel" pos="11" access="rw">
        </bits>
        <bits name="Va24_ibit" pos="10:8" access="rw">
        </bits>
        <bits name="Hv_mode_bl" pos="7" access="rw">
        </bits>
        <bits name="Ix2_bl" pos="6" access="rw">
        </bits>
        <bits name="Idiv10_led" pos="5" access="rw">
        </bits>
        <bits name="Idiv40_rgb" pos="4" access="rw">
        </bits>
        <bits name="Double_mode_en_clg" pos="3" access="rw">
        </bits>
        <bits name="Clk_clg_en" pos="2" access="rw">
        </bits>
        <bits name="Vh_bit_clg" pos="1:0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_49H" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="cnt_out" pos="15:0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_4aH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="Vl_bit_clg" pos="15:14" access="rw">
        </bits>
        <bits name="Freq_clk_clg_sel" pos="13:12" access="rw">
        </bits>
        <bits name="Pulldown_vib" pos="11" access="rw">
        </bits>
        <bits name="Vbuck2_pon_time_sel" pos="10:9" access="rw">
        </bits>
        <bits name="Vbuck2_poff_time_sel" pos="8:7" access="rw">
        </bits>
        <bits name="Bl_dim_delay_clk_sel" pos="6:5" access="rw">
        </bits>
        <bits name="reserved" pos="4:1" access="rw">
        </bits>
        <bits name="Flag_resetn" pos="0" access="rw">
        </bits>
    </reg>
    <reg name="pmu_8809_4bH" protect="rw">
        <bits name="write_req" pos="31" access="rw">
        </bits>
        <bits name="read_req" pos="30" access="rw">
        </bits>
        <bits name="Vbuck1_ldo_bit_lp" pos="15:12" access="rw">
        </bits>
        <bits name="Vbuck1_ldo_bit_nlp" pos="11:8" access="rw">
        </bits>
        <bits name="reserved" pos="7:0" access="rw">
        </bits>
    </reg>

    
</module>
</archive>
<archive relative = "psram8_ctrl.xml">

<module name="psram8_ctrl" category="System">

  <reg name="ctrl_time" protect="rw">
    <bits access="rw" name="rl_type" pos="31:31" rst="0x0">
    </bits>
    <bits access="rw" name="rl" pos="29:24" rst="0x3">
    </bits>
    <bits access="rw" name="wl" pos="21:16" rst="0x0">
    </bits>
    <bits access="rw" name="w_tcph" pos="13:8" rst="0x7">
    </bits>
    <bits access="rw" name="r_tcph" pos="5:0" rst="0x3">
    </bits>
  </reg>

  <reg name="read_ctrl" protect="rw">
    <bits access="rw" name="fifo_rst_time" pos="17:12" rst="0x1">
    </bits>
    <bits access="rw" name="rd_start_mode" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw" name="opt_length" pos="7:4" rst="0x3">
    </bits>
    <bits access="rw" name="rd_start_num" pos="3:0" rst="0x7">
    </bits>
  </reg>

  <reg name="cre" protect="rw">
    <bits access="rw" name="cre" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dqs_ctrl" protect="rw">
    <bits access="rw" name="o_dqs_u_delay" pos="30:24" rst="0x0">
    </bits>
    <bits access="rw" name="o_dqs_l_delay" pos="22:16" rst="0x0">
    </bits>
    <bits access="rw" name="i_dqs_u_delay" pos="14:8" rst="0x0">
    </bits>
    <bits access="rw" name="i_dqs_l_delay" pos="6:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_ctrl" protect="rw">
    <bits access="rw" name="o_clk_delay" pos="6:0" rst="0x0">
    </bits>
  </reg>

  <reg name="power_up" protect="rw">
    <bits access="r" name="init_done" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw" name="hw_power_pulse" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="sw_init_done" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="sw_power_level" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="power_time" protect="rw">
    <bits access="rw" name="rst_wait_time" pos="25:16" rst="0x3ff">
    </bits>
    <bits access="rw" name="rst_tcph_time" pos="13:8" rst="0x7">
    </bits>
    <bits access="rw" name="rst_acc_time" pos="5:0" rst="0x5">
    </bits>
  </reg>

  <reg name="reg_time" protect="rw">
    <bits access="rw" name="nop_time" pos="21:16" rst="0xf">
    </bits>
    <bits access="rw" name="send_reg_time" pos="13:8" rst="0x3">
    </bits>
    <bits access="rw" name="read_reg_time" pos="5:0" rst="0xf">
    </bits>
  </reg>

  <reg name="irsr" protect="r">
    <bits access="r" name="irsr_cross_1k" pos="2:2" rst="0x0">
    </bits>
    <bits access="r" name="irsr_rd_timeout" pos="1:1" rst="0x0">
    </bits>
    <bits access="r" name="irsr_init_done" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="imr" protect="rw">
    <bits access="rw" name="imr_cross_1k" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="imr_rd_timeout" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="imr_init_done" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="isr" protect="r">
    <bits access="r" name="isr_cross_1k" pos="2:2" rst="0x0">
    </bits>
    <bits access="r" name="isr_rd_timeout" pos="1:1" rst="0x0">
    </bits>
    <bits access="r" name="isr_init_done" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="icr" protect="rw">
    <bits access="rw" name="icr_cross_1k" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="icr_rd_timeout" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="icr_init_done" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="debug_sel" protect="rw">
    <bits access="rw" name="debug_sel" pos="7:0" rst="0x0">
    </bits>
  </reg>

  <reg name="timeout_val" protect="rw">
    <bits access="rw" name="timeout_value" pos="19:0" rst="0x7ff">
    </bits>
  </reg>

</module>
</archive>
<archive relative = "pwm.xml">
<module name="pwm" category="Periph">
    <reg name="PWT_Config" protect="rw">
        <bits name="PWT_Enable" pos="0" access="rw" rst="0">
            <comment>Enables the Pulse Width Tone output
                <br/>1 = Enable PWT output
                <br/>0 = Disable PWT output
            </comment>            
        </bits>
        <bits name="PWT_Duty" pos="13:4" access="rw" rst="all1">
            <comment>The PWT_Duty value can be used to set the approximate volume of the tone.
                <br/> The PWT_Duty value must be less than or equal to half the PWT_Period value and must be at least a value of 8, otherwise no tone will be generated.
            </comment>
        </bits>
        <bits name="PWT_Period" pos="26:16" access="rw" rst="all1">
            <comment>PWT_Period is the divider value to produce a tone of a given frequency.
                <br/> To calculate the PWT_Period value, Use the following formula:
                <br/>  PWT_Period = FBASE/FNOTE
                <br/> where FBASE is the frequency of the PWM module clock (it is based on the system frequency, 26, 39, 52, 78 or 104 MHz divided by 5).  FNOTE is the frequency of the desired tone.
            </comment>
        </bits>        
    </reg>
    <reg name="LPG_Config" protect="rw">
        <bits name="LPG_Reset_L"    pos="0"     access="rw" rst="0">
            <comment>Setting this bit to '0' will reset the Light Pulse Generator internal counters.
            </comment>
          </bits>
        <bits name="LPG_Test"    pos="1"     access="rw" rst="0">
            <comment>Setting this bit to '0' will reset the Light Pulse Generator internal counters.
            </comment>
        </bits>          
        <bits name="LPG_OnTime" pos="7:4"   access="rw" rst="0xf">
            <comment>Configures the duty cycle for the Light Pulse Generator by setting the ontime for the LPG output. The actual on-time is calculated as: Tick Period * LPG_OnTime * 256 where the Tick Period is nominally 1/16kHz.
            </comment>
            <options>
                <option name="undefined" value="0"/>
                <option name="15_6mS" value="1"/>
                <option name="31_2mS" value="2"/>
                <option name="46_8mS" value="3"/>
                <option name="62mS" value="4"/>
                <option name="78mS" value="5"/>
                <option name="94mS" value="6"/>
                <option name="110mS" value="7"/>
                <option name="125mS" value="8"/>
                <option name="140mS" value="9"/>
                <option name="156mS" value="10"/>
                <option name="172mS" value="11"/>
                <option name="188mS" value="12"/>
                <option name="200mS" value="13"/>
                <option name="218mS" value="14"/>
                <option name="234mS" value="15"/>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="LPG_Period"     pos="18:16" access="rw" rst="0">
            <comment>Configures the main period of the light pulse generator. The period is calculated based on the following configurations:
            <br/>with the Tick Period ~ 1/16kHz<br/>
            </comment>
            <options>
                <option name="0_125s" value="0"><comment>Tick Period * 2048</comment></option>
                <option name="0_25s"  value="1"><comment>Tick Period * 4096</comment></option>
                <option name="0_5s"   value="2"><comment>Tick Period * 8192</comment></option>
                <option name="0_75s"  value="3"><comment>Tick Period * 12288</comment></option>
                <option name="1s"     value="4"><comment>Tick Period * 16384</comment></option>
                <option name="1_25s"  value="5"><comment>Tick Period * 20480</comment></option>
                <option name="1_5s"   value="6"><comment>Tick Period * 24576</comment></option>
                <option name="1_75s"  value="7"><comment>Tick Period * 28672</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name="PWL0_Config" protect="rw">
        <bits name="PWL_Min" pos="7:0" access="rw" rst="all1">
            <comment>Sets the lower boundary for PWL pulse.  When pulse mode is not used, this is the threshold value for the PWL0.  Reading this value will return the current value used for the threshold.
            </comment>
        </bits>
        <bits name="PWL_Max" pos="15:8" access="rw" rst="all1">
            <comment>Sets the upper boundary for PWL pulse.  When pulse mode is not used, this value is ignored.  Reading this value will return the LFSR value used for generating the PWL outputs.
            </comment>
        </bits>
        <bits name="PWL0_En_H" pos="16" access="rs" rst="0">
            <comment>When this bit is written with '1', the PWL 0 is enabled and the output is a PRBS whose average on-time is proportional to PWL_Min.  This bit is cleared when either of the Force bits are written.  Reading this bit will return the current state of the PWL0 enable.
            </comment>
        </bits>
        <bits name="PWL0_Force_L" pos="17" access="rc" rst="0">
            <comment>Writing a '1' to this bit will force the PWL0 to output a low value.  If the PWL0 was previously enabled, this will clear the bit.
            </comment>
        </bits>
        <bits name="PWL0_Force_H" pos="18" access="r" rst="no">
            <comment>Writing a '1' to this bit will force the PWL0 to output a high value.  If the PWL0 was previously enabled, this will clear the bit.
            </comment>
        </bits>
        <bits name="PWL_Pulse_En" pos="19" access="rw" rst="0">
            <comment>This will enable the PWL pulse mode.  The threshold will dynamically sweep between PWL_Min and PWL_Max at a rate depending on PWL_Pulse_Per.
            </comment>
        </bits>
        <bits name="PWL0_Set_OE" pos="20" access="rs" rst="0">
            <comment>Writing '1' to this bit will set the output enable.  Reading this bit will return the current status.
            </comment>
        </bits>
        <bits name="PWL0_Clr_OE" pos="21" access="c" rst="no">
            <comment>Writing '1' to this bit will clear the output enable.
            </comment>
        </bits>
        <bits name="PWL_Set_Mux" pos="22" access="rs" rst="0">
            <comment>Writing a '1' to this bit will swap the PWL0 and PWL1 outputs.  Reading this bit will return the current status.
            </comment>
        </bits>
        <bits name="PWL_Clr_Mux" pos="23" access="c" rst="no">
            <comment>Writing a '1' to this bit will unswap the PWL0/PWL1 outputs.
            </comment>
        </bits>
        <bits name="PWL_Pulse_Per" pos="31:24" access="w" rst="all1">
            <comment>This value will adjust the pulse period when pulsing is enabled.
            </comment>
        </bits>
    </reg>
    <reg name="PWL1_Config" protect="rw">
        <bits name="PWL1_Threshold"         pos="7:0"   access="rw" rst="all1">
            <comment>Average duty cycle for the Pulse Width Light 1 output. The average duty cycle is calculated as PWL1_Threshold/256.
            </comment>
        </bits>
        <bits name="LFSR_Reg"               pos="15:8"  access="r" rst="0xa1">
            <comment>LFSR value for PWL.
            </comment>
        </bits>
        <bits name="PWL1_En_H" pos="16" access="rs" rst="0">
            <comment>When this bit is written with '1', the PWL 1 is enabled and the output is a PRBS whose average on-time is proportional to PWL1_Threshold.  This bit is cleared when either of the Force bits are written.  Reading this bit will return the current state of the PWL1 enable.
            </comment>
        </bits>
        <bits name="PWL1_Force_L" pos="17" access="rc" rst="0">
            <comment>Writing a '1' to this bit will force the PWL1 to output a low value.  If the PWL1 was previously enabled, this will clear the bit.
            </comment>
        </bits>
        <bits name="PWL1_Force_H" pos="18" access="r" rst="no">
            <comment>Writing a '1' to this bit will force the PWL1 to output a high value.  If the PWL1 was previously enabled, this will clear the bit.
            </comment>
        </bits>
        <bits name="PWL1_Set_OE" pos="20" access="rs" rst="0">
            <comment>Writing '1' to this bit will set the output enable.  Reading this bit will return the current status.
            </comment>
        </bits>
        <bits name="PWL1_Clr_OE" pos="21" access="c" rst="no">
            <comment>Writing '1' to this bit will clear the output enable.
            </comment>
        </bits>
    </reg>
    <reg name="TSC_DATA" protect="r">
        <bits name="TSC_X_Value" pos="9:0" access="r" rst="0">
          <comment>TSC X Value. </comment>
          <options>
            <mask/>
            <shift/>
          </options>
        </bits>
        <bits name="TSC_X_Value_valid" pos="10" access="r" rst="0">
            <comment>TSC X Value valid. </comment>
        </bits>
        <bits name="TSC_Y_Value" pos="20:11" access="r" rst="0">
            <comment>TSC Y Value. </comment>
            <options>
              <mask/>
              <shift/>
            </options>
        </bits>
        <bits name="TSC_Y_Value_valid" pos="21" access="r" rst="0">
            <comment>TSC Y Value valid. </comment>
        </bits>
    </reg>
    <reg name="GPADC_DATA" protect="r">
        <bits name="GPADC_Value" pos="9:0" access="r" rst="0">
            <comment>GPADC Value. </comment>
            <options>
              <mask/>
              <shift/>
            </options>
        </bits>
        <bits name="GPADC_Value_valid" pos="10" access="r" rst="0">
            <comment>GPADC Value valid. </comment>
        </bits>
    </reg>
</module>
</archive>
<archive relative = "regdef.xml" asm="no">
<cjoker>
/* Set or not mips16 */
#ifdef CT_ASM_MIPS16
#define SET_P_MIPS16 .set mips16
#else
#define SET_P_MIPS16 .set nomips16
#endif 

#define zero    $0
#define AT      $at
#define v0      $2
#define v1      $3
#define a0      $4
#define a1      $5
#define a2      $6
#define a3      $7
#define t0      $8
#define t1      $9
#define t2      $10
#define t3      $11
#define t4      $12
#define t5      $13
#define t6      $14
#define t7      $15
#define s0      $16
#define s1      $17
#define s2      $18
#define s3      $19
#define s4      $20
#define s5      $21
#define s6      $22
#define s7      $23
#define t8      $24
#define t9      $25
#define k0      $26
#define k1      $27
#define gp      $28
#define sp      $29
#define fp      $30
#define ra      $31

#define r0      $0
#define r1      $1
#define r2      $2
#define r3      $3
#define r4      $4
#define r5      $5
#define r6      $6
#define r7      $7
#define r8      $8
#define r9      $9
#define r10     $10
#define r11     $11
#define r12     $12
#define r13     $13
#define r14     $14
#define r15     $15
#define r16     $16
#define r17     $17
#define r18     $18
#define r19     $19
#define r20     $20
#define r21     $21
#define r22     $22
#define r23     $23
#define r24     $24
#define r25     $25
#define r26     $26
#define r27     $27
#define r28     $28
#define r29     $29
#define r30     $30
#define r31     $31

#define fp0     $f0
#define fp1     $f1
#define fp2     $f2
#define fp3     $f3
#define fp4     $f4
#define fp5     $f5
#define fp6     $f6
#define fp7     $f7
#define fp8     $f8
#define fp9     $f9
#define fp10    $f10
#define fp11    $f11
#define fp12    $f12
#define fp13    $f13
#define fp14    $f14
#define fp15    $f15
#define fp16    $f16
#define fp17    $f17
#define fp18    $f18
#define fp19    $f19
#define fp20    $f20
#define fp21    $f21
#define fp22    $f22
#define fp23    $f23
#define fp24    $f24
#define fp25    $f25
#define fp26    $f26
#define fp27    $f27
#define fp28    $f28
#define fp29    $f29
#define fp30    $f30
#define fp31    $f31

#define fpucntl $31

</cjoker>
</archive>
<archive relative = "rf_if.xml">
<module name="rf_if" category="Baseband">

  <reg protect="rw" name="Buffer">
    <bits access="rw" name="Rx_Tx data" pos="31:0" rst="no">
      <comment>In read mode this register contains the sample received on the Rx chain. I component is located on bit[15:0] and Q component is located on bit[31:16].
      <br />This register accesses to the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data sample arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overflow error will also occur.
      <br />The data written[29:0] into this register is the data transmitted. Any attempt to write data when the FIFO is full results in the write data being lost.
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="Ctrl">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <options>
        <option name="Disable" value="0" />
        <option name="Enable" value="1" />
      </options>
      <comment>Turn on/off the rf_if interface</comment>
    </bits>
    
    <bits access="rw" name="DigRF Enable" pos="1" rst="0">
      <options>
        <option name="Disable" value="0"><comment>Analog more selected</comment></option>
        <option name="Enable" value="1"><comment>DigRF mode selected</comment></option>
      </options>
      <comment>Turn on/off the DigRF mode</comment>
    </bits>
    
    <bits access="rw" name="Rx overflow Enable" pos="4" rst="1">
      <options>
        <option name="Disable" value="0"><comment>Disable (mask) Rx fifo overflow interrupt</comment></option>
        <option name="Enable" value="1"><comment>Enable Rx fifo overflow interrupt</comment></option>
      </options>
      <comment>Rx Fifo Overflow interrupt Enable</comment>
    </bits>
    
    <bits access="rw" name="Rx Cal Bypass" pos="5" rst="1">
      <options>
        <option name="Enabled" value="0" />
        <option name="Bypassed" value="1" />
      </options>
      <comment>Calibration bypass</comment>
    </bits>
    
    <bits access="rw" name="Rx Swap I_Q" pos="6" rst="0">
      <options>
        <option name="NO" value="0"><comment>No Swap</comment></option>
        <option name="YES" value="1"><comment>Swap I/Q</comment></option>
      </options>
      <comment>Rx swap I/Q</comment>
    </bits>
    
    <bits access="rw" name="Rx Force ADC On" pos="7" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Rx_On output controlled by TCO_RX_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced ADC on;Rx_On output always high</comment></option>
      </options>
      <comment>Force Rx On. This bit is used only with the analog option.</comment>
    </bits>

    <bits access="rw" name="Rx Force Dec On" pos="8" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, decimator controlled by Rx_dec_on signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced; decimator always on</comment></option>
      </options>
      <comment>Force Decimator On</comment>
    </bits>
    
    <bits access="w" name="Rx Force SOC" pos="9" rst="no">
      <comment>Force start of calibation in receive mode
        <br />Writing a 1 to this bit launch the calibration phase. Write only bit, this bit doesn't need to be cleared.
      </comment>
    </bits>
    
    <bits access="w" name="Rx Fifo Reset" pos="10" rst="no">
      <comment>Writing a 1 to this bit resets and flush the receive Fifo. 
        <br />Write only bit, this bit doesn't need to be cleared.
      </comment>
    </bits>
    
  
    <bits access="rw" name="Tx overflow Enable" pos="16" rst="1">
      <options>
        <option name="Disable" value="0"><comment>Disable (mask) Tx fifo overflow interrupt</comment></option>
        <option name="Enable" value="1"><comment>Enable Tx fifo overflow interrupt</comment></option>
      </options>
      <comment>Tx Fifo Overflow interrupt Enable</comment>
    </bits>
    
    <bits access="rw" name="Tx underflow Enable" pos="17" rst="1">
      <options>
        <option name="Disable" value="0"><comment>Disable (mask) Tx fifo undeflow interrupt</comment></option>
        <option name="Enable" value="1"><comment>Enable Tx fifo underflow interrupt</comment></option>
      </options>
      <comment>Tx Fifo Underflow interrupt Enable:</comment>
    </bits>
    
    <bits access="rw" name="Tx Force DAC On" pos="18" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Tx_On output controlled by TCO_TX_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced DAC on; Tx_On output always high</comment></option>
      </options>
      <comment>Force DAC On. This bit is used only with the analog option.</comment>
    </bits>
    
    <bits access="rw" name="Tx Force DAC Off" pos="19" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Tx_On output controlled by TCO_TX_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced DAC Off; Tx_On output always low</comment></option>
      </options>
      <comment>Force DAC Off. This bit is used only with the analog option.</comment>
    </bits>


    <bits access="rw" name="Tx Force oen" pos="20" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Tx_Oen controlled by TCO_TX_OEN signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced; Tx_Oen always high, Low pass output in HZ</comment></option>
      </options>
      <comment>Force Tx Oen. This bit is used only with the analog option.</comment>
    </bits>
  
    <bits access="rw" name="Tx Force GMSK On" pos="21" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, transmit serial interface controlled by TCO_GMSK_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced; serializer always enabled</comment></option>
      </options>
      <comment>Force GMSK On.</comment>
    </bits>
    <bits access="rw" name="Tx Swap I_Q" pos="22" rst="0">
      <options>
        <option name="NO" value="0"><comment>No Swap</comment></option>
        <option name="YES" value="1"><comment>Swap I/Q</comment></option>
      </options>
      <comment>Tx swap I/Q. This bit is used only with the analog option.</comment>
    </bits>
 
    <bits access="w" name="Tx Fifo Reset" pos="23" rst="no">
      <comment>Writing a 1 to this bit resets and flush the transmit Fifo. 
        <br />Write only bit, this bit doesn.t need to be cleared.
      </comment>
    </bits>
    
    <bits access="rw" name="DigRF Rx Rate" pos="24" rst="1">
      <options>
        <option name="ONE" value="0"><comment>One sample per symbol</comment></option>
        <option name="TWO" value="1"><comment>Two samples per symbol</comment></option>
      </options>
      <comment>Rx rate for DigRF interface. This bit is used only when DigRF is enabled (DigRF Enabled)
      </comment>
    </bits>
    
    <bits access="rw" name="DigRF Rx Clk Pol" pos="25" rst="1">
      <comment>Change the polarity of the DigRF Rx clock. This bit is used only when DigRF is enabled (DigRF Enabled)
        <br />0 = No inversion
        <br />1 = Invert clock polarity
      </comment>
    </bits>
    
    <bits access="rw" name="DigRF Tx mode" pos="26" rst="1">
      <options>
        <option name="Stream" value="0"></option>
        <option name="Block" value="1"></option>
      </options>
      <comment>Tx mode for the DigRF interface. This bit is used only when DigRF is enabled (DigRF Enabled)
      </comment>
    </bits>

    <bits access="rw" name="DigRF Tx Clk Pol" pos="27" rst="1">
      <comment>Change the polarity of the DigRF Rx clock. This bit is used only when DigRF is enabled (DigRF Enabled)
        <br />0 = No inversion
        <br />1 = Invert clock polarity
      </comment>
    </bits>

    <bits access="rw" name="DigRF Sample Size" pos="30:28" rst="all1" display="hex">
      <comment>Shift input sample in DigRF mode only. 
        <br />The Rx sample are on 16-bit, this field select a variable of bit among 16.
        <br />000 = 16-bit selected
        <br />001 = 15-bit selected 
        <br />010 = 14-bit selected
        <br />011 = 13-bit selected
        <br />100 = 12-bit selected
      </comment>
    </bits>
    <bits access="rw" name="DigRF Alignement Select" pos="31" rst="1" display="hex">
      <comment>Select the sample alignement in DigRF mode only.. 
        <br />0 = MSB aligned sample
        <br />1 = LSB aligned sample 
      </comment>
    </bits>
  </reg>
  

    <reg protect="r" name="Status">
      <bits access="r" name="Rx Fifo level" pos="4:0" rst="0">
        <comment>Those bits indicate the number of data available in the Rx Fifo.</comment>
      </bits>
      <bits access="r" name="Tx Fifo level" pos="6:5" rst="0">
        <comment>Those bits indicate the number of data available in the Tx Fifo. Those data will be sent.
        </comment>
      </bits>
      <bits access="r" name="Rx Overflow Cause" pos="8" rst="0">
        <comment>Rx overflow cause register
        <br />This bit indicates that an interruption was generated when the Rx fifo is overflow. 
        <br />This bit is cleared when the Rx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits access="r" name="Tx Overflow Cause" pos="9" rst="0">
        <comment>Tx overflow cause register
        <br />This bit indicates that an interruption was generated when the Tx fifo is overflow. 
        <br />This bit is cleared when the Tx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits access="r" name="Tx Underflow Cause" pos="10" rst="0">
        <comment>Tx underflow cause register
        <br />This bit indicates that an interruption was generated when the Tx fifo is underflow. 
        <br />This bit is cleared when the Tx_underflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits access="r" name="Rx Overflow Status" pos="16" rst="0">
        <comment>This bit indicates that the receiver received a new sample when the FIFO was already full. 
        <br />The new sample is discarded. This bit is cleared when the Rx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
      <bits access="r" name="Tx Overflow Status" pos="17" rst="0">
        <comment>This bit indicates that the user tried to write on the FIFO while it was already full. 
        <br />This bit is cleared when the Tx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
      <bits access="r" name="Tx Underflow Status" pos="18" rst="0">
        <comment>This bit indicates that the modulator tried to read on the FIFO while it was empty. 
        <br />This bit is cleared when the Tx_Underflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
    </reg>

    <reg protect="w" name="Interruption_clear">
      <bits access="w" name="Rx Overflow" pos="0" rst="no">
        <comment>Clear Rx Interrupt Overflow interrupt.
        </comment>
      </bits>
      <bits access="w" name="Tx Overflow" pos="1" rst="no">
        <comment>Clear Tx Interrupt Overflow interrupt.
        </comment>
      </bits>
      <bits access="w" name="Tx Underflow" pos="2" rst="no">
        <comment>Clear Tx Interrupt Underflow interrupt.
        </comment>
      </bits>
    </reg>
    <reg count="4" name="Tx Burst descriptor" protect="rw">
        <bits name="NB symbols" pos="7:0" access="rw" rst="0">
            <comment>Number of symbol to transmit
            </comment>
        </bits>
        <bits name="Modulation" pos="16" access="rw" rst="0">
            <comment>0 for GMSK, 1 for 8PSK 
            </comment>
        </bits>
        <bits name="End Burst" pos="24" access="rw" rst="0">
            <comment>Indicate an end of the transmit for this current burst
            </comment>
        </bits>
    </reg>

    <reg protect="r" name="Rx Offset">
      <bits access="r" name="Rx_Offset_I" pos="15:0" rst="all0" display="hex">
        <comment>Rx offset measured after calibration for I channel
        </comment>
      </bits>
      <bits access="r" name="Rx_Offset_Q" pos="31:16" rst="all0" display="hex">
        <comment>Rx offset measured after calibratio for Q channel
        </comment>
      </bits>
    </reg>
</module>
</archive>
<archive relative = "rf_spi.xml">

    <var    name="CMD_FIFO_LEN_BITS" value="5"/>
    <var    name="CMD_FIFO_LEN" value="20"/> 
    <var    name="CMD_SIZE_BITS" value="8"/>
    
    <var    name="CMD_DATA_FIFO_LEN_BITS" value="4"/>
    <var    name="CMD_DATA_FIFO_LEN" value="exp2(CMD_DATA_FIFO_LEN_BITS)"/>
    
    <var    name="GAIN_TABLE_LEN_BITS" value="4"/>
    <var    name="GAIN_TABLE_LEN" value="15"/>  
    <var    name="GAIN_SIZE_BITS" value="4"/>

    <var    name="RX_DATA_FIFO_LEN_BITS" value="2"/>
    <var    name="RX_DATA_FIFO_LEN" value="exp2(RX_DATA_FIFO_LEN_BITS)"/>
    

<module name="rf_spi" category="Modem">

    <reg name="Ctrl" protect="rw">
        <bits name="Enable"         pos="0"     access="rw" rst="0">
            <comment>Enable the rf spi
                <br/>1 = Enable
                <br/>0 = Disable (will finish current command anyway)
            </comment>
        </bits>
        <bits name="CS_Polarity"    pos="1"     access="rw" rst="1">
            <comment>Chip select polarity
                <br/>1 = the chip select is active low
                <br/>0 = the chip select is active high
            </comment>
        </bits>
        <bits name="DigRF_Read"     pos="2"     access="rw" rst="1">
            <comment>DigRF Read style mode
                <br/>1 = DigRF Read style mode (read after CS disabled)
                <br/>0 = SPI Read mode (read during write)
            </comment>
        </bits>
        <bits name="Clocked_Back2Back"  pos="3" access="rw" rst="1">
            <comment>DigRF style clocked back to back mode
                <br/>1 = clocked back to back transfers using turnarround timing only when more data are present in the FIFO.
                <br/>0 = stop the clock between each access according to CS_End_Hold and CS_Pulse_Min timings
            </comment>
        </bits>
        <bits name="Input_Mode"     pos="4"     access="rw" rst="1">
            <comment>Input mode
                <br/>1 = Record input data to input FIFO
                <br/>0 = No input data
            </comment>
        </bits>
        <bits name="Clock_Polarity" pos="5"     access="rw" rst="1">
            <comment>SPI Clock polarity
                <br/>1 = the clock disabled level is high, and the first edge is a falling edge.
                <br/>0 = the clock disabled level is low, and the first edge is a rising edge.
            </comment>
        </bits>
        <bits name="Clock_Delay"    pos="7:6"   access="rw" rst="3">
            <comment>Transfer start to first edge delay
                <br/> value from 0 to 2 is the number of spi clock half period between the Transfer start and the first clock edge.
            </comment>
        </bits>
        <bits name="DO_Delay"       pos="9:8"   access="rw" rst="3">
            <comment>Transfer start to first data out delay
                <br/> value from 0 to 2 is the number of spi clock half period between the Transfer start and the first data out.
            </comment>
        </bits>
        <bits name="DI_Delay"       pos="11:10" access="rw" rst="3">
            <comment>Transfer start to first data in sampled delay
                <br/> value from 0 to 3 is the number of spi clock half period between the Transfer start and the first data sampled in.
                <br/> The DI_Delay only specify the sampling time, for frame size, the counter is based on the DO_Delay even in DigRF read mode.
            </comment>
        </bits>
        <bits name="CS_Delay"       pos="13:12" access="rw" rst="3">
            <comment>Transfer start to CS activation delay
                <br/> value from 0 to 3 is the number of spi clock half period between the Transfer start and the CS activation edge.
            </comment>
        </bits>
        <bits name="CS_End_Hold"    pos="15:14" access="rw" rst="3">
            <comment>Transfer end to chip select deactivation delay
                <br/> value from 0 to 3 is the number of spi clock half period between the end of transfer (DO) and the CS deactivation edge.
                <br/> <Strong>Not used for Clocked_Back2Back mode</Strong>
            </comment>
        </bits>
        <bits name="Frame_Size"     pos="20:16" access="rw" rst="31">
            <comment>Number of data in the frame, or number of out data in DigRF read mode.
                <br/>The actual frame size is the value of this register + 1; valid value are 3 to 31 (frame size 4 to 32bits)
                <br/>The frame size is given for the number of data, the actual number of clock pulses might be greater. First if Clock_Delay &lt; DO_Delay an extra clock pulse is generated, second in case of DigRF read or back2back, some more clock pulses will be generated.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="CS_End_Pulse"   pos="23:22" access="rw" rst="3">
            <comment>Chip select deactivation to new start of transfer minimum delay
                <br/>value from 0 to 3 is the number of spi clock half period between the CS deactivation and a new transfer start (transfer will start only if more data are available in the transmit FIFO)
                <br/> <Strong>Not used for Clocked_Back2Back mode</Strong>
            </comment>
        </bits>
        <bits name="Input_Frame_Size"   pos="28:24" access="rw" rst="31">
            <comment>Frame Size For Input in DigRF input mode
                <br/>The actual frame size is the value of this register + 1; valid value are 3 to 31 (frame size 4 to 32bits)
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="TurnAround_Time"    pos="31:30" access="rw" rst="3">
            <comment>TurnAround time: end of write frame to start of read frame delay (in cycles)
                <br/>value from 0 to 3 is the number of spi clock period between the end of the output frame (without the DO_Delay) and the Input Frame start.
                <br/>Also used for Clocked_Back2Back mode, when Clocked_Back2Back=1 and there is more data available in the transmit FIFO:
                <br/>value from 0 to 3 is the number of spi clock period between the end of the frame (without the DO_Delay) and the start of the new frame.
                (It can also be seen as the number of spi clock period between the end of the last data bit and the start of the new data bit.)
            </comment>
        </bits>
    </reg>
    <reg name="Status" protect="rw">
        <bits name="Active_Status"      pos="0"     access="r" rst="0">
            <comment>The SPI activity status
                <br/>1 = A transfer is in progress
                <br/>0 = The transfer is done
            </comment>
        </bits>
        <bits name="Error_Cmd"          pos="1"     access="rc" rst="0">
            <comment>Error status
                <br/>1 = a new command (or gain) has been requested while a command was in progress.
                <br/>0 = No error
                <br/>Write 1 to clear.
            </comment>
        </bits>
        <bits name="Table_Ovf"          pos="6"     access="rc" rst="0">
            <comment>The Gain Table overflow status.
                <br/>1 = Too many data has been written in the table
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Table_Udf"          pos="7"     access="rc" rst="0">
            <comment>The Gain Table underflow status.
                <br/> 1 = a next gain request has been received while the read pointer was already at the top of the table.
                <br/> Writing a '1' clear the underflow status.
            </comment>
        </bits>
        <bits name="Cmd_Level"          pos="CMD_FIFO_LEN_BITS+7:8" access="r" rst="0">
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Command FIFO level, number of command in the FIFO
            </comment>
        </bits>
        <bits name="Cmd_Ovf"            pos="14"    access="rc" rst="0">
            <comment>The command FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Cmd_Udf"            pos="15"    access="rc" rst="0">
            <comment>The command FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
        <bits name="Cmd_Data_Level"     pos="CMD_DATA_FIFO_LEN_BITS+16:16"  access="r" rst="0">
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Command FIFO level, number of bytes in the FIFO
            </comment>
        </bits>
        <bits name="Cmd_Data_Ovf"       pos="22"    access="rc" rst="0">
            <comment>The command data FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Cmd_Data_Udf"       pos="23"    access="rc" rst="0">
            <comment>The command data FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
        <bits name="Rx_Level"           pos="RX_DATA_FIFO_LEN_BITS+24:24"   access="r" rst="0">
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Receive FIFO level, number of bytes in the FIFO
            </comment>
        </bits>
        <bits name="Rx_Ovf"             pos="30"    access="rc" rst="0">
            <comment>The receive FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Rx_Udf"             pos="31"    access="rc" rst="0">
            <comment>The receive FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
    </reg>
    <reg name="Rx_Data" protect="">
        <bits name="Rx_Data"    pos="7:0"   access="rw"  rst="no">
            <comment>Read in the receive FIFO
                <br/>Writing this register will write to Cmd_Data fifo (same as Cmd_Data register). This is because this address is used by the IFC channels to access the fifos.
            </comment>
        </bits>
    </reg>
    <reg name="Command" protect="w">
        <bits name="Send_Cmd"           pos="0"     access="w" rst="0">
            <comment> Writing 1 send the next command in the Cmd FIFO (This replace the TCU next cmd signal)
            </comment>
        </bits>
        <bits name="Flush_Cmd_FIFO"     pos="8"     access="w" rst="0">
            <comment>Writing 1 flush both Cmd, and cmd_data FIFO, <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name="Flush_Rx_FIFO"      pos="16"    access="w" rst="0">
            <comment>Writing 1 flush the receive data FIFO, <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name="Restart_Gain"       pos="24"    access="w" rst="0">
            <comment>Writing 1 place the read pointer at the beginning of the gain table. <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name="Reload_Gain"        pos="28"    access="w" rst="0">
            <comment>Writing 1 place the write pointer at the beginning of the gain table allowing to fill the table.
            </comment>
        </bits>
        <bits name="Drive_Zero"         pos="31"    access="rw" rst="1">
            <comment>Writing 1 change all the ouputs of the SPI interface to drive a logical '0'. This mode stops when a new command is requested to be send (by TCU) or when writting 0 to this register. This mode is useful when powering off the tranciever chip connected to the RF_SPI.
            </comment>
        </bits>
    </reg>
    <reg name="Cmd_Size" protect="w">
        <bits name="Cmd_Size"    pos="CMD_SIZE_BITS-1:0"   access="w"  rst="no">
            <comment>Write the size in bytes of the next command in the FIFO
            </comment>
        </bits>
        <bits name="Cmd_Mark"   pos="31"    access="w"  rst="no">
            <comment>Write 1 to mark the command.
                <br/>Marked commands are discarded if Enable_Rf_Spi_Marked_Cmd is low in the tcu register.
            </comment>
        </bits>
    </reg>
    <reg name="Cmd_Data" protect="w">
        <bits name="Cmd_Data"    pos="7:0"   access="w"  rst="no">
            <comment>Write in the Command data FIFO
            </comment>
        </bits>
    </reg>
    <reg name="Gain_Size" protect="rw">
        <bits name="Gain_Size"   pos="GAIN_SIZE_BITS-1:0"   access="rw"  rst="0">
            <comment>Size of a Gain command in bytes.
            </comment>
        </bits>
    </reg>
    <reg name="Gain_Data" protect="w">
        <bits name="Gain_Data"   pos="7:0"   access="w"  rst="no">
            <comment>Write in the Gain Table (the pointer auto increments)
            </comment>
        </bits>
    </reg>
    <reg name="IRQ" protect="rw">
        <bits name="Cmd_Data_DMA_Done_Cause"    pos="0" access="rc" rst="0">
            <comment>Cmd_Data_DMA_Done IRQ Cause bit
                <br/> 1 = the IRQ was triggered by the end of the DMA transfer to the cmd FIFO.
                <br/> To clear it write 1 in this bit or Cmd_Data_DMA_Done_Status bit.
            </comment>
        </bits>
        <bits name="Cmd_FIFO_empty_Cause"       pos="2" access="r" rst="0">
            <comment>Cmd_FIFO_empty IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Cmd_FIFO is empty.
                <br/> To clear it, fill the FIFO.
            </comment>
        </bits>
        <bits name="Cmd_Threshold_Cause"        pos="3" access="r" rst="0">
            <comment>Cmd_Threshold IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Cmd_FIFO level is below the Cmd_Threshold.
                <br/> To clear it, fill the FIFO.
            </comment>
        </bits>
        <bits name="Rx_FIFO_full_Cause"         pos="4" access="r" rst="0">
            <comment>Rx_FIFO_full IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Rx_Data_FIFO is full.
                <br/> To clear it, read from the FIFO.
            </comment>
        </bits>
        <bits name="Rx_Threshold_Cause"         pos="5" access="r" rst="0">
            <comment>Rx_Threshold IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Rx_Data_FIFO level is over the Rx_Threshold.
                <br/> To clear it, read from the FIFO.
            </comment>
        </bits>
        <bits name="Error_Cause"                pos="6" access="r" rst="0">
            <comment>Error IRQ Cause bit
                <br/> 1 = the IRQ was triggered because an error occured. Read the Status register to check the kind of error.
                <br/> To clear it, clear it in the Status register.
            </comment>
        </bits>
        <bitgroup name="All_Cause">
            <entry ref="Cmd_Data_DMA_Done_Cause"/>
            <entry ref="Cmd_FIFO_empty_Cause"/>
            <entry ref="Cmd_Threshold_Cause"/>
            <entry ref="Rx_FIFO_full_Cause"/>
            <entry ref="Rx_Threshold_Cause"/>
            <entry ref="Error_Cause"/>
        </bitgroup>
        <bits name="Cmd_Data_DMA_Done_Status"   pos="16"    access="rc" rst="0">
            <comment>Cmd_Data_DMA_Done IRQ Status bit
                <br/> 1 = the end of the DMA transfer to the cmd FIFO occured.
                <br/> To clear it write 1 in this bit or Cmd_Data_DMA_Done_Cause bit.
            </comment>
        </bits>
        <bits name="Cmd_FIFO_empty_Status"      pos="18"    access="r" rst="1">
            <comment>Cmd_FIFO_empty IRQ Status bit
                <br/> 1 = the Cmd_FIFO is empty.
            </comment>
        </bits>
        <bits name="Cmd_Threshold_Status"       pos="19"    access="r" rst="1">
            <comment>Cmd_Threshold IRQ Status bit
                <br/> 1 = the Cmd_FIFO level is bellow the Cmd_Threshold.
            </comment>
        </bits>
        <bits name="Rx_FIFO_full_Status"        pos="20"    access="r" rst="0">
            <comment>Rx_FIFO_full IRQ Status bit
                <br/> 1 = the Rx_Data_FIFO is full.
            </comment>
        </bits>
        <bits name="Rx_Threshold_Status"        pos="21"    access="r" rst="0">
            <comment>Rx_Threshold IRQ Status bit
                <br/> 1 = the Rx_Data_FIFO level is over the Rx_Threshold.
            </comment>
        </bits>
        <bits name="Error_Status"               pos="22"    access="r" rst="0">
            <comment>Error IRQ Status bit
                <br/> 1 = an error occured. Read the Status register to check the kind of error.
            </comment>
        </bits>
        <bitgroup name="All_Status">
            <entry ref="Cmd_Data_DMA_Done_Status"/>
            <entry ref="Cmd_FIFO_empty_Status"/>
            <entry ref="Cmd_Threshold_Status"/>
            <entry ref="Rx_FIFO_full_Status"/>
            <entry ref="Rx_Threshold_Status"/>
            <entry ref="Error_Status"/>
        </bitgroup>
    </reg>
    <reg name="IRQ_Mask" protect="rw">
        <bits name="Cmd_Data_DMA_Done_Mask"     pos="0" access="rw" rst="0">
            <comment>Cmd_Data_DMA_Done IRQ Mask bit
                <br/> 1 = the Cmd_Data_DMA_Done IRQ is enabled
                <br/> 0 = the Cmd_Data_DMA_Done IRQ is disabled
            </comment>
        </bits>
        <bits name="Cmd_FIFO_empty_Mask"        pos="2" access="rw" rst="0">
            <comment>Cmd_FIFO_empty IRQ Mask bit
                <br/> 1 = the Cmd_FIFO_empty IRQ is enabled
                <br/> 0 = the Cmd_FIFO_empty IRQ is disabled
            </comment>
        </bits>
        <bits name="Cmd_Threshold_Mask"         pos="3" access="rw" rst="0">
            <comment>Cmd_Threshold IRQ Mask bit
                <br/> 1 = the Cmd_Threshold IRQ is enabled
                <br/> 0 = the Cmd_Threshold IRQ is disabled
            </comment>
        </bits>
        <bits name="Rx_FIFO_full_Mask"          pos="4" access="rw" rst="0">
            <comment>Rx_FIFO_full IRQ Mask bit
                <br/> 1 = the Rx_FIFO_full IRQ is enabled
                <br/> 0 = the Rx_FIFO_full IRQ is disabled
            </comment>
        </bits>
        <bits name="Rx_Threshold_Mask"          pos="5" access="rw" rst="0">
            <comment>Rx_Threshold IRQ Mask bit
                <br/> 1 = the Rx_Threshold IRQ is enabled
                <br/> 0 = the Rx_Threshold IRQ is disabled
            </comment>
        </bits>
        <bits name="Error_Mask"                 pos="6" access="rw" rst="0">
            <comment>Error IRQ Mask bit
                <br/> 1 = the Error IRQ is enabled
                <br/> 0 = the Error IRQ is disabled
            </comment>
        </bits>
        <bitgroup name="All_Mask">
            <entry ref="Cmd_Data_DMA_Done_Mask"/>
            <entry ref="Cmd_FIFO_empty_Mask"/>
            <entry ref="Cmd_Threshold_Mask"/>
            <entry ref="Rx_FIFO_full_Mask"/>
            <entry ref="Rx_Threshold_Mask"/>
            <entry ref="Error_Mask"/>
        </bitgroup>
    </reg>
    <reg name="IRQ_Threshold" protect="rw">
        <bits name="Cmd_Threshold"      pos="CMD_FIFO_LEN_BITS+7:8" access="r" rst="all1">
            <comment>Command FIFO Threshold, number of command in the FIFO bellow which the Cmd_Threshold_IRQ is triggered.
            </comment>
        </bits>
        <bits name="Rx_Threshold"       pos="RX_DATA_FIFO_LEN_BITS+23:24"   access="r" rst="all1">
            <comment>Receive FIFO Threshold, number of bytes in the FIFO above which the Rx_Threshold_IRQ is triggered.
            </comment>
        </bits>
    </reg>
    <reg name="Divider" protect="rw">
        <bits name="Divider"    pos="6:1"   access="rw" rst="0">
            <comment>Clock Divider
                <br/>The state machine clock is generated by dividing the system clock by the value of this register + 1. So the output clock is divided by (register + 1)*2
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Clock_Limiter" pos="28" access="rw" rst="0">
            <comment>When enabled the clock input to the divider is not the system clock, but a limited version of it: It cannot be above 52MHz, so the output clock will never be above 26MHz.
                <br/> for system clock of 104Mhz the clock input to the divider is 52Mhz, for system clock of 78Mhz the clock input to the divider is 39Mhz, for lower system clock value, the input to the divider is the system clock.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
</module>
</archive>
<archive relative = "sci.xml">
<module name="sci" category="Modem">
    <reg name="Config" protect="rw">
        <bits name="Enable" pos="0" access="rw" rst="0">
            <comment>Enables the SIM Card IF module
            </comment>
        </bits>
        <bits name="Parity" pos="1" access="rw" rst="0">
            <comment>Selects the parity generation/detection
            </comment>
            <options>
                <option value="0" name="Even_parity"/>
                <option value="1" name="Odd_parity"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="PERF" pos="2" access="rw" rst="0">
            <comment>Parity Error Receive Feed-through
                <br/>0 = Don't store bytes with detected parity errors
                <br/>1 = Feed-through bytes with detected parity errors
            </comment>
        </bits>
        <bits name="Filter_Disable" pos="3" access="rw" rst="0">
            <comment>Enable or disable NULL (0x60) character filtering when SIM card sends NULL to reset WWT timer.
                <br/>0 = Enable NULL character filtering, NULL characters are not reported if not data.
                <br/>1 = Disable NULL character filtering.  NULL characters (0x60) are transferred to the SCI data buffer.
            </comment>
        </bits>
        <bits name="ClockStop" pos="4" access="rw" rst="1">
            <comment>Manual SCI Clock Stop control.  Manually starts and stops the SCI clock.  This bit must be set to '1' when Autostop mode is enabled.
                <br/>0 = Enable the SCI clock
                <br/>1 = Disable SCI clock
            </comment>
        </bits>
        <bits name="AutoStop_En_H" pos="5" access="rw" rst="0">
            <comment>Enables automatic clock shutdown when command is complete.  Enabling this will generate the necessary startup and shutdown delays required by the SIM protocol.
                <br/>0 = Auto clock control not enabled.  SCI clock controlled by SCI_Clockstop bit
                <br/>1 = Auto clock control enabled.
            </comment>
        </bits>
        <bits name="MSBH_LSBL" pos="6" access="rw" rst="1">
            <comment>Sets the transmission and reception bit order:
                <br/>0 = LSB is sent/recieved first (Direct convention)
                <br/>1 = MSB is sent/received first (Inverse convention)
            </comment>
        </bits>
        <bits name="LLI" pos="7" access="rw" rst="1">
            <comment>Logic Level Invert:
                <br/>0 = Logic level 0 data is sent/received as '0' or 'A' which is the same as the start bit.  (Direct convention)
                <br/>1 = Logic level 0 data is sent/received as '1' or 'Z' which is the opposite of the start bit.  (Inverse convention)
            </comment>
        </bits>
        <bits name="PEGen_Len" pos="8" access="rw" rst="0">
            <comment>Parity Error signal length.  This configuration bit can be used to extend the duration of the parity error signal generation from 1 ETU to 1.5 ETU
                <br/>0 = Parity Error signal duration is 1 ETU starting at 10.5 ETU
                <br/>1 = Parity Error signal duration is 1.5 ETU starting at 10.5 ETU
            </comment>
        </bits>
        <bits name="Parity_En" pos="9" access="rw" rst="0">
            <comment>Enable or disable parity error checking on the receive data
                <br/>0 = Disable parity error checking
                <br/>1 = Enable parity error checking
            </comment>
        </bits>
        <bits name="Stop_Level" pos="10" access="rw" rst="1">
            <comment>Logical value of the clock signal when SCI clock is stopped (either due to automatic shutdown or manual shutdown)
                <br/>0 = Stop clock at low level
                <br/>1 = Stop clock at high level
            </comment>
        </bits>
        <bits name="ARG_H" pos="16" access="rw" rst="0">
            <comment>Automatic Reset Generator.  Write a '1' to this bit to initiate an automatic reset procedure on the SIM.  Write '0' to switch back to SCI_Reset control (bit 20).  An ARG interrupt will be generated if the ARG process succeeded or failed.  The ARG status bit (ARG_Det) must be read to determine if a reset response from the card was detected.  This bit needs to be cleared between ARG attempts.
            </comment>
        </bits>
        <bits name="AFD_En_H" pos="17" access="rw" rst="0">
            <comment>Automatic format detection.  This bit is generally set in conjunction with the ARG_H bit to enable automatic detection of the data convention.
                <br/>1 = Enable TS detection and automatic convention settings programming
                <br/>0 = disable automatic settings and use the register bits (MSBH_LSBL and LLI) to control the convention
            </comment>
        </bits>
        <bits name="Tx_Resend_En_H" pos="18" access="rw" rst="1">
            <comment>1 = Enable automatic resend of characters when Tx parity error is detected
                <br/>0 = Disable automatic resend
            </comment>
        </bits>
        <bits name="Reset" pos="20" access="rw" rst="0">
            <comment>Direct connection to the SIM card reset pin.  This is overridden when ARG_H is enabled
                <br/>0 = SCI_Reset low voltage
                <br/>1 = SCI Reset high voltage
            </comment>
        </bits>
        <bits name="Dly_Sel" pos="21" access="rw" rst="0">
            <comment>This selects between two delay times for the automatic clock stop startup and shutdown:
                <br/>0 = short delay
                <br/>Startup/Shutdown : 744 SCI clocks / 1860 SCI clocks
                <br/>1 = long delay
                <br/>Startup/Shutdown : (2 x 744) SCI clocks / (2 x 1860) SCI clocks
            </comment>
        </bits>
        <bits name="In_avg_en" pos="22" access="rw" rst="1">
            <comment>Input data average enable.
                <br/>0 = Disable
                <br/>1 = Enable
            </comment>
        </bits>
        <bits name="Par_Chk_Offset" pos="29:24" access="rw" rst="0xe">
            <comment>Allows fine control of the parity check position during the parity error time period.
            </comment>
        </bits>
        <bits name="Sci_Mode" pos="31:30" access="rw" rst="0">
            <comment>These bits are reserved and must be written as '00' for the SCI module to work properly:
                <br/>"11" = Ser In &lt;- Ser Out loopback
                <br/>"10" = Ser In &lt;- Ser In (unmasked)
                <br/>others = Ser In &lt;- Ser In masked with Txing_H (normal mode)
            </comment>
        </bits>
    </reg>
    <reg name="Status" protect="r">
        <bits name="RxData_Rdy" pos="0" access="r" rst="0">
            <comment>Returns the status of the Rx FIFO:
                <br/>0 = Rx FIFO empty
                <br/>1 = There is at least 1 character in the Rx FIFO
            </comment>
        </bits>
        <bits name="Tx_FIFO_Rdy" pos="1" access="r" rst="1">
            <comment>Returns the status of the Tx FIFO:
                <br/>0 = Tx FIFO is full
                <br/>1 = There is at least 1 free spot in the Tx FIFO
            </comment>
        </bits>
        <bits name="Format_Det" pos="2" access="r" rst="0">
            <comment>Returns the status of the automatic format detection after reset:
                <br/>0 = TS character has not been detected in the ATR
                <br/>1 = TS character has been detected and SCI module is using the automatic convention settings
                <br/>
                <br/>This bit is cleared when the AFD_En bit is cleared
            </comment>
        </bits>
        <bits name="ARG_Det" pos="3" access="r" rst="0">
            <comment>Returns the status of the automatic reset procedure:
                <br/>0 = ARG detection has failed
                <br/>1 = ARG detection has detected that the SIM has responded to the reset
                <br/>
                <br/>This bit is used in conjunction with the ARG interrupt.  The ARG interrupt will be generated at the successful or unsuccessful termination of the ARG process.  This bit can be used to determine the success or failure.
            </comment>
        </bits>
        <bits name="Reset_Det" pos="4" access="r" rst="0">
            <comment>This is the status of the Reset pin when automatic reset generation is enabled.  This bit can be used to discover whether the SIM card that has successfully responded to an ARG procedure has an active high or active low reset. (Det means 'Detection')
            </comment>
        </bits>
        <bits name="Clk_Rdy_H" pos="5" access="r" rst="0">
            <comment>Status of the control signal to the clock control module.  This bit respects the startup and shutdown phases, so during these times, the clock may actually be on, but it is not considered to be 'ready'
                <br/>0 = SCI clock may be on or off but is not ready for use
                <br/>1 = SCI clock is on and ready for use
            </comment>
        </bits>
        <bits name="Clk_Off" pos="6" access="r" rst="1">
            <comment>Status bit of the Sci clock. 
                <br/>0 = Sci clock is ON
                <br/>1 = Sci clock is OFF
            </comment>
        </bits>
        <bits name="Rx_Err" pos="8" access="r" rst="0">
            <comment>A receive parity error was detected. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name="Tx_Err" pos="9" access="r" rst="0">
            <comment>A transmit parity error was detected. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name="RxOverflow" pos="10" access="r" rst="0">
            <comment>The internal receive FIFO has reached an overflow condition. Reading this register clears the bit.
            </comment>
        </bits> 
        <bits name="TxOverflow" pos="11" access="r" rst="0">
            <comment>The internal transmit FIFO has reached an overflow condition. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name="AutoStop_State" pos="31:30" access="r" rst="0">
            <comment>Returns the state of the clock management state machine when AutoStop mode is enabled.  This value is '00' when manual mode is selected.
            </comment>
            <options>
                <option value="0" name="Startup_phase"><comment>Clock is on, but not ready to be used.</comment></option>
                <option value="1" name="Auto_on"><comment>Clock is on and ready to be used</comment></option>
                <option value="2" name="Shutdown_phase"><comment>Clock is still on, but should not be used.</comment></option>
                <option value="3" name="Clock_off"><comment>Clock is off.</comment></option>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name="Data" protect="--">
        <bits name="Data_IN" pos="7:0" access="w" rst="0">
            <comment>Writing to this register will send the data to the SIM card. If automatic clock shutdown is enabled, the appropriate delay will be applied before the data is actually sent. 
            </comment>
        </bits>
        <bits name="Data_OUT" pos="7:0" access="r" rst="0">
            <comment>Reading this register will read from the receive data FIFO.
            </comment>
        </bits>
    </reg>
    <reg name="ClkDiv" protect="rw">
        <bits name="ClkDiv" pos="8:0" access="rw" rst="0x174">
            <comment>Clock divider for generating the baud clock from the SCI clock.  This value must match the value used by the SIM card whose default value is 0x174.
            </comment>
        </bits>
        <bits name="Baud_x8_En" pos="9" access="rw" rst="0">
            <comment>Speed mode enable.
                <br/>0 = Low speed mode
                <br/>1 = High speed mode(372/32, 372/64, 512/64)
            </comment>
        </bits>
        <bits name="Rx_Clk_Cnt_Limit" pos="14:10" access="rw" rst="0x10">
            <comment>Rx_clk_cnt wrap value.
            </comment>
         </bits>
        <bits name="Clk_Tst" pos="15" access="rw" rst="0">
          </bits>
        <bits name="ClkDiv_16" pos="23:16" access="rw" rst="0x18">
            <comment>Secondary clock divider for generating 16x baud clock.
            </comment>
        </bits>
        <bits name="MainDiv" pos="29:24" access="rw" rst="0x4">
            <comment>Main clock divider to generate the SCI clock.  This value should be calculated as follows:
                <br/>MainDiv = Clk_Sys/(2xSCI_Clk) - 1
                <br/>where SCI_Clk is in the range of 3-5 MHz as specified in the SIM specification.
            </comment>
            <options><mask/><default/></options>
        </bits>
        <bits name="Clk_Out_Inv" pos="30" access="rw" rst="0">
            <comment>Inverts the polarity of the SCI clock to the SIM card only.
                <br/>0 = No inversion
                <br/>1 = Invert external SCI clock
            </comment>
        </bits>
        <bits name="Clk_Inv" pos="31" access="rw" rst="0">
            <comment>Inverts  SCI clock to the SIM card .
                <br/>0 = No inversion
                <br/>1 = Invert external SCI clock
            </comment>
        </bits>
    </reg>
    <reg name="RxCnt" protect="rw">
        <bits name="RxCnt" pos="9:0" access="rw" rst="0">
            <comment>This value should be programmed with the number of expected characters to receive.  It will be decremented each time a character is <strong>actually</strong> received and should be 0 when the transfer is complete.  If a character is sent after the RxCnt reaches zero, the extra character flag will be set but this value will stay at zero.
            </comment>
        </bits>
        <bits name="Clk_Persist" pos="31" access="rw" rst="0">
            <comment>When in automatic clock shutdown mode, this bit can prevent the clock from entering shutdown mode when the transfer is complete.  This should be used for multi-transfer commands where the clock must not be shut down until the command is complete.  This bit must be programmed for each transfer.
                <br/>1 = Keep clock on
                <br/>0 = Allow clock shutdown when transfer is complete
            </comment>
        </bits>
    </reg>
    <reg name="Times" protect="rw">
        <bits name="ChGuard" pos="7:0" access="rw" rst="1">
            <comment>This is the extra guard time that can be added to the 2 ETU minimum (and default) guard time between successive transmitted characters.  This should be programmed depending on the SIM's ATR.  The total ETU guard time will be ChGuard + 1.
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="TurnaroundGuard" pos="11:8" access="rw" rst="0x6">
            <comment>Turnaround guard time configuration.  This value can be used to adjust the delay between the leading edge of a received character and the leading edge of the next transmitted character.  The minimum time specified in the SIM recommendation is 16 ETU.  The number of ETUs can be calculated using the following formula:
                <br/>Total Turnaround Time (in ETUs) = 11 + TurnaroundGuard
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="WI" pos="23:16" access="rw" rst="0x0A">
            <comment>Work Waiting Time factor.  A timeout will be generated when the WWT is exceeded.  The WWT is calculated by:
                <br/>       WWT = 960 x WI x (F/Fi)
                <br/>where Fi is the main SCI clock frequency (3-5 MHz) and F is 372 before an enhanced PPS and 512 after an enhanced PPS.
                <br/>The SCI_WI value must be calculated as follows:
                <br/>       SCI_WI = WI * D
                <br/>Thus, by default (WI = 10) this value needs to be set to 10 before an EPPS, but needs to be scaled to WI*D=80 after the EPPS procedure.
            
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="Tx_PERT" pos="31:24" access="rw" rst="0xFF">
            <comment>Number of times to try resending character when the SIM indicates a parity error.
            </comment>
        </bits>
    </reg>  
    <reg name="Ch_Filt" protect="rw">
        <bits name="Ch_Filt" pos="7:0" access="rw" rst="0x60">
            <comment>Value of the character to be filtered.  0x60 is the NULL character in the SIM protocol.  If character filtering is enabled, the <strong>first</strong> 0x60 character that is received by the SIM during a transfer will <strong>not</strong> be recorded.  The purpose of this character is to enable the SIM to reset the WWT counter when the SIM is not ready to send the data.  This filter has no effect on characters within the datastream.
            </comment>
        </bits>
    </reg>  
    
    <reg name="dbg" protect="w">
        <bits name="FIFO_RX_Clr" pos="0" access="w" rst="0">
            <comment>Clear RX FIFO.
            </comment>
        </bits>     
        <bits name="FIFO_TX_Clr" pos="1" access="w" rst="0">
            <comment>Clear TX FIFO.
            </comment>
        </bits>     
        <comment>UNDOCUMENTED FEATURE</comment>
    </reg>  
    <reg name="Int_Cause" protect="r">
        <bits name="Rx_Done" pos="0" access="r" rst="0">
            <comment>Number of expected Rx characters, as programmed in the RxCnt register, has been received.
            </comment>
        </bits>
        <bits name="Rx_Half" pos="1" access="r" rst="0">
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name="WWT_Timeout" pos="2" access="r" rst="0">
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name="Extra_Rx" pos="3" access="r" rst="0">
            <comment>An extra character has been received after the number of characters in RxCnt has been received.
            </comment>
        </bits>
        <bits name="Resend_Ovfl" pos="4" access="r" rst="0">
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the Tx_PERT field.
            </comment>
        </bits>     
        <bits name="ARG_End" pos="5" access="r" rst="0">
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Tx_Done" pos="6" access="r" rst="0">
            <comment>DMA tx done.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Rx_Done" pos="7" access="r" rst="0">
            <comment>DMA rx done.
            </comment>
        </bits>     
        <comment>
            This register is a <b>READ ONLY</b> register that returns the logical <b>and</b> of the SCI_INT_STATUS register and the SCI_INT_MASK. If any of these bits is '1', the SCI module will generate an interrupt.  Bits 21:16 return the <u>status</u> of the interrupt which is the interrupt state before the mask is applied.  These bits should only be used for debugging.
        </comment>
    </reg>  
    <reg name="Int_Clr" protect="rw">
        <bits name="Rx_Done" pos="0" access="c" rst="0">
            <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.
            </comment>
        </bits>
        <bits name="Rx_Half" pos="1" access="c" rst="0">
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name="WWT_Timeout" pos="2" access="c" rst="0">
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name="Extra_Rx" pos="3" access="c" rst="0">
            <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.
            </comment>
        </bits>
        <bits name="Resend_Ovfl" pos="4" access="c" rst="0">
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.
            </comment>
        </bits>     
        <bits name="ARG_End" pos="5" access="c" rst="0">
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Tx_Done" pos="6" access="c">
            <comment>DMA tx done.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Rx_Done" pos="7" access="c">
            <comment>DMA rx done.
            </comment>
        </bits>     
        <comment>
            This is a WRITE ONLY register that is used to clear an SCI interrupt. Write a '1' to the interrupt that is to be cleared. Writing '0' has no effect.
        </comment>
    </reg>  
    <reg name="Int_Mask" protect="rw">
        <bits name="Rx_Done" pos="0" access="rw" rst="0">
            <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.
            </comment>
        </bits>
        <bits name="Rx_Half" pos="1" access="rw" rst="0">
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name="WWT_Timeout" pos="2" access="rw" rst="0">
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name="Extra_Rx" pos="3" access="rw" rst="0">
            <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.
            </comment>
        </bits>
        <bits name="Resend_Ovfl" pos="4" access="rw" rst="0">
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.
            </comment>
        </bits>     
        <bits name="ARG_End" pos="5" access="rw" rst="0">
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>  
        <bits name="Sci_DMA_Tx_Done" pos="6" access="rw" rst="0">
            <comment>DMA tx done.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Rx_Done" pos="7" access="rw" rst="0">
            <comment>DMA rx done.
            </comment>
        </bits>     
        <comment>
            This register is READ/WRITE register that enables the desired interrupt. A '1' in a bit position indicates that the corresponding interrupt is enabled and if the interrupt occurs, the SCI will generate a hardware interrupt.
        </comment>
    </reg>  
</module>
</archive>
<archive relative = "sdmmc.xml">

<module name="sdmmc" category="Periph">


    <reg name="apbi_ctrl_sdmmc" protect="rw">
       <bits name="L_Endian"  pos="2:0" access="rw" rst="000">
          <comment>Controls the big endian or little endian of the FIFO data.
              <br/>Take 32 bit data 0X0A0B0C0D for Example,bit[31:24]=Byte3,bit[23:16]=Byte2,bit[15:8]=Byte1,bit[7:0]=Byte0.
              <br/>"000": the order is not changed.
                <br/>Byte3="0A",Byte2="0B",Byte1="0C",Byte0="0D".
              <br/>"001": reversed on byte.
                <br/>Byte3="0D",Byte2="0C,Byte1="0B",Byte0="0A".
              <br/>"010": reversed on half word.
                <br/>Byte3="0C",Byte2="0D,Byte1="0A",Byte0="0B".
              <br/>"010": reversed on bit.
                <br/>Byte3="B0",Byte2="30,Byte1="D0",Byte0="50".
              <br/>"100": reversed on bit.
                <br/>Byte3="0A",Byte2="0X,Byte1="0D",Byte0="0C".
          </comment>
       </bits> 
       <bits name="Soft_rst_L" pos="3" access="rw" rst="1">
          <comment>For the software to clear FIFO in case there is an error in communication with SD controller and some data are left behind.
              <br/>Active Low.
          </comment>
       </bits>
     </reg>

     <hole size="32"/>

     <reg name="APBI_FIFO_TxRx"  protect="--">   
         <bits name="DATA_IN" pos="31:0" access="w" rst="0">
           <comment>Write to the transmit FIFO
           </comment>
         </bits>
         <bits name="DATA_OUT" pos="31:0" access="r" rst="0">
           <comment>Read in the receive FIFO
           </comment>
         </bits>
     </reg>



<hole size="16288"/>

<reg protect="rw" name="SDMMC_CONFIG">

	<bits access="rw" name="SDMMC_SENDCMD" pos="0" rst="0">
		<comment>SD/MMC operation begin register, active high.<br /> 
		When '1', the controller finishes the last command and goes into suspend status. At suspend status, the controller will not execute the next command until the bit is set '0'.
		</comment>
	</bits>
	
	<bits access="rw" name="SDMMC_SUSPEND" pos="1" rst="1">
		<comment>SD/MMC operation suspend register, active high.
		</comment>
	</bits>
	
	<bits access="rw" name="RSP_EN" pos="4" rst="0">
		<comment>'1'indicates having a response,'0'indicates no response.
		</comment>
	</bits>
	
    <bits access="rw" name="RSP_SEL" pos="6:5" rst="0">
        <options>
            <default/>
            <option name="R2" value="0b10"/>
            <option name="R3" value="0b01"/>
            <option name="OTHER" value="0b00"/>
        </options>
		<comment>Response select register,"10" means R2 response, "01" means R3 response, "00" means others response, "11" is reserved.
		</comment> 
	</bits>
	
    <bits access="rw" name="RD_WT_EN" pos="8" rst="0">
		<comment>'1' indicates data operation, which includes read and write.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_WT_SEL" pos="9" rst="0">
        <options>
            <default/>
            <option name="READ" value="0"/>
            <option name="WRITE" value="1"/>
        </options>
		<comment>'1' means write operation,'0' means read operation.
		</comment>
	</bits>
	
	<bits access="rw" name="S_M_SEL" pos="10" rst="0">
        <options>
            <default/>
            <option name="SIMPLE"   value="0"/>
            <option name="MULTIPLE" value="1"/>
        </options>
		<comment>'1'means multiple block data operation.
		</comment>
	</bits>
	<bits access="rw" name="AUTO_FLAG_EN" pos="16" rst="1">
	</bits>
	
</reg>
	
<reg protect="r" name="SDMMC_STATUS">

	<bits access="r" name="Not_SDMMC_OVER" pos="0" rst="0">
		<comment>'1' means the SD/MMC operation is not over.
		</comment>
	</bits>
		
	<bits access="r" name="BUSY" pos="1" rst="0">
		<comment>'1' means SD/MMC is busy.
		</comment>
	</bits>	

	<bits access="r" name="DL_BUSY" pos="2" rst="0">
		<comment>'1' means the data line is busy.
		</comment>
	</bits>
	
	<bits access="r" name="SUSPEND" pos="3" rst="1">
		<comment>'1' means the controller will not perform the new command when SDMMC_SENDCMD= '1'.
		</comment>
	</bits>

	
	
		

	<bits access="r" name="RSP_ERROR" pos="8" rst="0">
		<comment>Response CRC checks error register '1' means response CRC check error.
		</comment>
	</bits>
	
	<bits access="r" name="NO_RSP_ERROR" pos="9" rst="0">
		<comment>'1' means the card has no response to command. 
		</comment>
	</bits>
	
	<bits access="r" name="CRC_STATUS" pos="14:12" rst="0">
		<comment>CRC check for SD/MMC write operation <br /> 
		"101" transmission error<br />
		"010" transmission right<br />
		"111" flash programming error
		</comment>
	</bits>
	
	<bits access="r" name="DATA_ERROR" pos="23:16" rst="0">
		<comment>8 bits data CRC check, "00000000" means no data error, "00000001" means DATA0 CRC check error, "10000000" means DATA7 CRC check error, each bit match one data line.
		</comment>
	</bits>

	<bits access="r" name="DAT3_VAL" pos="24" rst="-">
		<comment>SDMMC DATA 3 value.
		</comment>
	</bits>
	
</reg>

<reg protect="rw" name="SDMMC_CMD_INDEX">

	<bits access="rw" name="COMMAND" pos="5:0" rst="0">
		<comment>SD/MMC command register.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_CMD_ARG">

	<bits access="rw" name="ARGUMENT" pos="31:0" rst="0">
		<comment>SD/MMC command argument register, write data to the SD/MMC card.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_INDEX">

	<bits access="r" name="RESPONSE" pos="5:0" rst="0">
		<comment>SD/MMC response index register.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG3">

	<bits access="r" name="ARGUMENT3" pos="31:0" rst="0">
		<comment>Response argument of R1, R3 and R6, or 127 to 96 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG2">

	<bits access="r" name="ARGUMENT2" pos="31:0" rst="0">
		<comment>95 to 64 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG1">

	<bits access="r" name="ARGUMENT1" pos="31:0" rst="0">
		<comment>63 to 32 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG0">

	<bits access="r" name="ARGUMENT0" pos="31:0" rst="0">
		<comment>31 to 0 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_DATA_WIDTH">

	<bits access="rw" name="SDMMC_DATA_WIDTH" pos="3:0" rst="0">
		<comment>SD/MMC data width:<br />
		0x1: 1 data line<br />
		0x2: 2 reserved<br />
		0x4: 4 data lines<br />
		0x8: 8 data lines
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_SIZE">

	<bits access="rw" name="SDMMC_BLOCK_SIZE" pos="3:0" rst="0">
		<comment>SD/MMC size of one block:<br />
		0-1:reserved<br />
		2: 1 word<br />
		3: 2 words<br />
		4: 4 words<br />
		5: 8 words<br />
		6: 16 words<br />
 		      ¡­ <br />
		11: 512 words<br />
		12-15 reserved
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_CNT">

	<bits access="rw" name="SDMMC_BLOCK_CNT" pos="15:0" rst="0">
		<comment>Block number that wants to transfer.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_INT_STATUS">

	<bits access="r" name="NO_RSP_INT" pos="0" rst="0">
		<comment>'1' means no response.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_INT" pos="1" rst="0">
		<comment>'1' means CRC error of response.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_INT" pos="2" rst="0">
		<comment>'1' means CRC error of reading data.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_INT" pos="3" rst="0">
		<comment>'1' means CRC error of writing data.
		</comment>
	</bits>

	<bits access="r" name="DAT_OVER_INT" pos="4" rst="0">
		<comment>'1' means data transmission is over.
		</comment>
	</bits>

	<bits access="r" name="TXDMA_DONE_INT" pos="5" rst="0">
		<comment>'1' means tx dma done.
		</comment>
	</bits>

	<bits access="r" name="RXDMA_DONE_INT" pos="6" rst="0">
		<comment>'1' means rx dma done.
		</comment>
	</bits>
	
	<bits access="r" name="NO_RSP_SC" pos="8" rst="0">
		<comment>'1' means no response is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_SC" pos="9" rst="0">
		<comment>'1' means CRC error of response is the source of interrupt.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_SC" pos="10" rst="0">
		<comment>'1' means CRC error of reading data is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_SC" pos="11" rst="0">
		<comment>'1' means CRC error of writing data is the source of interrupt.
		</comment>
	</bits>
	 
	<bits access="r" name="DAT_OVER_SC" pos="12" rst="0">
		<comment>'1' means the end of data transmission is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="TXDMA_DONE_SC" pos="13" rst="0">
		<comment>'1' means tx dma done is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="RXDMA_DONE_SC" pos="14" rst="0">
		<comment>'1' means rx dma done is the source of interrupt.
		</comment>
	</bits>    
	
</reg>



<reg protect="rw" name="SDMMC_INT_MASK">

	<bits access="rw" name="NO_RSP_MK" pos="0" rst="0">
		<comment>When no response, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="RSP_ERR_MK" pos="1" rst="0">
		<comment>When CRC error of response, '1' means INT is disable.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_ERR_MK" pos="2" rst="0">
		<comment>When CRC error of reading data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="WR_ERR_MK" pos="3" rst="0">
		<comment>When CRC error of writing data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="DAT_OVER_MK" pos="4" rst="0">
		<comment>When data transmission is over, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="TXDMA_DONE_MK" pos="5" rst="0">
		<comment>when tx dma done, '1' means INT is disabled.
		</comment>
	</bits>

	<bits access="rw" name="RXDMA_DONE_MK" pos="6" rst="0">
		<comment>'1' means rx dma done, '1' means INT is disabled.
		</comment>
	</bits>    
</reg>


<reg protect="w" name="SDMMC_INT_CLEAR">

	<bits access="w" name="NO_RSP_CL" pos="0" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in NO_RSP_SC.
		</comment>
	</bits>

	<bits access="w" name="RSP_ERR_CL" pos="1" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RSP_ERR_SC.
		</comment>
	</bits>
	
	<bits access="w" name="RD_ERR_CL" pos="2" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RD_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="WR_ERR_CL" pos="3" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in WR_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="DAT_OVER_CL" pos="4" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in DAT_OVER_SC.
		</comment>
	</bits>

 	<bits access="w" name="TXDMA_DONE_CL" pos="5" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in TXDMA_DONE_SC.
		</comment>
	</bits>

	<bits access="w" name="RXDMA_DONE_CL" pos="6" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RXDMA_DONE_SC.
		</comment>
	</bits>   
</reg>

<reg protect="rw" name="SDMMC_TRANS_SPEED">

	<bits access="rw" name="SDMMC_TRANS_SPEED" pos="7:0" rst="0">
		<comment>Mclk = Pclk/(2*(SDMMC_TRANS_SPEED +1)).
		</comment>
	</bits>
</reg>

<reg protect="rw" name="SDMMC_MCLK_ADJUST">

	<bits access="rw" name="SDMMC_MCLK_ADJUST" pos="3:0" rst="0">
		<comment>This register may delay the mclk output. 
			 When MCLK_ADJUSTER = n, Mclk is outputted with  n Pclk.	
		</comment>
	</bits>

	<bits access="rw" name="CLK_INV" pos="4" rst="0">
		<comment>Invert Mclk.	
		</comment>
	</bits>

</reg>

</module>
</archive>
<archive relative = "seg_scan.xml">

<module name="seg_scan" category="System">

    <reg name="code_num_reg" protect="rw">
        <bits name="code_num"   pos="4:0"   access="rw" rst="5'h7">
            <comment> configure  the range (1-18) of code number  registers
            </comment>
        </bits>
    </reg>

    <reg name="refresh_cycle_reg" protect="rw"  >
        <bits name="refresh_cycle"   pos="31:0" access="rw" rst="32'hffff">
            <comment>configure the refreshed cycle in pclk domain when change output data from another code number register.
            </comment>
        </bits>
    </reg>

    <reg name="ctrl" protect="rw">
        <bits name="start"    pos="0"     access="rw" rst="0">
            <comment>this is a pulse signal
            </comment>
        </bits>
        <bits name="stop"    pos="1"     access="rw" rst="0">
            <comment>this is a pulse signal
            </comment>
        </bits>
        <bits name="load_en"   pos="2"     access="rw" rst="0">
            <comment>hardware enable and software clear.
            </comment>
        </bits>
    </reg>

    <reg name="code0_reg" protect="rw"  >
        <bits name="code0" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 0 output.
            </comment>
        </bits>
    </reg>

    <reg name="code1_reg" protect="rw"  >
        <bits name="code1" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 1 output.
            </comment>
        </bits>
    </reg>

    <reg name="code2_reg" protect="rw"  >
        <bits name="code2" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 2 output.
            </comment>
        </bits>
    </reg>

    <reg name="code3_reg" protect="rw"  >
        <bits name="code3" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 3 output.
            </comment>
        </bits>
    </reg>

    <reg name="code4_reg" protect="rw"  >
        <bits name="code4" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 4 output.
            </comment>
        </bits>
    </reg>

    <reg name="code5_reg" protect="rw"  >
        <bits name="code5" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 5 output.
            </comment>
        </bits>
    </reg>

    <reg name="code6_reg" protect="rw"  >
        <bits name="code6" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 6 output.
            </comment>
        </bits>
    </reg>

    <reg name="code7_reg" protect="rw"  >
        <bits name="code7" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 7 output.
            </comment>
        </bits>
    </reg>

    <reg name="code8_reg" protect="rw"  >
        <bits name="code8" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 8 output.
            </comment>
        </bits>
    </reg>

    <reg name="code9_reg" protect="rw"  >
        <bits name="code9" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 9 output.
            </comment>
        </bits>
    </reg>

    <reg name="code10_reg" protect="rw"  >
        <bits name="code10" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 10 output.
            </comment>
        </bits>
    </reg>

    <reg name="code11_reg" protect="rw"  >
        <bits name="code11" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 11 output.
            </comment>
        </bits>
    </reg>

    <reg name="code12_reg" protect="rw"  >
        <bits name="code12" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 12 output.
            </comment>
        </bits>
    </reg>

    <reg name="code13_reg" protect="rw"  >
        <bits name="code13" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 13 output.
            </comment>
        </bits>
    </reg>

    <reg name="code14_reg" protect="rw"  >
        <bits name="code14" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 14 output.
            </comment>
        </bits>
    </reg>

    <reg name="code15_reg" protect="rw"  >
        <bits name="code15" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 15 output.
            </comment>
        </bits>
    </reg>

    <reg name="code16_reg" protect="rw"  >
        <bits name="code16" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 16 output.
            </comment>
        </bits>
    </reg>

    <reg name="code17_reg" protect="rw"  >
        <bits name="code17" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 17 output.
            </comment>
        </bits>
    </reg>


    <reg name="pin_oen0_reg" protect="rw" > 
        <bits name="pin_oen0" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 0 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen1_reg" protect="rw"  >
        <bits name="pin_oen1" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 1 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen2_reg" protect="rw"  >
        <bits name="pin_oen2" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 2 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen3_reg" protect="rw"  >
        <bits name="pin_oen3" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 3 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen4_reg" protect="rw"  >
        <bits name="pin_oen4" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 4 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen5_reg" protect="rw"  >
        <bits name="pin_oen5" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 5 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen6_reg" protect="rw"  >
        <bits name="pin_oen6" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 6 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen7_reg" protect="rw"  >
        <bits name="pin_oen7" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 7 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen8_reg" protect="rw"  >
        <bits name="pin_oen8" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 8 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen9_reg" protect="rw"  >
        <bits name="pin_oen9" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 9 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen10_reg" protect="rw"  >
        <bits name="pin_oen10" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 10 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen11_reg" protect="rw"  >
        <bits name="pin_oen11" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 11 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen12_reg" protect="rw"  >
        <bits name="pin_oen12" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 12 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen13_reg" protect="rw"  >
        <bits name="pin_oen13" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 13 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen14_reg" protect="rw"  >
        <bits name="pin_oen14" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 14 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen15_reg" protect="rw"  >
        <bits name="pin_oen15" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 15 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen16_reg" protect="rw"  >
        <bits name="pin_oen16" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 16 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen17_reg" protect="rw"  >
        <bits name="pin_oen17" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 17 of pin_oen.
            </comment>
        </bits>
    </reg>


</module>
</archive>
<archive relative = "spi.xml">
<var name = "SPI_TX_FIFO_SIZE" value="16"/>
<var name = "SPI_RX_FIFO_SIZE" value="16"/>

<module name="spi" category="Periph">
    <reg name="ctrl" protect="rw">
        <bits name="Enable"  pos="0" access="rw" rst="0">
            <comment>Enable the module and activate the chip select selected by CS_sel field.
            </comment>
        </bits>
        <bits name="CS_sel" pos="2:1" access="rw" rst="0">
            <comment>Selects the active CS.
            </comment>
            <options>
                <option name="CS0" value="0"/>
                <option name="CS1" value="1"/>
                <option name="CS2" value="2"/>
                <option name="CS3" value="3"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="Input_mode" pos="4" access="rw"  rst="1">
            <comment>When set to 1 the inputs are activated, else only the output is driven and no data are stored in the receive FIFO.
                <br/>Notes: The Input_mode bit status is also readable onto the bit rxtx_buffer[31].
            </comment>
        </bits>
        <bits name="Clock_Polarity" pos="5" access="rw" rst="1">
            <comment>The spi clock polarity
                <br/>when '0' the clock disabled level is low, and the first edge is a rising edge.
                <br/>When '1' the clock disabled level is high, and the first edge is a falling edge.
            </comment>
        </bits>
        <bits name="Clock_Delay" pos="7:6" access="rw" rst="3">
            <comment>Transfer start to first edge delay value from 0 to 2 is the number of spi clock half period between the CS activation and the first clock edge.
            </comment>
        </bits>
        <bits name="DO_Delay" pos="9:8" access="rw" rst="3">
            <comment>Transfer start to first data out delay value from 0 to 2 is the number of spi clock half period between the CS activation and the first data out
            </comment>
        </bits>
        <bits name="DI_Delay" pos="11:10" access="rw" rst="3">
            <comment>Transfer start to first data in sample delay value from 0 to 3 is the number of spi clock half period between the CS activation and the first data in sampled.
                <br/>NOTE: DI_Delay must be less or equal to DO_Delay + CS_Delay + 2.
                <br/>In other words DI_Delay can be 3 only if DO_Delay and CS_Delay are not both equal to 0.
            </comment>
        </bits>
        <bits name="CS_Delay" pos="13:12" access="rw" rst="3">
            <comment>Transfer end to chip select deactivation delay value from 0 to 3 is the number of spi clock half period between the end of transfer and CS deactivation
            </comment>
        </bits>
        <bits name="CS_Pulse" pos="15:14" access="rw" rst="3">
            <comment>Chip select deactivation to reactivation minimum delay value from 0 to 3 is the number of spi clock half period between the CS deactivation and a new CS activation (CS will activate only if more data are available in the transmit FIFO)
            </comment>
        </bits>
        <bits name="Frame_Size" pos="20:16" access="rw" rst="31">
            <comment>Frame Size
                <br/>The frame size is the binary value of this register + 1 valid value are 3 to 31 (frame size 4 to 32bits)
            </comment>
        </bits>
        <bits name="OE_delay" pos="28:24" access="rw" rst="31">
            <comment>OE delay
                <br/>When 0: regular mode, SPI_DO pin as output only.
                <br/>Value from 1 to 31 is the number of data out to transfert before the SPI_DO pin switch to input.
            </comment>
        </bits>
        <bits name="ctrl_data_mux_sel" pos="29" access="rw" rst="0">
            <comment>Selects the active CS and Input_reg either from the ctrl or rxtx_buffer register.
                <br/>If SPI FIFO 8b or 32b, when set to "0": CS from CS_sel and INPUT from Input_mode in the register ctrl.
                <br/>Only if SPI FIFO 32b, when set to "1": CS and INPUT from SPI DATA.(Do not work for FIFO8b)
            </comment>
            <options>
                <option name="Ctrl_reg_sel"  value="0"/>
                <option name="Data_reg_sel"  value="1"/>
                <default/><shift/><mask/>
            </options>            
        </bits>
        
        <bits name="Input_sel" pos="31:30" access="rw" rst="0">
            <comment>Selects the input line to be used as SPI data in.(Not used for SPI3)
                <br/>when "00" the SPI_DI_0 is used.
                <br/>When "01" the SPI_DI_1 is used.
                <br/>When "10" the SPI_DI_2 is used. 
                <br/>When "11" reserved.
            </comment>
        </bits>
        
    </reg>
        
    <reg name="status" protect="rw">

        <bits name="Active_Status" pos="0" access="r" rst="0">
            <comment>'1' when a transfer is in progress.
            </comment>
        </bits>
        <bits name="Cause_Rx_Ovf_Irq" pos="3" access="rw" rst="0">
            <comment>The receive FIFO overflow irq cause.
                <br/>Writing a '1' clear the receive overflow status and cause.
            </comment>
        </bits>
        <bits name="Cause_Tx_Th_Irq" pos="4" access="r" rst="0">
            <comment>The transmit FIFO threshold irq cause.
            </comment>
        </bits>
        <bits name="Cause_Tx_Dma_Irq" pos="5" access="rw" rst="0">
            <comment>The transmit Dma Done irq cause.
                <br/>Writing a '1' clear the transmit Dma Done status and cause.
            </comment>
        </bits>
        <bits name="Cause_Rx_Th_Irq" pos="6" access="r" rst="0">
            <comment>The receive FIFO threshold irq cause.
            </comment>
        </bits>
        <bits name="Cause_Rx_Dma_Irq" pos="7" access="rw" rst="0">
            <comment>The receive Dma Done irq cause.
                <br/>Writing a '1' clear the receive Dma Done status and cause.
            </comment>
        </bits>
        <bitgroup name="Irq_Cause">
            <entry ref="Cause_Rx_Ovf_Irq"/>
            <entry ref="Cause_Tx_Th_Irq"/>
            <entry ref="Cause_Tx_Dma_Irq"/>
            <entry ref="Cause_Rx_Th_Irq"/>
            <entry ref="Cause_Rx_Dma_Irq"/>
        </bitgroup>
        <bits name="Tx_Ovf" pos="9" access="rw" rst="0">
            <comment>The transmit FIFO overflow status.
                <br/>Writing a '1' clear the transmit overflow status and cause.
            </comment>
        </bits>
        <bits name="Rx_Udf" pos="10" access="rw" rst="0">
            <comment>The receive FIFO underflow status.
                <br/>Writing a '1' clear the receive underflow status and cause.
            </comment>
        </bits>
        <bits name="Rx_Ovf" pos="11" access="rw" rst="0">
            <comment>The receive FIFO overflow status.
                <br/>Writing a '1' clear the receive overflow status and cause.
            </comment>
        </bits> 
        <bits name="Tx_Th" pos="12" access="r" rst="0">
            <comment>The transmit FIFO threshold status.
            </comment>
        </bits> 
        <bits name="Tx_Dma_Done" pos="13" access="rw" rst="0">
            <comment>The transmit Dma Done status.
                <br/>Writing a '1' clear the transmit Dma Done status and cause.
            </comment>
        </bits> 
        <bits name="Rx_Th" pos="14" access="r" rst="0">
            <comment>The receive FIFO threshold status.
            </comment>
        </bits> 
        <bits name="Rx_Dma_Done" pos="15" access="rw" rst="0">
            <comment>The receive Dma Done status.
                <br/>Writing a '1' clear the receive Dma Done status and cause.
            </comment>
        </bits> 
        <bits name="Tx_Space" pos="20:16" access="r" rst="16" >
            <comment>Transmit FIFO Space
                <br/>Number of empty spot in the FIFO
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits> 
        <bits name="Rx_Level" pos="28:24" access="r" rst="0">
            <comment>Receive FIFO level
                <br/>Number of DATA in the FIFO
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits> 
        <bits name="FIFO_Flush" pos="30" access="w" rst="0">
            <comment>Writing '1' flush both FIFO, don't do it when SPI is active (transfer in progress)
            </comment>
        </bits>
    </reg>
    <reg name="rxtx_buffer" protect="--">
        <comment>Spi1 fifo size (rxtx_buffer): 8bits.<br/>
                 Spi2 fifo size (rxtx_buffer): 8bits.<br/>
                 Spi3 fifo size (rxtx_buffer): 32bits.<br/>

        </comment>
        <bits name="DATA_IN" pos="28:0" access="rw" rst="0">
            <comment>Write to the transmit FIFO
	    Read in the receive FIFO.
            </comment>
        </bits>
        <bits name="DATA_OUT" pos="28:0" access="rw" rst="0">
            <comment>Write to the transmit FIFO
	    Read in the receive FIFO.
            </comment>
        </bits>
        
        <bits name="CS" pos="30:29" access="rw" rst="0">
            <comment>
                Chip Select on which write the data written in the
                Fifo. 
		Data in bit [30:29]
		Data out bit [30:29]
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

        <bits name="READ_ENA" pos="31" access="rw" rst="0">
            <comment>
                Set this bit to one when the data received while sending
                this peculiar data are expected to be kept in the FIFO,
                otherwise no data is recorded in the FIFO.
		Data in bit [31]
		Data out bit [31]
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

    </reg>
    <reg name="cfg" protect="rw">
        <bits name="CS_Polarity" pos="2:0" access="rw" rst="all1" cut="1" cutprefix="CS_Polarity">
            <comment>Chip select polarity
            </comment>
            <options>
                <option name="active high" value="0"><comment>chip select is active high</comment></option>
                <option name="active low" value="1"><comment>chip select is active low</comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="Clock_Divider" pos="25:16" access="rw" rst="0x3ff">
            <comment>Clock Divider
                <br/>The state machine clock is generated by dividing the system clock by the value of this register + 1.
                <br/>So the output clock is divided by (register + 1)*2
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Clock_Limiter" pos="28" access="rw" rst="1">
            <comment>When enabled the clock input to the divider is not the system clock, but a limited version of it: It cannot be above 52MHz, so the output clock will never be above 26MHz.
                <br/> for system clock of 104Mhz the clock input to the divider is 52Mhz, for system clock of 78Mhz the clock input to the divider is 39Mhz, for lower system clock value, the input to the divider is the system clock.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

    </reg>

    <reg name="pattern" protect="rw">
        <bits name="pattern" pos="7:0" access="rw" rst="0">
            <comment>MMC Pattern value for RX pattern match mode.
            </comment>
        </bits>
        <bits name="pattern_mode" pos="8" access="rw" rst="0">
            <comment> Enable the pattern mode.
            </comment>
            <options>
                <option name="disabled" value="0"><comment>Spi Behaviour.</comment></option>
                <option name="enabled" value="1"><comment>Pattern matching.</comment></option>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="pattern_selector" pos="9" access="rw" rst="0">
            <comment> Select the RX pattern matching mode when the pattern_mode is enabled( set 1). Used for SD/MMC SPI mode.</comment>
            <options>
                <option name="UNTIL" value="0"><comment>No datas are written into the RX FIFO UNTIL the received data is equal to the pattern.</comment></option>
                <option name="WHILE" value="1"><comment>No datas are written into the RX FIFO WHILE the received data is equal to the pattern.</comment></option>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    
    <reg name="stream" protect="rw">
        <bits name="tx_stream_bit" pos="0" access="rw" rst="0">
            <comment>When TX stream mode is enabled, once the TX fifo is empty, all new bits send have the value of this bit.
            </comment>
            <options>
                <option name="zero" value="0"/>
                <option name="one" value="1"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="tx_stream_mode" pos="8" access="rw" rst="0">
            <comment>Enable the TX stream mode. Used for SD/MMC SPI mode.
                <br/>When enabled, this mode provide infinite bit stream for sending, after fifo is empty the extra bits generated all have the same value. The value is in tx_stream_bit.
            </comment>    
            <options>
                <option name="disabled" value="0"/>
                <option name="enabled" value="1"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="tx_stream_stop_with_rx_dma_done" pos="16" access="rw" rst="0">
            <comment>Allow to automatically clear the tx_stream_mode when Rx_Dma_Done is set.
            </comment>    
            <options>
                <option name="disabled" value="0"/>
                <option name="enabled" value="1"/>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    <reg name="pin_control" protect="rw">
        <bits name="clk_ctrl" pos="1:0" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_Clk pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_Clk pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_Clk pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_Clk pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="do_ctrl" pos="3:2" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_DO pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_DO pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_DO pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_DO pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>            
        </bits>
        <bits name="cs0_ctrl" pos="5:4" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_CSO pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_CSO pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_CSO pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_CSO pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>               
        </bits>        
        <bits name="cs1_ctrl" pos="7:6" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_CS1 pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_CS1 pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_CS1 pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_CS1 pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>   
        </bits>
        <bits name="cs2_ctrl" pos="9:8" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_CS2 pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_CS2 pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_CS2 pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_CS2 pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>   
        </bits> 
         
    </reg>
    <reg name="irq" protect="rw">
        <bits name="Mask_Rx_ovf_Irq" pos="0" access="rw" rst="0">
            <comment>Mask the receive FIFO overflow irq
            </comment>
        </bits>
        <bits name="Mask_Tx_Th_Irq" pos="1" access="rw" rst="0">
            <comment>Mask the transmit FIFO threshold irq
            </comment>
        </bits>
        <bits name="Mask_Tx_Dma_Irq" pos="2" access="rw" rst="0">
            <comment>Mask the transmit Dma Done irq
            </comment>
        </bits>
        <bits name="Mask_Rx_Th_Irq" pos="3" access="rw" rst="0">
            <comment>Mask the receive FIFO threshold irq
            </comment>
        </bits>
        <bits name="Mask_Rx_Dma_Irq" pos="4" access="rw" rst="0">
            <comment>Mask the receive DMA Done irq
            </comment>
        </bits>
        <bitgroup name="Irq_Mask">
            <entry ref="Mask_Rx_ovf_Irq"/>
            <entry ref="Mask_Tx_Th_Irq"/>
            <entry ref="Mask_Tx_Dma_Irq"/>
            <entry ref="Mask_Rx_Th_Irq"/>
            <entry ref="Mask_Rx_Dma_Irq"/>
        </bitgroup>
        <bits name="Tx_Threshold" pos="6:5" access="rw" rst="3">
            <comment>Transmit FIFO threshold this threshold is used to generate the irq.
            </comment>
            <options>
                <option name="1 Empty Slot" value="0"/>
                <option name="4 Empty Slots" value="1"/>
                <option name="8 Empty Slots" value="2"/>
                <option name="12 Empty Slots" value="3"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="Rx_Threshold" pos="8:7" access="rw" rst="3">
            <comment>Receive FIFO threshold this threshold is used to generate the irq.
            </comment>
            <options>
                <option name="1 Valid Data" value="0"/>
                <option name="4 Valid Data" value="1"/>
                <option name="8 Valid Data" value="2"/>
                <option name="12 Valid Data" value="3"/>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>

</module>
</archive>
<archive relative = "spi_flash.xml">
<module name="spi_flash" category="System">

    <reg name="spi_cmd_addr" protect="rw">
		<bits access="rw" name="spi_tx_cmd" pos="7:0" rst="all0">           
			<comment> spi flash command to send. 
			</comment>
		</bits>
		<bits access="rw" name="spi_address" pos="31:8" rst="all0">           
			<comment> spi flash address to send. 
			</comment>
		</bits>
     </reg>
	 <reg name="spi_block_size" protect="rw">
		<bits access="rw" name="spi_modebit" pos="7:0" rst="all0">           
			<comment> spi flash modebit,set 0xA0 to enable continuous read. 
			</comment>
		</bits>
		<bits access="rw" name="spi_rw_blk_size" pos="16:8" rst="0x1">           
			<comment> spi flash spi read/write block size. 
			</comment>
        </bits>
		<bits access="rw" name="continuous enable" pos="24" rst="0x0">           
        </bits>
     </reg>
     <reg name="spi_data_fifo_wo" protect="w">
		<bits access="w" name="spi_tx_data" pos="7:0" rst="all0">           
			<comment> spi flash data to send. 
			</comment>
		</bits>
		<bits access="w" name="spi_send_type" pos="8" rst="0x0">           
			<comment> spi send byte, 1: quad send 0: spi send. 
			</comment>
		</bits>
     </reg>

     <reg name="spi_data_fifo_ro" protect="r">
		<bits access="r" name="spi_flash_busy" pos="0" rst="0x0">           
			<comment> spi flash busy. 
			</comment>
		</bits>
		<bits access="r" name="tx_fifo_empty" pos="1" rst="0x1">           
			<comment> tx fifo empty. 
			</comment>
		</bits>
		<bits access="r" name="tx_fifo_full" pos="2" rst="0x0">           
			<comment> tx fifo full. 
			</comment>
		</bits>
		<bits access="r" name="rx_fifo_empty" pos="3" rst="0x1">           
			<comment> rx fifo empty. 
			</comment>
		</bits>
		<bits access="r" name="rx_fifo_count" pos="8:4" rst="all0">           
			<comment> rx fifo data count. 
			</comment>
		</bits>
		<bits access="r" name="read_state_busy" pos="9" rst="0">           
		</bits>
		<bits access="r" name="main_fsm_idle" pos="10" rst="0">           
		</bits>
     </reg>

     <reg name="spi_read_back" protect="r">
		<bits access="r" name="spi_read_back_reg" pos="31:0" rst="all0">           
			<comment> spi flash read back data. 
			</comment>
		</bits>
     </reg>

     <reg name="spi_config" protect="rw">
		<bits access="rw" name="quad_mode" pos="0" rst="0x0">           
			<comment> spi flash read mode from AHB. 
			</comment>
			<options>
            <option name="spi read"  value ="0"></option>
            <option name="quad read" value ="1"></option>
        	</options>
		</bits>
		<bits access="rw" name="spi_wprotect_pin" pos="1" rst="0x0">           
			<comment> spi flash wprotect pin. 
			</comment>
		</bits>
		<bits access="rw" name="spi_hold_pin" pos="2" rst="0x0">           
			<comment> spi flash hold pin. 
			</comment>
		</bits>
		<bits access="rw" name="sample_delay" pos="6:4" rst="0x2">           
			<comment> spi flash read sample delay cycles. 
			</comment>
		</bits>
		<bits access="rw" name="bypass_start_cmd" pos="7" rst="0x1">           
		</bits>
		<bits access="rw" name="clk_divider" pos="15:8" rst="0x8">           
			<comment> spi flash clock divider. 
			</comment>
		</bits>
		<bits access="rw" name="cmd_quad" pos="16" rst="0x0">           
			<comment> spi flash send command using quad lines. 
			</comment>
        </bits>
		<bits access="rw" name="tx_rx_size" pos="18:17" rst="0x0">           
        </bits>
     </reg>

     <reg name="spi_fifo_control" protect="w">
		<bits access="w" name="rx_fifo_clr" pos="0" rst="0x0">           
			<comment> rx fifo_clr,self clear. 
			</comment>
		</bits>
		<bits access="w" name="tx_fifo_clr" pos="1" rst="0x0">           
			<comment> tx fifo_clr,self clear. 
			</comment>
		</bits>
     </reg>

     <reg name="spi_cs_size" protect="rw">
		<bits access="rw" name="spi_cs_num" pos="0" rst="0x0">           
			<comment> spi flash cs num. 
			</comment>
			<options>
            <option name="1 spiflash"  value ="0"></option>
            <option name="2 spiflash"  value ="1"></option>
        	</options>
		</bits>
		<bits access="rw" name="spi size" pos="2:1" rst="all0">           
			<comment> single chip spi flash size. 
			</comment>
			<options>
            <option name="32m"  value ="0"></option>
            <option name="64m"  value ="1"></option>
            <option name="16m"  value ="2"></option>
            <option name="8m"   value ="3"></option>
        	</options>
		</bits>
		<bits access="w" name="spi_128m" pos="3" rst="0x0">           
			<comment> spi flash is 128m flash. 
			</comment>
			<options>
            <option name="other spiflash"  value ="0"></option>
            <option name="128m  spiflash"  value ="1"></option>
        	</options>
		</bits>
		<bits access="rw" name="ahb_read_disable" pos="4" rst="0x0">           
			<comment> disable read from ahb. 
			</comment>
			<options>
            <option name="enable ahb read"  value ="0"></option>
            <option name="disable ahb read" value ="1"></option>
        	</options>
		</bits>
		<bits access="w" name="SPI_1_SEL" pos="5" rst="0x0">           
		<options>
            <option name="flash 0"  value ="0"></option>
            <option name="flash 1" value ="1"></option>
        	</options>
		</bits>
		<bits access="w" name="spi_cs1_sel1" pos="6" rst="0x0">           
		</bits>
		<bits access="rw" name="diff_128m_diff_cmd_en" pos="7" rst="0x0">           
		</bits>
    </reg>

    <reg name="spi_read_cmd" protect="rw">
		<bits access="rw" name="qread_cmd" pos="7:0" rst="8'heb">           
			<comment> quad read command. 
			</comment>
		</bits>
		<bits access="rw" name="fread_cmd" pos="15:8" rst="8'h0b">           
			<comment> fast read command. 
			</comment>
		</bits>
		<bits access="rw" name="read_cmd" pos="23:16" rst="8'h03">           
			<comment> read command. 
			</comment>
		</bits>
		<bits access="w" name="protect_byte" pos="31:24" rst="all0">           
			<comment> protect_byte, must be 0x55 when program this register. 
			</comment>
		</bits>
    </reg>
    
    <reg name="spi_flash_24" protect="rw">
		<bits access="rw" name="nand_sel" pos="0" rst="all0">           
		</bits>
		<bits access="rw" name="nand_addr" pos="2:1" rst="all0">           
		</bits>
		<bits access="rw" name="page_read_cmd" pos="15:8" rst="8'h13">           
        </bits>
		<bits access="rw" name="get_sts_cmd" pos="23:16" rst="8'h0f">           
        </bits>
		<bits access="rw" name="ram_read_cmd" pos="31:24" rst="8'h03">           
        </bits>
    </reg>

    <reg name="spi_flash_28" protect="rw">
		<bits access="rw" name="get_sts_addr" pos="7:0" rst="8'hc0">           
		</bits>
		<bits access="rw" name="program_exe_cmd" pos="15:8" rst="8'h10">           
        </bits>
		<bits access="rw" name="sts_qip" pos="23:16" rst="8'h01">           
        </bits>
    </reg>

    <reg name="spi_flash_2c" protect="rw">
		<bits access="rw" name="four_byte_addr" pos="0" rst="all0">           
		</bits>
		<bits access="rw" name="dummy_cycle_en" pos="1" rst="all0">           
		</bits>
		<bits access="rw" name="dummy_cycle" pos="11:8" rst="8'h08">           
        </bits>
    </reg>

    <reg name="spi_flash_30" protect="rw">
		<bits access="rw" name="first_128m_cmd" pos="7:0" rst="0x8c">           
		</bits>
		<bits access="rw" name="second_128m_cmd" pos="15:8" rst="0x8d">           
        </bits>
		<bits access="rw" name="third_128m_cmd" pos="23:16" rst="8'h0">           
        </bits>
		<bits access="rw" name="fourth_128m_cmd" pos="31:24" rst="8'h0">           
        </bits>
    </reg>
     
    <reg name="spi_flash_34" protect="rw">
		<bits access="rw" name="timeout_value" pos="31:0" rst="32'h4000">           
		</bits>
    </reg>
     
</module>


</archive>
<archive relative = "sys_ctrl.xml">

<include file="globals.xml"/>

<module name="sys_ctrl" category="System">
    
    <enum name="Cpu_Id">
        <entry name="XCPU"><comment>CPU IDs</comment></entry>
        <entry name="BCPU"/>
    </enum>

    
    <enum name="Sys_Clks">
    
        <entry name="SYS_XCPU"><comment>System side System clocks</comment></entry>
        <entry name="SYS_XCPU_int"/>
        <bound name="NB_SYS_CLK_XCPU"/>
        <entry name="SYS_PCLK_CONF"/>
        <entry name="SYS_PCLK_DATA"/>
        <entry name="SYS_AMBA"/>
        <entry name="SYS_DMA"/>
        <entry name="SYS_GOUDA"/>
        <entry name="SYS_EBC"/>
        <entry name="SYS_IFC_CH0"/>
        <entry name="SYS_IFC_CH1"/>
        <entry name="SYS_IFC_CH2"/>
        <entry name="SYS_IFC_CH3"/>
        <entry name="SYS_IFC_CH4"/>
        <entry name="SYS_IFC_CH5"/>
        <entry name="SYS_IFC_CH6"/>
        <entry name="SYS_IFC_CH7"/>
        <entry name="SYS_IFC_DBG"/>
        <entry name="SYS_A2A"/>
        <entry name="SYS_INTSRAM"/>
        <entry name="SYS_DEBUG_UART"/>
        <entry name="SYS_DBGHST"/>
        <entry name="SYS_VOC_AHB"/>   
        <entry name="SYS_MAILBOX"/>   
        <entry name="SYS_IFC2_CH0"/>   
        <entry name="SYS_IFC2_CH1"/>   
        <entry name="SYS_AIF"/>   
    
        <entry name="SYSD_SCI"><comment>System side divided clock (either divided by module or by sys_ctrl)</comment></entry>
        <entry name="SYSD_RF_SPI"/>
        <entry name="SYSD_OSC"/>
        <entry name="SYSD_PWM"/>
        <entry name="SYSD_DAIS_208K"><comment>divided BCK clock for DAI</comment></entry>
        <bound name="NB_SYS_CLK_AEN"/>
        <bound name="SYSCLK_PAGE_1"/>
    
        <entry name="SYS_GPIO"><comment>the following don't have an auto enable</comment></entry>
        <entry name="SYS_IRQ"/>
        <entry name="SYS_TCU"/>
        <entry name="SYS_TIMER"/>
        <bound name="NB_SYS_CLK_EN"/>
    
        <entry name="SYS_SCI"><comment>the following are sharing their enable</comment></entry>
        <entry name="SYS_NOGATE"><comment>keep last</comment></entry>
        <bound name="NB_SYS_CLK"/>
    </enum>
    
    <enum name="Per_Clks">
    
        <entry name="PER_UART"><comment>System side System clocks for Peripherals</comment></entry>
        <entry name="PER_UART2"/>
        <entry name="PER_I2C"/>
        <entry name="PER_I2C2"/>
        <entry name="PER_I2C3"/>
        <entry name="PER_SDMMC"/>
        <entry name="PER_SDMMC2"/>
        <entry name="PER_CAMERA"/>
    
        <entry name="PERD_SPI1"><comment>System side divided clock (either divided by module or by sys_ctrl)</comment></entry>
        <entry name="PERD_SPI2"/>
        <entry name="PERD_SPI3"/>
        <bound name="NB_PER_CLK_AEN"/>
    
        <entry name="PER_USBC"/>
        <entry name="PER_SPY"/>
        <entry name="PER_TEST"/>
        <bound name="NB_PER_CLK_EN"/>
    
        <bound name="NB_PER_CLK"/>
    </enum>    
    
    <enum name="BB_Clks">
    
        <entry name="BB_BCPU"><comment>Baseband side System clocks</comment></entry>
        <entry name="BB_BCPU_INT"/>
        <entry name="BB_AMBA"/>
        <entry name="BB_PCLK_CONF"/>
        <entry name="BB_PCLK_DATA"/>
        <entry name="BB_ROM_AHB"/>
        <entry name="BB_MAILBOX"/>
        <entry name="BB_EXCOR"/>
        <entry name="BB_IFC_CH2"/>
        <entry name="BB_IFC_CH3"/>
        <entry name="BB_SRAM"/>
        <entry name="BB_A2A"/>
        <entry name="BB_ITLV"/>
        <entry name="BB_VITERBI"/>
        <entry name="BB_CIPHER"/>
        <entry name="BB_RF_IF"/>
        <entry name="BB_COPRO"/>
        <entry name="BB_CP2_REG"/>
        <entry name="BB_XCOR"/>
        <entry name="BB_EVITAC"/>
        <entry name="BB_CORDIC"/>
        <entry name="BB_COM_REGS"/>
        <entry name="BB2_SDMMC"/>
        <entry name="BB_CHOLK"/>
    
        <bound name="NB_BB_CLK_AEN"/>
    
        <entry name="BB_IRQ"><comment>the following don't have an auto enable</comment></entry>
        <entry name="BB_A53"/>
        <entry name="BB_TIMER"/>
        <entry name="BBD_OSC"/>
        <bound name="NB_BB_CLK_EN"/>
        <bound name="NB_BB_CLK"/>
    </enum>
    
    <enum name="Other_Clks">
        
        
        
        <bound name="OC_HOST_UART"><comment>Other clocks<br/>clocks with auto enble<br/>the debug host clock auto enable is not used in host mode, only in uart mode</comment></bound>
        <entry name="OC_DEBUG_UART"/>
        <entry name="OC_BCK"/>
        <entry name="OC_UART"/>
        <entry name="OC_UART2"/>
        <entry name="OC_RF_RX"/>
        <entry name="OC_RF_TX"/>
        <entry name="OC_MEM_BRIDGE"/>
        <entry name="OC_VOC_CORE"/>
        <entry name="OC_VOC_AHB"/>
        <entry name="OC_VOC_DAI"/>
        <bound name="NB_OTHER_CLK_AEN"/>
        
        <entry name="OC_VOC"/>
        <entry name="OC_LPS"/>
        <entry name="OC_GPIO"/>
        <entry name="OC_USBPHY"/>
        <entry name="OC_PIX"/>
        <entry name="OC_Reserve"/>
        <entry name="OC_MEM_CLK_OUT"/>
        <entry name="OC_DBG"/>
        <entry name="OC_TCU"/>  
        <entry name="OC_SYS_SPIFLASH"/>                
        <entry name="OC_SPIFLASH"/>                
        <bound name="NB_OTHER_CLK_EN"/>
        
        <bound name="NB_OTHER_CLK"/>
    </enum>
    
    
    <enum name="Resets">
        
        <entry name="RST_XCPU"><comment>System side resets</comment></entry>
        <entry name="RST_SYS_IRQ"/>
        <entry name="RST_SYS_A2A"/>
        <entry name="RST_ABB"/>
        <entry name="RST_DMA"/>
        <entry name="RST_GOUDA"/>
        <entry name="RST_TIMER"/>
        <entry name="RST_TCU"/>
        <entry name="RST_GPIO"/>
        <entry name="RST_KEYPAD"/>
        <entry name="RST_PWM"/>
        <entry name="RST_UART"/>
        <entry name="RST_UART2"/>
        <entry name="RST_SPI1"/>
        <entry name="RST_SPI2"/>
        <entry name="RST_SPI3"/>
        <entry name="RST_RF_SPI"/>
        <entry name="RST_SCI"/>
        <entry name="RST_SPY"/>
        <entry name="RST_I2C"/>
        <entry name="RST_I2C2"/>
        <entry name="RST_I2C3"/>
        <entry name="RST_MEM_BRIDGE"/>
        <entry name="RST_SPIFLASH"/>
        <entry name="RST_EXT_APB"/>
        <entry name="RST_SDMMC"/>
        <entry name="RST_CAMERA"/>
        <entry name="RST_USBC"/>
        <entry name="RST_USBPHY"/>
        <entry name="RST_DBG"/>
        <bound name="RST_PAGE_1"><comment>Next Register</comment></bound>
        <entry name="RST_VOC"/>
        <entry name="RST_AIF"/>
        <entry name="RST_IFC2"/>
        <entry name="RST_MAILBOX"/>
        <entry name="RST_SDMMC2"/>
        <entry name="RST_DAI"/>
        <bound name="NB_SRST"/>
        
        <bound name="BOUND_BRST_FIRST"><comment>Baseband side resets</comment></bound>
        <entry name="RST_BCPU"/>
        <entry name="RST_BB_IRQ"/>
        <entry name="RST_BB_A2A"/>
        <entry name="RST_BB_IFC"/>
        <entry name="RST_BB_SRAM"/>
        <entry name="RST_ITLV"/>
        <entry name="RST_VITERBI"/>
        <entry name="RST_CIPHER"/>
        <entry name="RST_XCOR"/>
        <entry name="RST_COPRO"/>
        <entry name="RST_RF_IF"/>
        <entry name="RST_ROM_BB"/>
        <entry name="RST_MAILBOX_BB"/>
        <entry name="RST_EXCOR"/>
        <entry name="RST_EVITAC"/>
        <entry name="RST_CORDIC"/>
        <entry name="RST_TCU_BB"/>
        <entry name="RST_BB2_SDMMC"/>
        <entry name="RST_CHOLK"/>
        <entry name="RST_A53"/>
        <entry name="RST_BB_TIMER"/>
        <bound name="BOUND_BRST_AFTER"/>
        <entry name="RST_BB_FULL"/>
        <bound name="NR_RST_REG"><comment>The following reset does not have register</comment></bound>
        <entry name="RST_SYS_FULL"/> 
        <bound name="NB_RST"/>
    </enum>
    <var name="NB_BRST" value="BOUND_BRST_AFTER-BOUND_BRST_FIRST"/>

    
    <enum name="Reset_Others">
        <entry name="RSTO_DBG_HOST"><comment>Reset Other : resync on corresponding clock other</comment></entry>
        <entry name="RSTO_GPADC"/>
        <entry name="RSTO_BCK"/>
        <entry name="RSTO_UART"/>
        <entry name="RSTO_UART2"/>
        <bound name="BOUND_RSTO_RF_FIRST"/>
        <entry name="RSTO_RF_RX"/>
        <entry name="RSTO_RF_TX"/>
        <bound name="BOUND_RSTO_RF_AFTER"/>
        <entry name="RSTO_MEM_BRIDGE"/>
        <entry name="RSTO_DBG"/>
        <entry name="RSTO_VOC_DAI"/>
        <entry name="RSTO_VOC"/>
        <entry name="RSTO_LPS"/>
        <entry name="RSTO_GPIO"/>
        <entry name="RSTO_WDTIMER"/>
        <entry name="RSTO_USBPHY"/>
        <entry name="RSTO_TCU"/>
        <entry name="RSTO_BBTIMER"/>
        <entry name="RSTO_NANDMC"/>
        <bound name="NB_RSTO"/>
    </enum>

    <range name="p_Reset_BB_L" left="BOUND_BRST_AFTER-1" right="BOUND_BRST_FIRST" ><comment>Range for Reset register generation</comment></range>

    <range name="range_Reset_Sys_Reg_L" left="NR_RST_REG-1" right="0" />
    <range name="range_Reset_Sys_L" left="NB_RST-1" right="0" />
    <range name="range_Reset_Other_L" left="NB_RSTO-1" right="0" />

    <range name="range_Clock_SysXcpu_H" left="NB_SYS_CLK_XCPU-1" right="0" ><comment>Range for XCPU clock_ctrl generation</comment></range>
    <range name="range_Clock_Sys_H" left="NB_SYS_CLK-1" right="0" ><comment>Range for clock_ctrl generation</comment></range>
    <range name="range_Mode_Clock_Sys_H" left="NB_SYS_CLK_AEN-1" right="1" />
    <range name="range_Enable_Clock_Sys_H" left="NB_SYS_CLK_EN-1" right="0" />
    
    <range name="range_Clock_Per_H" left="NB_PER_CLK-1" right="0" />
    <range name="range_Mode_Clock_Per_H" left="NB_PER_CLK_AEN-1" right="0" />
    <range name="range_Enable_Clock_Per_H" left="NB_PER_CLK_EN-1" right="0" />
    
    <range name="range_Clock_BB_H" left="NB_BB_CLK-1" right="0" />
    <range name="range_Mode_Clock_BB_H" left="NB_BB_CLK_AEN-1" right="1" />
    <range name="range_Enable_Clock_BB_H" left="NB_BB_CLK_EN-1" right="0" />

    <range name="range_Clock_Other_H" left="NB_OTHER_CLK-1" right="0" />
    <range name="range_Mode_Clock_Other_H" left="NB_OTHER_CLK_AEN-1" right="0" />
    <range name="range_Enable_Clock_Other_H" left="NB_OTHER_CLK_EN-1" right="0" />






    <range name="range_Cfg_Clk_Host" left="6" right="0" ><comment>Range for clock_ctrl generation, as there is no config register for this clock in sys_ctrl</comment></range>


    <var name="SYS_CTRL_PROTECT_LOCK" value="0xa50000" ><comment>For REG_DBG protect lock/unlock value</comment></var>
    <var name="SYS_CTRL_PROTECT_UNLOCK" value="0xa50001" />




    <reg name="REG_DBG" protect="rw">
        <comment><strong>This register is used to Lock and Unlock the protected registers.</strong>
        </comment>
        <bits name="Scratch"    pos="15:0"  access="rw"  rst="no">
            <comment>Scratch register: used for debug
            </comment>
        </bits>
        <bits name="Write Unlock Status"    pos="30"  access="r"  rst="0">
            <comment>Is set to 1 when a write attempt has been done on a protected register
                <br/>Can be reset by writing 0xa50000 or 0xa50001 to the debug register (With the LSB at 1 to unlock the protected registers, with the LSB at 0 to lock them)
            </comment>
        </bits>
        <bits name="Write Unlock"           pos="31"  access="r"  rst="1">
            <comment>When this bit is set to 1, the protected registers are accessible
                <br/>When this bit is set to 0, the protected registers can not be written
                <br/>Write 0xa50000 to the debug register to set this bit to 0
                <br/>Write 0xa50001 to the debug register to set this bit to 1
            </comment>
        </bits>
    </reg>

    <reg name="Sys_Rst_Set" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Set_Sys_Rst"    pos="RST_PAGE_1-1:0"  access="rs" rst="1" cut="1" cutprefix="Set" cutenum="Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name="Set_Rst_Out"    pos="30"    access="rs" rst="0">
            <comment>Writing a 1 to this bit will output a 0 on the RST_OUT pin
                <br/>Reading this bit will return the RST_OUT line state.
            </comment>
        </bits>
        <bits name="Soft_Rst"   pos="31"    access="s" rst="0">
            <comment>Writing a 1 to this bit will reset the entire chip.
            </comment>
        </bits>
    </reg>
    <reg name="Sys_Rst_Clr" protect="rw">
        <bits name="Clr_Sys_Rst"    pos="RST_PAGE_1-1:0"  access="rc" rst="1" cut="1" cutprefix="Clr" cutenum="Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name="Clr_Rst_Out"    pos="30"    access="rc" rst="0">
            <comment>Writing a 1 to this bit will output a 1 on the RST_OUT pin
                <br/>Reading this bit will return the RST_OUT line state.
            </comment>
        </bits>
    </reg>
    <reg name="BB_Rst_Set" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Set_Sys_Msb_Rst"    pos="NB_SRST-1-RST_VOC:RST_PAGE_1 - RST_VOC"  access="rs" rst="1" cut="1" cutprefix="Set" cutenum="Resets" cutstart="RST_VOC">
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name="Set_BB_Rst"    pos="BOUND_BRST_AFTER-1-RST_VOC:RST_BCPU-RST_VOC"  access="rs" rst="1" cut="1" cutprefix="Set" cutenum="Resets" cutstart="RST_BCPU">
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name="Set_RST_BB_FULL" pos="31"    access="rs" rst="1">
            <comment>Writing a 1 to this reset bit will reset the all  modules on the baseband  and leave them in reset state. (this resets more modules than all lower bits of this register)
                <br/>Reading this register returns the reset state of the full baseband side.
                <br/>0 : in reset
                <br/>1 : out of reset

            </comment>
        </bits>
    </reg>
    <reg name="BB_Rst_Clr" protect="rw">
        <bits name="Clr_Sys_Msb_Rst"    pos="NB_SRST-1- RST_VOC:RST_PAGE_1- RST_VOC"  access="rc" rst="1" cut="1" cutprefix="Clr" cutenum="Resets" cutstart="RST_VOC">
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name="Clr_BB_Rst"    pos="BOUND_BRST_AFTER-1- RST_VOC:RST_BCPU- RST_VOC"  access="rc" rst="1" cut="1" cutprefix="Clr" cutenum="Resets" cutstart="RST_BCPU">
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name="Clr_RST_BB_FULL" pos="31"    access="rc" rst="1">
            <comment>Writing a 1 to this reset bit will take all the modules on the baseband   out of reset state. (modules can be kept in reset if the corresponding bit in lower bits of this register is still forcing it's reset)
                <br/>Reading this register returns the reset state of the full baseband side.
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="Clk_Sys_Mode" protect="rw">
        <bits name="Mode_SYS_XCPU"   pos="0" access="r"  rst="1">
            <comment> fixed to '1'. This clock is gated only by manual mode or xcpu_sleep from irq module.
            </comment>   
        </bits>
        <bits name="Mode_Clk_Sys"   pos="NB_SYS_CLK_AEN-1:1"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="Sys_Clks" cutstart="1">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_Sys_Enable" protect="rw">
        <bits name="Enable_Clk_Sys"     pos="NB_SYS_CLK_AEN-1:0"  access="w1s" rst="1" cut="1" cutprefix="Enable" cutenum="Sys_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_Sys_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_Sys"    pos="NB_SYS_CLK_AEN-1:0"  access="w1c" rst="1" cut="1" cutprefix="Disable" cutenum="Sys_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_Per_Mode" protect="rw">
        <bits name="Mode_Clk_Per"   pos="NB_PER_CLK_AEN-1:0"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="Per_Clks" cutstart="0">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_Per_Enable" protect="rw">
        <bits name="Enable_Clk_Per"     pos="NB_PER_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="Per_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_Per_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_Per"    pos="NB_PER_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="Per_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_BB_Mode" protect="rw">
       <bits name="Mode_BB_BCPU"   pos="0" access="r"  rst="1">
            <comment> fixed to '1'. This clock is gated only by manual mode or bcpu_sleep from irq module.  
            </comment>   
        </bits>
        <bits name="Mode_Clk_BB"   pos="NB_BB_CLK_AEN-1:1"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="BB_Clks" cutstart="1">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_BB_Enable" protect="rw">
        <bits name="Enable_Clk_BB"     pos="NB_BB_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="BB_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_BB_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_BB"    pos="NB_BB_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="BB_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_Other_Mode" protect="rw">
        <bits name="Mode_Clk_Other"   pos="NB_OTHER_CLK_AEN-1:0"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="Other_Clks" cutstart="0">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_Other_Enable" protect="rw">
        <bits name="Enable_Clk_Other"     pos="NB_OTHER_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="Other_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_Other_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_Other"    pos="NB_OTHER_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="Other_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Pll_Ctrl" protect="rw">
        <comment>Register protected by Write_Unlocked_H.</comment>
        <bits name="Pll_Enable" pos="0" access="rw" rst="0">
            <comment>Mode of the Pll. This register is set to enable by the LPS_start_ExtPll_pulse_H.</comment>
            <options>
                <option name="Power_Down" value="0"></option>
                <option name="Enable" value="1"></option>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="Pll_Lock_Reset" pos="4" access="rw" rst="1">
            <comment>Used to reset the PLL Lock Detector.</comment>
            <options>
                <option name="Reset"    value="0"></option>
                <option name="No_Reset" value="1"></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="Pll_Clk_Fast_Enable" pos="12" access="rw" rst="0">
            <comment>pll clock fast enable</comment>
            <options>
                <option name="Disable"    value="0"></option>
                <option name="Enable" value="1"></option>
                <mask/><shift/>
            </options>
        </bits>
            
    </reg>    
    <reg name="Sel_Clock" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Slow_sel_RF"    pos="0"  access="rw" rst="1">
            <comment>PreSelects between RF clock and Oscillator clock for Clock Slow
            </comment>
            <options>
                <option name="Oscillator"   value="1"></option>
                <option name="RF"           value="0"></option>
            </options>
        </bits>
        <bits name="Sys_sel_Fast"    pos="1"  access="rw" rst="1">
            <comment>Selects between the Slow clock and the Fast Clock (Pll clock) and Selects between the Slow clock and the Xcpu Clock
            </comment>
            <options>
                <option name="Slow"         value="1"></option>
                <option name="Fast"         value="0"></option>
            </options>
          </bits>
          <bits name="TCU_13M_SEL"    pos="2"  access="rw" rst="1">
              <comment>Select Clk_TCU freq between 13M and 26M
              </comment>
              <options>
                  <option name="13M" value="0"></option>
                  <option name="26M" value="1"></option>
              </options>
          </bits>

        <bits name="Pll_disable_lps"    pos="3"  access="rw" rst="0">
            <comment>Disable PLL when LPS power up.
            </comment>
            <options>
                <option name="Disable"      value="1"></option>
                <option name="Enable"       value="0"></option>
            </options>
        </bits>
        <bits name="RF_detected" pos="4" access="r" rst="no">
            <options>
                <option name="Ok" value="1"><comment>When 1, the clock from the XCver is detected.</comment></option>
                <option name="No" value="0"><comment>When 0, the clock from the XCver is not detected.</comment></option>
            </options>
        </bits>
        <bits name="RF_Detect_Bypass" pos="5" access="rw" rst="0">
            <comment>If RF_Detect_Bypass = 0, RF clock is selected when she is detected.
                <br/>If RF_Detect_Bypass = 1, RF clock is selected even she is not detected.
            </comment> 
        </bits>

        <bits name="RF_Detect_Reset" pos="6" access="rw" rst="0">
            <comment>When 1, The RF clock detection counter is force reseted.
                <br/>When 0, The RF clock detection counter is enabled.
            </comment>               
        </bits>
        <bits name="RF_selected_L"    pos="7"    access="r" rst="1">
            <comment>0 when RF clock is effectively selected for Slow Clock. RF clock selection is not done until the clock has been detected.
            </comment>
        </bits>
        <bits name="PLL_Locked" pos="8" access="r" rst="0">
            <options>
                <option name="Locked"     value="1"><comment></comment></option>
                <option name="Not_Locked" value="0"><comment></comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>  
        <bits name="Fast_Selected_L"    pos="9"    access="r" rst="1">
            <comment>0 when Fast clock is effectively selected. Fast clock selection is not done until the PLL has locked.
            </comment>
            <options>
            <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="spiflash_sel_fast" pos="10" access="rw" rst="1">
            <comment>When 1, clk_spiflash is clk_slow.
                <br/>When 0, switch from clk_slow to clk_spiflash
            </comment>               
            <options>
                <option name="Slow" value="1"></option>
                <option name="Fast" value="0"></option>
            </options>
        </bits>
        <bits name="mem_bridge_sel_fast" pos="11" access="rw" rst="1">
            <comment>When 1, clk_mem_bridge is clk_slow.
                <br/>When 0, switch from clk_slow to clk_pll_mem_bridge
            </comment>               
            <options>
                <option name="Slow" value="1"></option>
                <option name="Fast" value="0"></option>
            </options>
        </bits>
        <bits name="bb_sel_fast" pos="12" access="rw" rst="1">
            <comment>When 1, clk_bb is clk_slow.
                <br/>When 0, switch to pll fast clk.
            </comment>               
            <options>
                <option name="Slow" value="1"></option>
                <option name="Fast" value="0"></option>
            </options>
        </bits>
        <bits name="PLL_Bypass_Lock" pos="13" access="rw" rst="0">
            <comment>When 1, pll_locked is high always.
                <br/>When 0, pll_locked is pll_locked_int.
            </comment>               
        </bits>
        <bits name="voc_sel_fast" pos="14" access="rw" rst="1">
            <comment>When 1, clk_voc is clk_slow.
                <br/>When 0, switch to pll fast clk.
            </comment>               
            <options>
                <option name="Slow" value="1"></option>
                <option name="Fast" value="0"></option>
            </options>
        </bits>
    </reg>

    <reg name="Cfg_Clk_Sys" protect="rw">
       <bits name="Sys_Freq"   pos="3:0"  access="rw" rst="b0010">
           <options>
               <option name="312M" value="13"/>
               <option name="250M" value="12"/>
               <option name="208M" value="11"/>
               <option name="178M" value="10"/>
               <option name="156M" value="9"/>
               <option name="139M" value="8"/>
               <option name="125M" value="7"/>
               <option name="113M" value="6"/>
               <option name="104M" value="5"/>
               <option name="89M" value="4"/>
               <option name="78M" value="3"/>
               <option name="52M" value="2"/>
               <option name="39M" value="1"/>
               <option name="26M" value="0"/>
               <default/>
               <mask/>
               <shift/>
            </options>
            <comment>Note: for unvalid values the memory interface will run at 26MHz
            </comment>
       </bits>
    </reg>
    
    <reg name="Cfg_Clk_Mem_Bridge" protect="rw">
       <bits name="Mem_Freq"   pos="3:0"  access="rw" rst="b0010">
           <options>
               <option name="312M" value="13"/>
               <option name="250M" value="12"/>
               <option name="208M" value="11"/>
               <option name="178M" value="10"/>
               <option name="156M" value="9"/>
               <option name="139M" value="8"/>
               <option name="125M" value="7"/>
               <option name="113M" value="6"/>
               <option name="104M" value="5"/>
               <option name="89M" value="4"/>
               <option name="78M" value="3"/>
               <option name="52M" value="2"/>
               <option name="39M" value="1"/>
               <option name="26M" value="0"/>
               <default/>
               <mask/>
               <shift/>
            </options>
            <comment>Note: for unvalid values the memory interface will run at 26MHz
            </comment>
       </bits>
    </reg>

    <reg name="Cfg_Clk_Voc" protect="rw">
       <bits name="Voc_Freq"   pos="3:0"  access="rw" rst="b0000">
           <options>
               <option name="312M" value="13"/>
               <option name="250M" value="12"/>
               <option name="208M" value="11"/>
               <option name="178M" value="10"/>
               <option name="156M" value="9"/>
               <option name="139M" value="8"/>
               <option name="125M" value="7"/>
               <option name="113M" value="6"/>
               <option name="104M" value="5"/>
               <option name="89M" value="4"/>
               <option name="78M" value="3"/>
               <option name="52M" value="2"/>
               <option name="39M" value="1"/>
               <option name="26M" value="0"/>
               <default/>
               <mask/>
               <shift/>
            </options>
            <comment>Note: for unvalid values the memory interface will run at 26MHz
            </comment>
       </bits>
    </reg>

     <reg name="Cfg_Clk_Out" protect="rw">
         <bits name="ClkOut_Sel"     pos="4:0"    access="rw" rst="0">
             <options>
                 <option name="clk_sys" value="0"/>
                 <option name="clk_bb " value="1"/>
                 <option name="clk_per" value="2"/>
                 <option name="clk_tcu" value="3"/>
                 <option name="clk_host_uart" value="4"/>
                 <option name="clk_uart1" value="5"/>
                 <option name="clk_rf_rx" value="6"/>
                 <option name="clk_lps" value="7"/>
                 <option name="clk_gpio" value="8"/>
                 <option name="clk_spiflash" value="9"/>
                 <option name="clk_mem_bridge" value="10"/>
                 <option name="clk_mem_bridge_out" value="11"/>
                 <option name="clk_mem_bridge_fast" value="12"/>
                 <option name="clk_usb_48m" value="13"/>
                 <option name="clk_slow" value="14"/>
                 <option name="clk_32k" value="15"/>
                 <default/>
                 <mask/>
                 <shift/>
             </options>
        </bits>
        <bits name="ClkOut_Enable"   pos="5"    access="rw" rst="0">
            <comment>Clk_out enable. </comment>
            <options>
                <option name="disable" value="0"></option>
                <option name="enable" value="1"></option>
            </options>
        </bits>
    </reg>

    <reg name="Cfg_Clk_BB" protect="rw">
       <bits name="BB_Freq"   pos="3:0"  access="rw" rst="b0010">
           <options>
               <option name="312M" value="13"/>
               <option name="250M" value="12"/>
               <option name="208M" value="11"/>
               <option name="178M" value="10"/>
               <option name="156M" value="9"/>
               <option name="139M" value="8"/>
               <option name="125M" value="7"/>
               <option name="113M" value="6"/>
               <option name="104M" value="5"/>
               <option name="89M" value="4"/>
               <option name="78M" value="3"/>
               <option name="52M" value="2"/>
               <option name="39M" value="1"/>
               <option name="26M" value="0"/>
               <default/>
               <mask/>
               <shift/>
            </options>
            <comment>Note: for unvalid values the memory interface will run at 26MHz
            </comment>
       </bits>
    </reg>
    
    <reg name="Cfg_Clk_AudioBCK_Div" protect="rw">
        <bits name="AudioBck_Divider" pos="10:0" access="rw" rst="all1">
            <comment> denominator of audio bck divider.
            </comment>
        </bits>
        <bits name="AudioBck_Update" pos="11" access="rw" rst="0">
        </bits>
    </reg>

    <reg name="Cfg_Aif_Tx_Stb_Div" protect="rw">
        <bits name="aif_tx_stb_div" pos="12:0" access="rw" rst="all1">
            <comment> denominator of aif clk divider.
            </comment>
        </bits>
        <bits name="aif_tx_stb_update" pos="13" access="rw" rst="0">
        </bits>
        <bits name="aif_tx_stb_sel" pos="15:14" access="rw" rst="0">
            <options>
               <option name="sel_codec_clk" value="0"/>
               <option name="sel_52m_clk" value="1"/>
               <option name="sel_fm_clk" value="2"/>
               <default/>
               <mask/>
               <shift/>
           </options>
           <comment>aif_clk_root select.
                <br/>0: i_clk_codec
                <br/>1: xtal 52M
                <br/>2: fm clock
            </comment>
        </bits>
        <bits name="aif_tx_stb_en" pos="16" access="rw" rst="0">
            <comment>aif clock enable.
                <br/>0: disable
                <br/>1: enable
            </comment>
        </bits>
    </reg>

    <reg name="Cfg_Clk_Uart"    protect="rw" count="3" >
        <bits name="Uart_Divider"    pos="23:0"   access="rw" rst="b000000000011100000000001">
            <comment>[9:0]     numerator
                <br/>[23:10]   denominator
            </comment>               
        </bits>
        <bits name="Uart_Update"    pos="24"   access="rw" rst="0">
        </bits>
        <bits name="Cfg_Uart_Num"    pos="9:0"   access="rw" rst="b0000000001">
            <comment> The numerator of uart divider
            </comment>               
        </bits>
        <bits name="Cfg_Uart_Denom"    pos="23:10"   access="rw" rst="b00000000001110">
            <comment> The denominator of uart divider
            </comment>               
        </bits>

    </reg>

    <reg name="Cfg_Clk_PWM"  protect="rw">
        <bits name="PWM_Divider"    pos="7:0"   access="rw" rst="all1">
            <comment>The Pwm reference clock frequency is the system clock divided by this register value + 1.
            </comment>
        </bits>
    </reg>

    <reg name="Cfg_Clk_Auxclk"  protect="rw">
        <bits name="AUXCLK_EN"    pos="0"   access="rw" rst="0">
            <comment>AUXCLK out enable. (26MHz coming from Xcver) </comment>
           <options>
               <option name="disable" value="0"></option>
               <option name="enable" value="1"></option>
           </options>
        </bits>
    </reg>

<hole size="32"/>

    <reg name="Cfg_Clk_Camera_Out" protect="rw">
        <bits name="Clk_Camera_Out_En" pos="0" access="rw" rst="0">
            <comment>Clk_Camera_out enable. </comment>
            <options>
                <option name="disable" value="0"></option>
                <option name="enable" value="1"></option>
            </options>
        </bits>
        <bits name="Clk_Cam_Out_Mode" pos="1" access="rw" rst="0">
            <comment>If camera fifo is almost full, disable clk_camera_out.</comment>    
            <options>
                <option name="off" value="0"></option>
                <option name="on" value="1"></option>
            </options>
        </bits>
        <bits name="Clk_Cam_Out_Sel" pos="2" access="rw" rst="0">
            <comment>Select from which clock the clock camera is generated. </comment>
            <options>
                <option name="156MHz" value="0"></option>
                <option name="52MHz" value="1"></option>
            </options>
        </bits>
        <bits name="Clk_Camera_Out_Div" pos="7:4" access="rw" rst="8">
            <comment>Clk_Camera_out divider. </comment>
            <options>
               <mask/>
               <shift/>
            </options>
        </bits>
        <bits name="Clk_Cam_Out_Update" pos="8" access="r" rst="0">
            <comment>Clk_Camera_out divider update. </comment>
        </bits>
        <bits name="Clk_SPI_Camera_Div" pos="26:16" access="rw" rst="200">
            <comment>Clk_SPI_Camera divider. </comment>
        </bits>
        <bits name="Clk_SPI_Cam_Update" pos="27" access="r" rst="0">
            <comment>Clk_SPI_Camera divider update. </comment>
        </bits>
        <bits name="Clk_SPI_Cam_Pol" pos="28" access="rw" rst="0">
            <comment>Clk_SPI_Camera polarity. </comment>
        </bits>
    </reg>
         

    <reg name="Cfg_AHB" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Sys_New_Arbitration" pos="0" access="rw" rst="1">
            <comment>Used to solve the possible AHBC arbitration bug. The new arbitration scheme will give the priority to a unsplitted master over a new comer who was not splitted before. To use this feature please enable the AHB_Cmd_Full_Shift fix in the Membridge FIFO Control as well.</comment>
            <options>
                <option name="Enable" value="1"></option>
                <option name="Disable" value="0"></option>
            </options>
        </bits>
        <bits name="Sys_Enable" pos="SYS_NB_MASTERS:1" access="rw" rst="1" cut="1" cutprefix="Enable" cutenum="Sys_Master_Id" cutstart="1">
            <options>
                <option name="Enable" value="1"><comment>Normal configuration</comment></option>
                <option name="Disable" value="0"><comment>The master is never granted on the System AHB</comment></option>
            </options>
        </bits>
        <bits name="Sel_GOUDA_AHB_MEMB" pos="15" access="rw" rst="1">
            <comment>Select Gouda data bus mode: AHB or Memory bridge direct.</comment>
            <options>
                <option name="AHB" value="1"></option>
                <option name="Mem_bridge" value="0"></option>
            </options>
        </bits>
        <bits name="BB_New_Arbitration" pos="16" access="rw" rst="1">
            <comment>The new arbitration scheme will give the priority to a unsplitted master over a new comer who was not splitted before.</comment>
            <options>
                <option name="Enable" value="1"></option>
                <option name="Disable" value="0"></option>
            </options>
        </bits>
        <bits name="BB_Enable" pos="BB_NB_MASTERS+16:17" access="rw" rst="1" cut="1" cutprefix="Enable" cutenum="BB_Master_Id" cutstart="1">
            <options>
                <option name="Enable" value="1"><comment>Normal configuration</comment></option>
                <option name="Disable" value="0"><comment>The master is never granted on the Baseband AHB</comment></option>
            </options>
        </bits>

        <bits name="USB_Ram_Test_Mode" pos="31" access="rw" rst="0">
            <options>
                <option name="Enable" value="1"><comment>USB Ram test mode, allow access to 3 upper bits of the USB ram: mapped as lower bits</comment></option>
                <option name="Disable" value="0"><comment>Normal usage of the USB Ram</comment></option>
            </options>
        </bits>
    </reg>

    <reg name="Ctrl_AHB" protect="rw">
        <comment>This register is protected. Used to unsplit masters manualy.
        </comment>
        <bits name="Sys_Force_HSPLIT" pos="SYS_NB_MASTERS-1:0" access="rw" rst="1" cut="1" cutprefix="SPLIT" cutenum="Sys_Master_Id" cutstart="1">
            <options>
                <option name="Normal" value="1"><comment>Normal configuration</comment></option>
                <option name="Force" value="0"><comment>The master is Unsplitted</comment></option>
            </options>
        </bits>
        <bits name="BB_Force_HSPLIT" pos="BB_NB_MASTERS+15:16" access="rw" rst="1" cut="1" cutprefix="SPLIT" cutenum="BB_Master_Id" cutstart="1">
            <options>
                <option name="Normal" value="1"><comment>Normal configuration</comment></option>
                <option name="Force" value="0"><comment>The master is Unsplitted</comment></option>
            </options>
        </bits>
    </reg>

    <reg name="XCpu_Dbg_BKP" protect="rw">
        <bits name="BKPT_En" pos="0" access="rw" rst="0">
            <comment>Enable XCPU hardware breakpoint.
            </comment>
        </bits>
        <bits name="BKPT_Mode" pos="5:4" access="rw" rst="all1" display="bin">
            <options>
                <option name="I" value="0"><comment>Breakpoint is triggered when an instruction is fetched at XCpu_Dbg_Addr</comment></option>
                <option name="R" value="1"><comment>Breakpoint triggered when a data is read at XCpu_Dbg_Addr</comment></option>
                <option name="W" value="2"><comment>Breakpoint triggered when a data is written at XCpu_Dbg_Addr</comment></option>
                <option name="RW" value="3"><comment>Breakpoint triggered when a data is read OR written at XCpu_Dbg_Addr</comment></option>
                <default/>
            </options>
        </bits>
        <bits name="Stalled"    pos="8" access="rc" rst="0">
            <comment>When 1 the cpu is stalled and stays stalled until this bit is set to 0, when 0 the stall condition depends on the breakpoint trigger. If the breakpoint is triggered, the cpu stalls. It can be released by writing a 0 to this bit.
            </comment>
        </bits>
    </reg>
    <reg name="XCpu_Dbg_Addr" protect="rw">
        <bits name="Breakpoint address" pos="NB_BITS_ADDR-1:0" access="rw" rst="no" display="hex">
            <comment>Physical address of breakpoint
            </comment>
        </bits>
    </reg>
    <reg name="BCpu_Dbg_BKP" protect="rw">
        <bits name="BKPT_En" pos="0" access="rw" rst="0">
            <comment>Enable BCPU hardware breakpoint.
            </comment>
        </bits>
        <bits name="BKPT_Mode" pos="5:4" access="rw" rst="all1" display="bin">
            <options>
                <option name="I" value="0"><comment>Breakpoint is triggered when an instruction is fetched at BCpu_Dbg_Addr</comment></option>
                <option name="R" value="1"><comment>Breakpoint triggered when a data is read at BCpu_Dbg_Addr</comment></option>
                <option name="W" value="2"><comment>Breakpoint triggered when a data is written at BCpu_Dbg_Addr</comment></option>
                <option name="RW" value="3"><comment>Breakpoint triggered when a data is read OR written at BCpu_Dbg_Addr</comment></option>
                <default/>
            </options>
        </bits>
        <bits name="Stalled"    pos="8" access="rc" rst="0">
            <comment>When 1 the cpu is stalled and stays stalled until this bit is set to 0, when 0 the stall condition depends on the breakpoint trigger. If the breakpoint is triggered, the cpu stalls. It can be released by writing a 0 to this bit.
            </comment>
        </bits>
    </reg>
    <reg name="BCpu_Dbg_Addr" protect="rw">
        <bits name="Breakpoint address" pos="NB_BITS_ADDR-1:0" access="rw" rst="no" display="hex">
            <comment>Physical address of breakpoint
            </comment>
        </bits>
        
    </reg>
    
    <reg name="Cfg_Cpus_Cache_Ram_Disable" protect="rw">
        <bits name="XCpu_Use_Mode"  pos="0" access="rw" rst="0">
            <comment>When 1 the XCPU deselects its cache rams automatically when not in use, when 0 this feature is disabled.
            </comment>
        </bits>
        <bits name="XCpu_Clk_Off_Mode" pos="1" access="rw" rst="0">
            <comment>When 1 the cache rams are automatically deselected  when the XCPU clock is shutdown, when 0 this feature is disabled.
            </comment>
        </bits>
        <bitgroup name="XCpu_Cache_Ram_Disable">
            <entry ref="XCpu_Use_Mode"/>
            <entry ref="XCpu_Clk_Off_Mode"/>
        </bitgroup>
        <bits name="BCpu_Use_Mode"  pos="16" access="rw" rst="0">
            <comment>When 1 the BCPU deselects its cache rams automatically when not in use, when 0 this feature is disabled.
            </comment>
        </bits>
        <bits name="BCpu_Clk_Off_Mode" pos="17" access="rw" rst="0">
            <comment>When 1 the cache rams are automatically deselected  when the BCPU clock is shutdown, when 0 this feature is disabled.
            </comment>
        </bits>
        <bitgroup name="BCpu_Cache_Ram_Disable">
            <entry ref="BCpu_Use_Mode"/>
            <entry ref="BCpu_Clk_Off_Mode"/>
        </bitgroup>
        
    </reg>

    <reg name="Reset_Cause" protect="rw">
        
        <bits name="WatchDog_Reset" pos="0" access="rw" rst="no">
            <options>
                <option name="Happened" value="1"><comment>A watchdog reset has happened</comment></option>
                <option name="No" value="0"><comment>No watchdog reset happened since the last HW reset or power on.</comment></option>
            </options>
            <comment>Writing a 1 to this bit will reset the bits watchdog_Reset cause, GlobalSoft_Reset cause and HostDebug_Reset cause to 0.
            </comment>
        </bits>
        <bits name="GlobalSoft_Reset" pos="4" access="r" rst="no">
            <options>
                <option name="Happened" value="1"><comment>A reset was initiated from Global soft reset register</comment></option>
                <option name="No" value="0"><comment>The reset was not from the soft reset register.</comment></option>
            </options>
        </bits>
        <bits name="HostDebug_Reset" pos="8" access="r" rst="no">
            <options>
                <option name="Happened" value="1"><comment>A reset was initiated from the Host interface</comment></option>
                <option name="No" value="0"><comment>The reset was not from the debug interface.</comment></option>
            </options>
        </bits>
        <bits name="AlarmCause" pos="12" access="r" rst="no">
            <options>
                <option name="Happened" value="1"><comment>An Alarm occur from the calendar</comment></option>
                <option name="No" value="0"><comment>No Alarm occur.</comment></option>
            </options>
        </bits>       
        <bits name="Boot_Mode" pos="21:16" access="rw" rst="6'h28">
            <comment>This contains the state of boot mode pins latched during Reset.
                <br/> bit 16: BOOT_MODE_NO_AUTO_PU.
                <br/> bit 17: BOOT_MODE_FORCE_MONITOR.
                <br/> bit 18: BOOT_MODE_UART_MONITOR_ENABLE.
                <br/> bit 19: BOOT_MODE_USB_MONITOR_DISABLE.
                <br/> bit 20: BOOT_MODE_NAND_FLASH_ENABLE.
                <br/> bit 21: BOOT_MODE_FLASH_ADMUX.
                <br/> see BootSequence for details.
                <br/> This register is not reseted by a software or host reset.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="SW_Boot_Mode" pos="27:22" access="rw" rst="no">
            <comment> Software boot mode (Reseted at zero by external reset pin)
                <br/> This register is not reseted by a software or host reset.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Fonctional_Test_Mode" pos="31" access="r" rst="no">
            <comment>When 1 the chip has booted in fonctional test mode (for chip production tests).
            </comment>
        </bits>
    </reg>
    
   <reg name="WakeUp" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="force_Wakeup" pos="0" access="rw" rst="0">
            <comment>When 1, the wake up is set. When 0, the wake up is clear .
            </comment>
        </bits>
    </reg>

   <reg name="Ignore_Charger_REG" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Ignore_Charger" pos="0" access="rw" rst="0">
            <comment>When 1, the CHG_MASK line to PMU is set. When 0, it is cleared.
            </comment>
        </bits>
    </reg>

    <reg name="Cfg_Clk_SpiFlash" protect="rw">
       <bits name="Spiflash_Freq"   pos="3:0"  access="rw" rst="b0011">
           <options>
               <option name="312M" value="13"/>
               <option name="250M" value="12"/>
               <option name="208M" value="11"/>
               <option name="178M" value="10"/>
               <option name="156M" value="9"/>
               <option name="139M" value="8"/>
               <option name="125M" value="7"/>
               <option name="113M" value="6"/>
               <option name="104M" value="5"/>
               <option name="89M" value="4"/>
               <option name="78M" value="3"/>
               <option name="52M" value="2"/>
               <option name="39M" value="1"/>
               <option name="26M" value="0"/>
               <default/>
               <mask/>
               <shift/>
            </options>
            <comment>Note: for unvalid values the memory interface will run at 26MHz
            </comment>
       </bits>
    </reg>

<hole size="32"/>    

    <reg name="Clk_Sys_Enable2" protect="rw">
        <bits name="Enable_Clk_Sys_Msb"     pos="NB_SYS_CLK_EN-1-NB_SYS_CLK_AEN:NB_SYS_CLK_AEN - NB_SYS_CLK_AEN"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="Sys_Clks" cutstart="NB_SYS_CLK_AEN">
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_Sys_Disable2" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_Sys_Msb"    pos="NB_SYS_CLK_EN-1-NB_SYS_CLK_AEN:NB_SYS_CLK_AEN-NB_SYS_CLK_AEN"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="Sys_Clks" cutstart="NB_SYS_CLK_AEN">
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>

<hole size="160"/>

   <reg name="CFG_XTAL_DIV" protect="rw">
        <bits name="CFG_XTAL_DIV" pos="4:0" access="rw" rst="0b00010">
            <comment>[4:0]    denominator
            </comment>               
        </bits>
        <bits name="CFG_XTAL_DIV_UPDATE" pos="5" access="rw" rst="0">
        </bits>
    </reg>

<hole size="320"/>

   <reg name="Cfg_Rsd" protect="rw">
        <comment>This register is reserved.
        </comment>
        <bits name="Reserve" pos="15:0" access="rw" rst="0xf0f0">
            <comment>This register is reserved.
            </comment>
        </bits>
    </reg>
</module>

</archive>

<archive relative = "sys_ifc.xml">

<include file="globals.xml"/>

<include file="gallite_generic_config.xml"/>

<var name="SYS_IFC_ADDR_ALIGN" value="0" />

<var name="SYS_IFC_TC_LEN" value="23" />

<var name="SYS_IFC_STD_CHAN_NB" value="SYS_IFC_NB_STD_CHANNEL" /> 

<var name="SYS_IFC_RFSPI_CHAN" value="1" />

<module name="sys_ifc" category="System">
  

  <reg protect="--" name="get_ch">
    <bits access="r" name="ch_to_use" pos="3:0" rst="0">
      <comment>This field indicates which standard channel to use.
      <br /> Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
      <br /> After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
      <br />0000 = use Channel0
      <br />0001 = use Channel1
      <br />0010 = use Channel2 
      <br /> ...
      <br />0111 = use Channel7
      <br />1111 = all channels are busy</comment>
      <options><mask/><shift/><default/></options>
    </bits>
  </reg>

  <reg protect="r" name="dma_status">
    <bits access="r" name="ch_enable" pos="SYS_IFC_STD_CHAN_NB+SYS_IFC_RFSPI_CHAN-1:0" rst="0">
      <comment>This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
      <br />0000_0000 = All channels disabled 
      <br />0000_0001 = Ch0 enabled 
      <br />0000_0010 = Ch1 enabled 
      <br />0000_0100 = Ch2 enabled 
      <br />0000_0101 = Ch0 and Ch2 enabled 
      <br />0000_0111 = Ch0, Ch1 and Ch2 enabled 
      <br />1111_1111 = all channels enabled</comment>
    </bits>

    <bits access="r" name="ch_busy" pos="SYS_IFC_STD_CHAN_NB-1+16:16" rst="0">
      <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
    </bits>
  </reg>

  <reg protect="r" name="debug_status">
    <bits access="r" name="dbg_status" pos="0" rst="1">
      <comment>Debug Channel Status .<br />0= The debug channel is running
      (not idle) <br />1= The debug channel is in idle mode</comment>
    </bits>
  </reg>

  <hole size="32" />

  

  <struct count="SYS_IFC_STD_CHAN_NB" name="std_ch">
    <reg protect="rw" name="control">
      <bits access="w" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer. </comment>
      </bits>

      <bits access="w" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit disable the channel.
        <br />When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled. </comment>
      </bits>


      <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
        <comment>Exchange the read data from fifo halfword MSB or LSB
        <br />
    </comment>
      </bits>

      <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
        <comment>Exchange the write data to fifo  halfword MSB or LSB
        <br />
    </comment>
      </bits>


      <bits access="rw" name="autodisable" pos="4" rst="1">
        <comment>Set Auto-disable mode<br /> 0 = when TC reach zero the
        channel is not automatically released.<br /> 1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.</comment>
      </bits>
      
      <bits access="rw" name="Size" pos="5" rst="0">
        <comment>Peripheral Size
            <br /> 0= 8-bit peripheral
            <br /> 1= 32-bit peripheral
        </comment>
      </bits>

      <bits access="rw" name="req_src" pos="12:8" rst="0x7" display="hex">
        <options linkenum="Sys_Ifc_Request_IDs"> 
        
          <shift/><mask/><default/>
        </options>

        <comment>Select DMA Request source</comment>
      </bits>

        <bits access="rw" name="flush" pos="16" rst="0">
        <comment>When one, flush the internal FIFO channel. 
        <br />This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel. 
        <br /> Before writting back this bit to zero the internal fifo must empty.
        </comment>
      </bits>

        <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
        <comment>Set the MAX burst length for channel 0,1. 
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.  
        <br /> The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4. 
        <br /> .
        </comment>



        
      </bits>
    </reg>

    <reg protect="r" name="status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>The internal channel fifo is empty </comment>
      </bits>
    </reg>

    <reg protect="rw" name="start_addr">
      <bits access="rw" name="start_addr"
            pos="NB_BITS_ADDR-1:SYS_IFC_ADDR_ALIGN" rst="0xFFFFFFF" display="hex">
        <comment>AHB Address. This field represent the start address of the
        transfer.
        <br />For a 32-bit peripheral, this address must be aligned 32-bit.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="tc">
      <bits access="rw" name="tc" pos="SYS_IFC_TC_LEN-1:0" rst="0xFFFFFF" display="hex">
        <comment>Transfer Count, this field indicated the transfer size in bytes to perform.
        <br />During a transfer a write in this register add the new value to the current TC. 
        <br />A read of this register return the current current transfer count.
        </comment>
      </bits>
    </reg>
  </struct>
  
  

  <reg protect="rw" name="ch_rfspi_control">
      <bits access="s" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />This channel works only in fifo mode. </comment>
      </bits>

      <bits access="c" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit to disable the channel.
        </comment>
      </bits>
    </reg>

    <reg protect="r" name="ch_rfspi_status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>The internal channel fifo is empty </comment>
      </bits>
      
      <bits access="r" name="fifo_level" pos="12:8" rst="0">
        <comment>Internal fifo level </comment>
      </bits>
    </reg>

    <reg protect="rw" name="ch_rfspi_start_addr">
      <bits access="rw" name="start_AHB_addr"
            pos="NB_BITS_ADDR-1:SYS_IFC_ADDR_ALIGN" rst="0xFFFFFFF" display="hex">
        <comment>AHB Start Address. <br />This field represent the start address of the fifo.
                 The start address must 32-bit aligned.
        </comment>
      </bits>
    </reg>
    
    <reg protect="rw" name="ch_rfspi_end_addr">
      <bits access="rw" name="end_AHB_addr"
            pos="NB_BITS_ADDR-1:SYS_IFC_ADDR_ALIGN" rst="0xFFFFFFF" display="hex">
        <comment>AHB End Address. <br />This field represent the last address of the fifo (it is the first address not used in the fifo). <br />The end address must 32-bit aligned.
        </comment>
      </bits>
    </reg>


    <reg protect="rw" name="ch_rfspi_tc">
      <bits access="rw" name="ch_rfspi_tc" pos="13:0" rst="0x0" display="hex">
        <comment>Transfer Count, transfer size in bytes. <br />This bit
        indicated the transfer size in bytes to perform. Up to 16kbytes per
        transfer. <br />During a transfer a write in this register add the new
        value to the current TC. A read of this register return the current
        current transfer count.</comment>
      </bits>
    </reg>
</module>

</archive>

<archive relative = "sys_ifc2.xml">
<include file="globals.xml"/>
<module name="sys_ifc2" category="System">
  <var name="SYS_IFC2_ADDR_LEN" value="15" />

  <var name="SYS_IFC2_ADDR_ALIGN" value="2" />

  <var name="SYS_IFC2_TC_LEN" value="8" />

  

  <struct count="2" name="ch">
    <comment>
        The Channel 0 conveys data from the AIF to the memory.<br/>
        The Channel 1 conveys data from the memory to the AIF.
        <br/>These Channels only exist with Voice Option.
    </comment>
    <reg protect="rw" name="control">
      <bits access="w" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer. </comment>
      </bits>

      <bits access="w" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit disable the channel.
        <br />When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled. </comment>
      </bits>

      <bits access="rw" name="auto_disable" pos="4" rst="0">
        <comment>Automatic channel Disable. When this bit is set, the channel is automatically disabled at the next interrupt. 
        </comment>
      </bits>
    </reg>

    <reg protect="r" name="status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>When 1 the channel is enabled</comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>When 1 the fifo is empty </comment>
      </bits>

      <bits access="r" name="cause_ief" pos="8" rst="0">
        <comment>Cause interrupt End of FIFO. </comment>
      </bits>

      <bits access="r" name="cause_ihf" pos="9" rst="0">
        <comment>Cause interrupt Half of FIFO. </comment>
      </bits>

      <bits access="r" name="cause_i4f" pos="10" rst="0">
        <comment>Cause interrupt Quarter of FIFO. </comment>
      </bits>
      
      <bits access="r" name="cause_i3_4f" pos="11" rst="0">
        <comment>Cause interrupt Three Quarter of FIFO. </comment>
      </bits>

      <bits access="r" name="ief" pos="16" rst="0">
        <comment>End of FIFO interrupt status bit. </comment>
      </bits>

      <bits access="r" name="ihf" pos="17" rst="0">
        <comment>Half of FIFO interrupt status bit. </comment>
      </bits>

      <bits access="r" name="i4f" pos="18" rst="0">
        <comment>Quarter of FIFO interrupt status bit. </comment>
      </bits>

      <bits access="r" name="i3_4f" pos="19" rst="0">
        <comment>Three Quarter of FIFO interrupt status bit.</comment>
      </bits>
    </reg>

    <reg protect="rw" name="start_addr">
      <bits access="rw" name="start_addr"
            pos="NB_BITS_ADDR-1:SYS_IFC2_ADDR_ALIGN" rst="0xFFFFFFFF" display="hex">
        <comment>AHB Start Address. This field represent the start address of the FIFO located in RAM.
        </comment>
      </bits>
     </reg>

    <reg protect="rw" name="Fifo_Size">
      <bits access="rw" name="Fifo_Size" pos="14:4" rst="0xFFF" display="hex">
        <comment>Fifo size in bytes, max 32kBytes.
            <br />The size of the fifo must be a multiple of 16 (The four LSB are always zero). 
        </comment>
      </bits>
    </reg>
    <hole size="32" />
    <reg protect="rw" name="int_mask">
      <bits access="rw" name="end_fifo" pos="8" rst="0">
        <comment>END FIFO Mask interrupt. When one this interrupt is enabled.
        </comment>
      </bits>

      <bits access="rw" name="half_fifo" pos="9" rst="0">
        <comment>HALF FIFO Mask interrupt. When one this interrupt is enabled.
        </comment>
      </bits>

      <bits access="rw" name="quarter_fifo" pos="10" rst="0">
        <comment>QUARTER FIFO Mask interrupt. When one this interrupt is
        enabled. </comment>
      </bits>
      
      <bits access="rw" name="three_quarter_fifo" pos="11" rst="0">
        <comment>THREE QUARTER FIFO Mask interrupt. When one this interrupt is
        enabled. </comment>
      </bits>
    </reg>

    <reg protect="rw" name="int_clear">
      <bits access="c" name="end_fifo" pos="8" rst="0">
        <comment>Write one to clear end of fifo interrupt. </comment>
      </bits>

      <bits access="c" name="half_fifo" pos="9" rst="0">
        <comment>Write one to clear half of fifo interrupt. </comment>
      </bits>

      <bits access="c" name="quarter_fifo" pos="10" rst="0">
        <comment>Write one to clear Quarter fifo interrupt. </comment>
      </bits>

      <bits access="c" name="three_quarter_fifo" pos="11" rst="0">
        <comment>Write one to clear Three Quarter fifo interrupt. </comment>
      </bits>
    </reg>

    <reg protect="r" name="cur_ahb_addr">
      <bits access="r" name="cur_ahb_addr" pos="NB_BITS_ADDR-1:0" rst="0" display="hex">
        <comment>Current AHB address value. The nine MSB bit is constant and
        equal to the PAGE_ADDR field in the IFC_CH_AHB_START_ADDR register.
        </comment>
      </bits>
    </reg>
  </struct>
</module>
</archive>
<archive relative = "sys_irq.xml">

<include file="globals.xml"/>

<module name="sys_irq" category="System">
    
    
    <enum name="XCPU_Irq_Lines">
        <entry name="XCpu_Main_Irq_Line"><comment>XCPU Irq Lines</comment></entry>
        
        <entry name="XCpu_Page_Spy_Irq_Line" value="3"/>
        <entry name="XCpu_Debug_Irq_Line" value="4"/>
        <entry name="XCpu_Host_Irq_Line"/>
    </enum>


    <reg name="Cause" protect="r">
        <comment>If cause is not null and interrupt are enabled then the interrupt line 0 is driven on the system CPU.
            <br/>The cause for the Irq sources, one bit for each module's irq source.
            <br/>The cause is the actual Irq source masked by the mask register.
        </comment>
        <bits name="Cause" pos="SYS_NB_IRQ-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Status" protect="r">
        <comment>The status for the level Irq sources, one bit for each module's irq source.
            <br/>The status reflect the actual Irq source.
        </comment>
        <bits name="Status" pos="SYS_NB_IRQ-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Mask_Set" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Set" pos="SYS_NB_IRQ-1:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Mask_Clear" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Clr" pos="SYS_NB_IRQ-1:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="NonMaskable" protect="rw">
        <bits name="Main_IRQ" pos="10" access="r" rst="0">
            <comment>This is the Main Irq source it drive the system CPU interrupt line 0.
                <br/>This bit comes from the modules irq and is masked by the Mask and SC registers.
            </comment>
        </bits>
        <bits name="Page_Spy_IRQ" pos="13" access="r" rst="0">
            <comment>This is the Page Spy Irq source it drive the system CPU interrupt line 3.
                <br/>This bit is controlled by the page spy module.
            </comment>
        </bits>
        <bits name="Debug_IRQ" pos="14" access="rw" rst="0">
            <comment>This is the debug Irq source, the value written here drives the system CPU interrupt line 4.
            </comment>
        </bits>
        <bits name="Host_IRQ" pos="15" access="r" rst="0">
            <comment>This is the Host Irq source it drive the system CPU interrupt line 5.
                <br/>This bit is controlled by the host internal register.
            </comment>
        </bits>
        <bits name="IntEnable_Status" pos="31" access="r" rst="1">
            <comment>Status of the Interrupt enable semaphore bit.
            </comment>
        </bits>
   </reg>
    <reg name="SC" protect="">
        <bits name="IntEnable" pos="0" access="rw" rst="1">
            <comment>Interrupt enable semaphore, used for critical section.
                <br/>Read returns its value and then clears it to '0' disabling interrupts.
                <br/>Write the read value to restore the previous state, this will exit the critical section.
            </comment>
        </bits>
    </reg>
    <reg name="WakeUp_Mask" protect="rw">
        <comment>Each bit to '1' in that registers allows the correcponding interrupt to wake up the System CPU (i.e.: Reenable it's clock, see CLOCK_SYS_ENABLE and CLOCK_SYS_DISABLE registers in sys_ctrl registers section)
        </comment>
        <bits name="WakeUp_Mask" pos="SYS_NB_IRQ-1:0" access="rw" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Cpu_Sleep" protect="w">
        <bits name="Sleep" pos="0" access="w" rst="0">
            <comment>Writing '1' to this bit will put the XCPU to sleep (i.e.: Disable it's clock, see CLOCK_SYS_ENABLE and CLOCK_SYS_DISABLE registers in sys_ctrl registers section)
            </comment>
        </bits>
    </reg>
    <reg name="Pulse_Mask_Set" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Pulse_Mask_Set" pos="SYS_NB_IRQ_PULSE-1:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Mask_Clr" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Pulse_Mask_Clr" pos="SYS_NB_IRQ_PULSE-1:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Clear" protect="rw">
        <comment>Writing '1' clears the corresponding Pulse IRQ.
            <br/>Pulse IRQ are set by the modules and cleared here.
        </comment>
        <bits name="Pulse_Clr" pos="SYS_NB_IRQ_PULSE-1:0" access="c" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Status" protect="r">
        <comment>The status for the Pulse Irq sources, one bit for each module's irq source.
            <br/>The status reflect the actual Irq source.
        </comment>
        <bits name="Pulse_Status" pos="SYS_NB_IRQ_PULSE-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>

</module>

</archive>
<archive relative = "tcu.xml">

<module name="tcu" category="Modem">

    
    <var name="NB_TCO" value="12"/> 
    <var name="NB_TCU_PROG_EVENTS" value="60"/>

    <enum name="Internal_TCO_mapping">
        <entry name="TCO_GMSK_ON" value="6"><comment>Internal TCO mapping</comment></entry>
        <entry name="TCO_TX_OEN"/>
        <entry name="TCO_TX_ON"/>
        <entry name="TCO_RX_ON"/>
        <entry name="TCO_RX_DEC_ON"/>
        <entry name="TCO_PDN"/>
    </enum>

    <enum name="TCU_Event">
        
        <entry name="Clr_TCO_0" value="0"><comment>Clear TCO 0 : set the TCO 0 to the inactive state<br/>To clear TCO n, use event 2*n</comment></entry>
        <entry name="Set_TCO_0" value="1"><comment>Set TCO 0 : set the TCO 0 to the active state<br/>To set TCO n, use event 2*n+1</comment></entry>
        <entry name="Clr_TCO_1"><comment>...</comment></entry>
        
        
        <entry name="Stop_GMSK" value="TCO_GMSK_ON*2"><comment>stop modulation</comment></entry>
        <entry name="Start_GMSK" value="TCO_GMSK_ON*2+1"><comment>starts modulation and output on IQ DAC</comment></entry>
        <entry name="HighZ_IQ_DAC" value="TCO_TX_OEN*2"/>
        <entry name="Drive_IQ_DAC" value="TCO_TX_OEN*2+1"/>
        <entry name="disable_IQ_DAC" value="TCO_TX_ON*2"/>
        <entry name="enable_IQ_DAC" value="TCO_TX_ON*2+1"/>
        <entry name="disable_IQ_ADC" value="TCO_RX_ON*2"><comment>disable IQ ADC</comment></entry>
        <entry name="enable_IQ_ADC" value="TCO_RX_ON*2+1"><comment>enable IQ ADC</comment></entry>
        <entry name="stop_RFin_record" value="TCO_RX_DEC_ON*2"><comment>stop recording IQ samples</comment></entry>
        <entry name="start_RFin_record" value="TCO_RX_DEC_ON*2+1"><comment>start recording IQ samples</comment></entry>
        <entry name="Clr_PDN" value="TCO_PDN*2"><comment>Clear RF_PDN</comment></entry>
        <entry name="Set_PDN" value="TCO_PDN*2+1"><comment>Set RF_PDN</comment></entry>
        
        <entry name="SEND_SPI_CMD" value="NB_TCO*2"><comment>Send RF spi command</comment></entry>
        <entry name="NEXT_GAIN"/>
        <entry name="FIRST_GAIN"/>
        
        <entry name="NEXT_FC"/>
        
        <entry name="PA_RAMP0"><comment>Start Ramp 0</comment></entry>
        <entry name="PA_RAMP1"><comment>Start Ramp 1</comment></entry>
        <entry name="PA_RAMP2"><comment>Start Ramp 2</comment></entry>
        <entry name="PA_RAMP3"><comment>Start Ramp 3</comment></entry>
        <entry name="PA_RAMP4"><comment>Start Ramp 4</comment></entry>
        <entry name="RX_SOC"/>
        <entry name="DIGRF_STB"/>
        
        <entry name="BCPU_TCU_IRQ0"><comment>Trigger BCPU TCU irq 0</comment></entry>
        <entry name="BCPU_TCU_IRQ1"><comment>Trigger BCPU TCU irq 1</comment></entry>
        
        <entry name="XCPU_TCU_IRQ0"><comment>Trigger XCPU TCU irq 0</comment></entry>
        <entry name="XCPU_TCU_IRQ1"><comment>Trigger XCPU TCU irq 1</comment></entry>
        
        <entry name="WAKEUP_DONE"><comment>End of the WakeUp Mode</comment></entry>
        <entry name="NO_EVENT" value="63"/> 
    </enum>

    
    
	<var name="LP_FRAC_NB_BITS" value="16"/>
	<var name="LP_COUNT_INT_NB_BITS" value="19"/>
	<var name="LP_COUNT_NB_BITS" value="LP_COUNT_INT_NB_BITS + LP_FRAC_NB_BITS"/>
	<var name="LP_RATE_INT_NB_BITS" value="12"/>
	<var name="LP_RATE_NB_BITS" value="LP_RATE_INT_NB_BITS + LP_FRAC_NB_BITS"/>
	<var name="SYS_COUNT_NB_BITS" value="29"/>
	<var name="FRAME_COUNT_NB_BITS" value="10"/>
    
	<var name="PU_COUNT_NB_BITS" value="12"/>


    
    
    <reg name="Ctrl" protect="rw">
        <bits name="Load_Val" pos="13:0" access="rw" rst="all1" display="hex">
            <comment>Value loaded into the TCU counter when the Load bit is set to 1
            </comment>
        </bits>
        <bits name="Enable" pos="16" access="rw" rst="0">
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="Load" pos="20" access="w" rst="0">
            <comment>Writing a 1 to this bit will load the TCU with the TCU loadval value
                <br/>Writing a 0 has no effect
            </comment>
        </bits>
        <bits name="NoLatch" pos="28" access="rw" rst="0">
            <options>
                <option name="Normal" value="0"><comment>Normal Behavior, The programmation area is copied to the active area when the tcu wraps</comment></option>
                <option name="Force_Only" value="1"><comment>The programmation area is copied into the active area only when force latch is used</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Wrap_Val" protect="rw">
        <bits name="Wrap_Val" pos="13:0" access="rw" rst="all1" display="hex">
            <comment>TCU counter wrap value.
                <br/>The TCU counter returns to 0 when this value is reached
            </comment>
        </bits>
    </reg>
    <reg name="Cur_Val" protect="rw">
        <bits name="Cur_Val" pos="13:0" access="r" display="hex" rst="0">
            <comment>TCU counter current value
            </comment>
        </bits>
    </reg>
    <reg name="Latch" protect="rw">
        <bits name="ForceLatch" pos="7:0" access="w" cut="1" cutprefix="ForceLatch_Area" rst="0">
            <comment>Writing 1 transfer the programmed events to the active area.
            </comment>
        </bits>
        <bits name="Force_NoEvent" pos="16" access="w" rst="0">
            <comment>Writing 1 to this bit with one of the ForceLatch bit will force the corresponding Active Area to receive no events (i.e. clear it) instead of transfering the programmed area.
            </comment>
        </bits>
        <bits name="ClearProgArea" pos="31" access="w" rst="0">
            <comment>Writing 1 clears the Program Area
            </comment>
        </bits>
    </reg>
    <reg name="Setup" protect="rw">
        <bits name="TCO_Polarity" pos="NB_TCO-1:0" access="rw" rst="0" cut="1" cutprefix="POL_TCO">
            <comment>Configure the TCO polarity
            </comment>
            <options>
                <option name="Active High" value="0"/>
                <option name="Active Low" value="1"/>
            </options>
        </bits>
        <bits name="Write_Error" pos="28" access="rc" rst="0">
            <comment>Error Status: become 1 when writing to Program Area while the TCU is coping the Program Area to the Active Area. In this case the write is ignored.
                <br/>Write 1 to clear it.
            </comment>
        </bits>
        <bits name="Debug_Active" pos="31" access="rw" rst="0">
            <comment>This bit allows to access directly the active area for debug purposes
            </comment>
            <options>
                <option name="Normal" value="0"/>
                <option name="Debug" value="1"><comment>the active area is directly mapped instead of the program area.</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Disable_Event" protect="rw">
        <bits name="Disable_TCO" pos="9:0" access="rw" rst="all1" cut='1' cutprefix="Disable_TCO">
            <comment>Writing 1 disable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Internal_TCO" pos="14:10" access="rw" rst="all1" cut='1' cutprefix="Disable" cutenum="Internal_TCO_mapping">
            <comment>Writing 1 disable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Send_Spi_Cmd" pos="15" access="rw" rst="1">
            <comment>Writing 1 disable the events SEND_SPI_CMD.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Next_Gain" pos="16" access="rw" rst="1">
            <comment>Writing 1 disable the events NEXT_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_First_Gain" pos="17" access="rw" rst="1">
            <comment>Writing 1 disable the events FIRST_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Next_Fc" pos="18" access="rw" rst="1">
            <comment>Writing 1 disable the events NEXT_FC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Ramp" pos="23:19" access="rw" rst="all1" cut='1' cutprefix="Disable_Ramp">
            <comment>Writing 1 disable the corresponding Ramp event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Rx_SOC" pos="24" access="rw" rst="1">
            <comment>Writing 1 disable the events RX_SOC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_DigRF_Strobe" pos="25" access="rw" rst="1">
            <comment>Writing 1 disable the events DIGRF_STB.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Bcpu_Irq" pos="27:26" access="rw" rst="all1" cut='1' cutprefix="Disable_Bcpu_Irq">
            <comment>Writing 1 disable the corresponding BCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Xcpu_Irq" pos="29:28" access="rw" rst="all1" cut='1' cutprefix="Disable_Xcpu_Irq">
            <comment>Writing 1 disable the corresponding XCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Rf_Spi_Marked_Cmd" pos="31" access="rw" rst="1">
            <comment>Writing 1 disable the marked rf spi commands (cf RF SPI).
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>
    <reg name="Enable_Event" protect="rw">
        <bits name="Enable_TCO" pos="9:0" access="rs" rst="all1" cut='1' cutprefix="Enable_TCO">
            <comment>Writing 1 enable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Internal_TCO" pos="14:10" access="rs" rst="all1" cut='1' cutprefix="Enable" cutenum="Internal_TCO_mapping">
            <comment>Writing 1 enable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Send_Spi_Cmd" pos="15" access="rs" rst="1">
            <comment>Writing 1 enable the events SEND_SPI_CMD.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Next_Gain" pos="16" access="rs" rst="1">
            <comment>Writing 1 enable the events NEXT_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_First_Gain" pos="17" access="rs" rst="1">
            <comment>Writing 1 enable the events FIRST_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Next_Fc" pos="18" access="rs" rst="1">
            <comment>Writing 1 enable the events NEXT_FC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Ramp" pos="23:19" access="rs" rst="all1" cut='1' cutprefix="Enable_Ramp">
            <comment>Writing 1 enable the corresponding Ramp event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Rx_SOC" pos="24" access="rs" rst="1">
            <comment>Writing 1 enable the events RX_SOC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_DigRF_Strobe" pos="25" access="rs" rst="1">
            <comment>Writing 1 enable the events DIGRF_STB.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Bcpu_Irq" pos="27:26" access="rs" rst="all1" cut='1' cutprefix="Enable_Bcpu_Irq">
            <comment>Writing 1 enable the corresponding BCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Xcpu_Irq" pos="29:28" access="rs" rst="all1" cut='1' cutprefix="Enable_Xcpu_Irq">
            <comment>Writing 1 enable the corresponding XCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Rf_Spi_Marked_Cmd" pos="31" access="rs" rst="1">
            <comment>Writing 1 enable the marked rf spi commands (cf RF SPI).
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>
    <reg name="Set_TCO" protect="rw">
        <bits name="Set_TCO" pos="NB_TCO-1:0" access="s" cut='1' cutprefix="Set_TCO" rst="0">
            <comment>Writing 1 set corresponding TCO to the active state (The actual line state also depends on TCO_Polarity).
                <br/>Reading returns the actual state of all TCOs.
            </comment>
        </bits>
    </reg>
    <reg name="Clr_TCO" protect="rw">
        <bits name="Clr_TCO" pos="NB_TCO-1:0" access="c" cut='1' cutprefix="Clr_TCO" rst="0">
            <comment>Writing 1 set corresponding TCO to the inactive state (The actual line state also depends on TCO_Polarity).
                <br/>Reading returns the actual state of all TCOs.
            </comment>
        </bits>
    </reg>

    <reg name="Cfg_Clk_Div" protect="rw">
        <bits name="TCU_Clk_Same_Sys" pos="29" access="rw" rst="0">
            <comment>Enable Clk_TCU same with Clk_Sys.
            </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="Enable_DAI_Simple_208K" pos="30" access="rw" rst="0">
            <comment>Enable the 208kHz pulse generation for DAI Simple. (!) When enabling the clock field Enable_Qbit should also be enabled.
            </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="Enable_Qbit" pos="31" access="rw" rst="0">
            <comment>Enable the Quarter bit generation (required for normal TCU operation)
            </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
    </reg>
    <reg name="LPS_SF_Ctrl" protect="rw">
        <bits name="LPS_SF_Enable" pos="0" access="rw" rst="0">
            <comment>Lps Skip Frame Enable.
                <br/>When enabled the frame interrupt are masked until the programmed number of frames are elapsed.
                <br/>This is done by masking the frame interrupt line from the regular TCU counter, and counting the frames. Also when activating the LowPower SkipFrame the frame counter is tranfered to the low power counter that will update it based on the 32kHz Clock.
            </comment>
        </bits>
        <bits name="LPS_SF_LowPower" pos="5:4" access="rw" rst="0">
            <comment>Controls the Lps Low Power Counters (counters at 32kHz) usage.
            </comment>
            <options>
                <option name="Stop" value="0"><comment>Disable the Low Power Counters.</comment></option>
                <option name="SkipFrame" value="1"><comment>The Low Power Counters are started in Skip Frame Mode. In this mode the Low Power Counter are used to maintain the Time base, The Skip Frame Must be enabled as this is the Low Power extention of the Skip Frame feature.</comment></option>
                <option name="Calib" value="3"><comment>Start the calibration. The Low Power Counters are used to Calibrate the 32kHz clock against the System Clock, The Calibration is required to compensate from temperature variation. Note that the Skip Frame can also be enabled during calibration (but not with low power).</comment></option>
                <mask/>
                <shift/>
                <default/>
            </options>
        </bits>
        <bits name="LPS_SF_Wakeup0" pos="8" access="rw" rst="0">
            <comment>Enable fake Fint used with wakeupNumber=0. </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="LPS_SF_Wakeup0_cfg" pos="9" access="rw" rst="0">
            <comment>Enable fake Fint when sys_sf_frame_count>=cfg_sf_frame. 
                <br/>Default sys_sf_frame_count>cfg_sf_frame.
            </comment>
            <options>
                <option name="0" value="0"/>
                <option name="1" value="1"/>
            </options>
        </bits>
    </reg>
    <reg name="LPS_SF_Status" protect="rw">
        <bits name="LPS_SF_Ready" pos="0" access="r" rst="0">
            <comment>Lps Skip Frame Ready, status of the state machines to keep valid state between system clock and 32Khz clock.
                <br/>Must read as '1' before entering Low Power Skip Frame or Calibration mode.
            </comment>
        </bits>
        <bits name="LPS_SF_SlowRunning" pos="4" access="r" rst="0">
            <comment>'1' when Lps Skip Frame Low Power Counters are Running.
                <br/>When entering Low Power Skip Frame, the counters are not immediately started, they wait for the nextFrame interrupt. Reading this status allow to know if the counters are running, and the System Clock can be safely disabled.
            </comment>
        </bits>
        <bits name="LPS_SF_CalibrationDone" pos="8" access="r" rst="0">
            <comment>'1' when the Lps Skip Frame Calibration is Done.
            </comment>
        </bits>
        <bits name="LPS_SF_PU_Reached" pos="31" access="r" rst="0">
            <comment>'1' when the Lps Skip Frame Power-up sequence frame is reached.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Frames" protect="rw">
        <bits name="LPS_SF_Frame" pos="FRAME_COUNT_NB_BITS-1:0" access="rw" rst="0">
            <comment>Number of frames to Skip.
                <br/>If the power up sequence is enabled, frames are skipped until both this number is reached and the powerup sequence has finished.
                <br/>Note: The power up sequence must be <b>Done</b> before the the frame LPS_SF_Frame ends.
            </comment>
        </bits>
        <bits name="LPS_SF_PU_Frame" pos="FRAME_COUNT_NB_BITS+15:16" access="rw" rst="0">
            <comment>Number of frames before activating the Power-up sequence.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Restart_Time" protect="rw">
        <bits name="LPS_SF_Restart_Time" pos="LP_COUNT_INT_NB_BITS-1:0" access="rw" rst="0">
            <comment>For LowPower SkipFrame mode: Value to restart TCU (and frame interrupt generation) on the system clock counter after a low power phase.
                <br/>For Calibration mode: number of 32k cycles for the calibration.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Frame_Period" protect="rw">
        <bits name="LPS_SF_Frame_Period" pos="LP_COUNT_INT_NB_BITS-1:0" access="rw" rst="0">
            <comment>Value of the frame period in system clock count.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Rate" protect="rw">
        <comment>The rate is the number of System Clocks per 32kHz Clocks.
        </comment>
        <bits name="LPS_SF_Rate_Int" pos="LP_RATE_NB_BITS-1:LP_FRAC_NB_BITS" access="rw" rst="0">
            <comment>Integer part of the rate.
            </comment>
        </bits>
        <bits name="LPS_SF_Rate_Frac" pos="LP_FRAC_NB_BITS-1:0" access="rw" rst="0">
            <comment>Fractional part of the rate.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Elapsed_Frames" protect="rw">
        <bits name="LPS_SF_Elapsed_Frames" pos="FRAME_COUNT_NB_BITS-1:0" access="r" rst="0">
            <comment>Current number of elapsed frames.
                <br/>Valid when Skip Frame is Enabled.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Sys_Count" protect="rw">
        <bits name="LPS_SF_Sys_Count" pos="SYS_COUNT_NB_BITS-1:0" access="r" rst="0">
            <comment>Value of the system clock counter at the end of calibration (when CalibrationDone is '1' in LPS_SF_Status register).
                <br/>The hardware behind it is reused during other operation, reading that register at any other time will return an undefined value.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_PU_Ctrl" protect="rw">
        <bits name="LPS_PU_Enable" pos="0" access="rw" rst="1">
            <comment>Enable the Power-Up Sequence.
                <br/>This bit is automatically cleared when the sequence is <b>Done</b>.
            </comment>
            <options>
                <option name="ENABLE"  value="1"/>
                <option name="DISABLE" value="0"/>
                <default/>
            </options>
        </bits>
        <bits name="LPS_PU_ForceStart" pos="4" access="rw" rst="1">
            <comment>When '1' forces the Power-up sequence to start.
                <br/>This bit is automatically cleared when the sequence is <b>Done</b>.
            </comment>
            <options>
                <option name="ENABLE"  value="1"/>
                <option name="DISABLE" value="0"/>
                <default/>
            </options>
        </bits>
        <bits name="LPS_PU_CO0_On" pos="8" access="rw" rst="0">
            <comment>This force the Controlled Output 0 (LPSCO[0]) to be Active (See polarity for actual line state).
            </comment>
        </bits>
        <bits name="LPS_PU_CO1_On" pos="9" access="rw" rst="0">
            <comment>This force the Controlled Output 1 (LPSCO[1]) to be Active (See polarity for actual line state).
            </comment>
        </bits>
        <bitgroup name="LPS_PU_CO_On">
            <entry ref="LPS_PU_CO0_On"/>
            <entry ref="LPS_PU_CO1_On"/>
        </bitgroup>
        <bits name="LPS_PU_CLK_RF_On" pos="10" access="rw" rst="0">
            <comment>This force the Clock RF control line (CLK_RF_26M_EN) to be on.
            </comment>
        </bits>
        <bits name="LPS_PU_SPI_On" pos="11" access="rw" rst="0">
            <comment>This force the SPI to be on.
            </comment>
        </bits>
        <bits name="LPS_PU_CO0_Pol" pos="12" access="rw" rst="0">
            <comment>This sets the Controlled Output 0 (LPSCO[0]) polarity.
                <br/>Set to '1' if the line is active low.
            </comment>
        </bits>
        <bits name="LPS_PU_CO1_Pol" pos="13" access="rw" rst="0">
            <comment>This sets the Controlled Output 1 (LPSCO[1]) polarity.
                <br/>Set to '1' if the line is active low.
            </comment>
        </bits>
        <bitgroup name="LPS_PU_CO_Pol">
            <entry ref="LPS_PU_CO0_Pol"/>
            <entry ref="LPS_PU_CO1_Pol"/>
        </bitgroup>
        <bits name="LPS_PU_CLK_RF_Pol" pos="14" access="rw" rst="0">
            <comment>This sets the Clock RF control line (CLK_RF_26M_EN) polarity.
                <br/>Set to '1' if the line is active low.
            </comment>
        </bits>
        <bits name="LPS_PU_SPI_Step" pos="18:16" access="rw" rst="2">
            <comment>This selects the step where the SPI is switched on during the power up sequence.
            </comment>
            <options>
                <option name="CO_S1" value="0"><comment>The SPI is switched on at state <b>Controlled Output step 1</b>.</comment></option>
                <option name="RFClkReady" value="1"><comment>The SPI is switched on at state <b>RF Clock Ready</b>.</comment></option>
                <option name="Ready" value="2"><comment>The Analog SPI is switched on at state <b>Ready</b>.</comment></option>
                <option name="Done" value="3"><comment>The Analog SPI is switched on at state <b>Done</b>.</comment></option>
            </options>
        </bits>
        <bits name="LPS_PU_Mask_CO0_S1" pos="20" access="rw" rst="0">
            <comment>This selects the action to take on Controlled Output 0 (LPSCO[0]) during the state <b>Controlled Output step 1</b>.
            </comment>
            <options>
                <option name="Enable" value="1"><comment>The Controlled Output 0 (LPSCO[0]) is switched on during the state <b>Controlled Output step 1</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The Controlled Output 0 (LPSCO[0]) is not changed during the state <b>Controlled Output step 1</b>.</comment></option>
            </options>
        </bits>
        <bits name="LPS_PU_Mask_CO1_S1" pos="21" access="rw" rst="0">
            <comment>This selects the action to take on Controlled Output 1 (LPSCO[1]) during the state <b>Controlled Output step 1</b>.
            </comment>
            <options>
                <option name="Enable" value="1"><comment>The Controlled Output 1 (LPSCO[1]) is switched on during the state <b>Controlled Output step 1</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The Controlled Output 1 (LPSCO[1]) is not changed during the state <b>Controlled Output step 1</b>.</comment></option>
            </options>
        </bits>
        <bitgroup name="LPS_PU_Mask_CO_S1">
            <entry ref="LPS_PU_Mask_CO0_S1"/>
            <entry ref="LPS_PU_Mask_CO1_S1"/>
        </bitgroup>
        <bits name="LPS_PU_Mask_CO0_S2" pos="22" access="rw" rst="0">
            <comment>This selects the action to take on Controlled Output 0 (LPSCO[0]) during the state <b>Controlled Output step 2</b>.
            </comment>
            <options>
                <option name="Enable" value="1"><comment>The Controlled Output 0 (LPSCO[0]) is switched on during the state <b>Controlled Output step 2</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The Controlled Output 0 (LPSCO[0]) is not changed during the state <b>Controlled Output step 2</b>.</comment></option>
            </options>
        </bits>
        <bits name="LPS_PU_Mask_CO1_S2" pos="23" access="rw" rst="0">
            <comment>This selects the action to take on Controlled Output 1 (LPSCO[1]) during the state <b>Controlled Output step 2</b>.
            </comment>
            <options>
                <option name="Enable" value="1"><comment>The Controlled Output 1 (LPSCO[1]) is switched on during the state <b>Controlled Output step 2</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The Controlled Output 1 (LPSCO[1]) is not changed during the state <b>Controlled Output step 2</b>.</comment></option>
            </options>
        </bits>
        <bitgroup name="LPS_PU_Mask_CO_S2">
            <entry ref="LPS_PU_Mask_CO0_S2"/>
            <entry ref="LPS_PU_Mask_CO1_S2"/>
        </bitgroup>
        
        <bits name="LPS_PU_Mask_CLK_RF" pos="24" access="rw" rst="1">
            <comment>Mask Start Clock RF: When set to '1' the Clock RF is not started during the power up sequence.
            </comment>
            <options>
                <option name="Enable" value="1"><comment>The Clock RF is started during the state <b>RF Clock Enable</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The Clock RF is not started.</comment></option>
            </options>
        </bits>

        <bits name="LPS_PU_Mask_St_PLL" pos="25" access="rw" rst="0">
            <comment>Mask Start Pll: When set to '1' the Pll is not started during the power up sequence.
            </comment>
            <options>
                <option name="Enable" value="1"><comment>The Pll is started during the state <b>RF Clock Ready</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The Pll is not started.</comment></option>
            </options>
        </bits>
        <bits name="LPS_PU_Mask_Sw_RF" pos="26" access="rw" rst="1">
            <comment>Mask Switch to RF clock: When set to '1' the slow clock is not switched to the RF clock during the power up sequence.
            </comment>
            <options>
                <option name="Switch" value="1"><comment>The System Clock is switched to Clock RF during the state <b>RF Clock Ready</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The System Clock is not switched.</comment></option>
            </options>
        </bits>
        <bits name="LPS_PU_Mask_Sw_Fast" pos="27" access="rw" rst="0">
            <comment>Mask Switch to Fast clock: When set to '1' the system clock is not switched to the Fast clock during the power up sequence.
            </comment>
            <options>
                <option name="Switch" value="1"><comment>The System Clock is switched to Clock Pll during the state <b>Pll Clock Ready</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The System Clock is not switched.</comment></option>
            </options>
        </bits>
        <bits name="LPS_PU_CPU_Done" pos="28" access="rw" rst="0">
            <comment>When set to '1' Ready step is done for the CPU.
                <br/>When both the CPU and the TCU are done, the state <b>Ready</b> ends and the state machine goes to state <b>Done</b>.
                <br/>This bit is automatically cleared when the sequence is <b>Done</b>.
            </comment>
        </bits>
        <bits name="LPS_PU_Run_TCU_WakeUp" pos="29" access="rw" rst="0">
            <comment>Run the TCU in WakeUp mode:
                <br/>In WakeUp mode, the TCU is started at time 0, process the TCU events until it reaches the Event WAKEUP_DONE.
                <br/>The WakeUp mode is started during the state <b>Ready</b>, the state <b>Ready</b> ends when both the CPU and the TCU are done.
                <br/>If the TCU is not started in WakeUp mode, it is considered Done for the <b>Ready</b> end.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_PU_Status" protect="rw">
        <bits name="LPS_PU_Done" pos="0" access="r" rst="0">
            <comment>The Power-Up Sequence is done (or idle).
            </comment>
        </bits>
        <bits name="LPS_PU_Ready" pos="4" access="r" rst="0">
            <comment>The Power-Up Sequence is in state <b>Ready</b>.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_PU_Times" protect="rw">
        <bits name="LPS_PU_tCO_S2" pos="4:0" access="rw" rst="0">
            <comment>Time in 32Khz clocks to wait between the states <b>Controlled Output step 1</b> and <b>Controlled Output step 2</b>.
            </comment>
        </bits>
        <bits name="LPS_PU_tCLK_RF_EN" pos="10:6" access="rw" rst="0">
            <comment>Time in 32Khz clocks to wait between the states <b>Controlled Output step 2</b> and <b>RF Clock Enable</b>.
            </comment>
        </bits>
        <bits name="LPS_PU_tCLK_RF" pos="23:12" access="rw" rst="all1">
            <comment>Time in 32Khz clocks to wait between the states <b>RF Clock Enable</b> and <b>RF Clock Ready</b>.
                <br/>This is the time to wait after VCO enable before switching to RF and starting the PLL.
            </comment>
        </bits>
        <bits name="LPS_PU_tCLK_PLL" pos="28:24" access="rw" rst="0">
            <comment>Time in 32Khz clocks to wait between the states <b>RF Clock Ready</b> and <b>Pll Clock Ready</b>.
                <br/>This is the time to wait after starting the PLL before switching to the Fast clock or checking if the PLL is locked.
            </comment>
        </bits>
        <bits name="LPS_PU_PLL_Lock" pos="31" access="rw" rst="0">
            <comment>If set waits for the lock status of the PLL after the LPS_PU_PLL time is elapsed before switching to the Fast Clock (in Fast step), else switch immediately after the expiration of the time.
            </comment>
            <options>
                <option name="Bypass" value="0"><comment>After expiration of the time LPS_PU_tClk_PLL go directly to the state <b>Pll Clock Ready</b>.</comment></option>
                <option name="Check" value="1"><comment>After expiration of the time LPS_PU_tClk_PLL, wait for the PLL to be locked before going to the state <b>Pll Clock Ready</b>.</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="LPS_PU_IRQ" protect="rw">
        <bits name="LPS_IRQ_Calibration_Done_Cause" pos="0" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the calibration is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_Slow_Running_Cause" pos="1" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the Slow Counter started.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Done_Cause" pos="2" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the Power-Up sequence is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Ready_Cause" pos="3" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the Power-Up sequence reached the state <b>Ready</b>.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Reached_Cause" pos="4" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the Power-Up frame was reached.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name="LPS_PU_IRQ_Cause">
            <entry ref="LPS_IRQ_Calibration_Done_Cause"/>
            <entry ref="LPS_IRQ_Slow_Running_Cause"/>
            <entry ref="LPS_IRQ_PU_Done_Cause"/>
            <entry ref="LPS_IRQ_PU_Ready_Cause"/>
            <entry ref="LPS_IRQ_PU_Reached_Cause"/>
        </bitgroup>

        <bits name="LPS_IRQ_Calibration_Done_Status" pos="16" access="rc" rst="0">
            <comment>1 when the calibration is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_Slow_Running_Status" pos="17" access="rc" rst="0">
            <comment>1 when the Slow Counter started.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Done_Status" pos="18" access="rc" rst="0">
            <comment>1 when the Power-Up sequence is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Ready_Status" pos="19" access="rc" rst="0">
            <comment>1 when the Power-Up sequence reached the state <b>Ready</b>.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Reached_Status" pos="20" access="rc" rst="0">
            <comment>1 when the Power-Up frame was reached.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name="LPS_PU_IRQ_Status">
            <entry ref="LPS_IRQ_Calibration_Done_Status"/>
            <entry ref="LPS_IRQ_Slow_Running_Status"/>
            <entry ref="LPS_IRQ_PU_Done_Status"/>
            <entry ref="LPS_IRQ_PU_Ready_Status"/>
            <entry ref="LPS_IRQ_PU_Reached_Status"/>
        </bitgroup>
    </reg>
    <reg name="LPS_PU_IRQ_Mask" protect="rw">
        <bits name="LPS_IRQ_Calibration_Done_Mask" pos="0" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_Calibration_Done is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_Slow_Running_Mask" pos="1" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_Slow_Running is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Done_Mask" pos="2" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_PU_Done is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Ready_Mask" pos="3" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_PU_Ready is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Reached_Mask" pos="4" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_PU_Reached is enabled.
            </comment>
        </bits>
        <bitgroup name="LPS_PU_IRQ_Mask">
            <entry ref="LPS_IRQ_Calibration_Done_Mask"/>
            <entry ref="LPS_IRQ_Slow_Running_Mask"/>
            <entry ref="LPS_IRQ_PU_Done_Mask"/>
            <entry ref="LPS_IRQ_PU_Ready_Mask"/>
            <entry ref="LPS_IRQ_PU_Reached_Mask"/>
        </bitgroup>
    </reg>
    <reg name="RX_GAIN_INTERVAL" protect="rw">
        <bits name="RX_GAIN_interval" pos="9:0" access="rw" rst="1001110000">
            <comment>New RX gain active period from TCU_EVENT(TCO_RX_DEC_ON) = 625 Qbit.
            </comment>
        </bits>
        <bits name="RX_GAIN_offset" pos="16:10" access="rw" rst="0">
            <comment>RX gain active time offset, -127 Qbit to 0 Qbit.
            </comment>
        </bits>
        <bits name="SW_Off_Time" pos="19:17" access="rw" rst="2">
            <comment>Guard time for next Switch ON, 0 Qbit to 7 Qbit.
            </comment>
        </bits>
        <bits name="RX_GAIN_delay" pos="26:20" access="rw" rst="0">
            <comment>Delay time from TCU_DEC_ON to I/Q sample, 0 Qbit to 127 Qbit.
            </comment>
        </bits>
    </reg>
    <hole size="1280"/>
    <reg name="Event" protect="rw" count="NB_TCU_PROG_EVENTS">
        <bits name="Event_Time" pos="13:0" access="rw" rst="all1">
            <comment>The event Id will be executed when the TCU counter reaches the value programmed in Event time field of this register.
            </comment>
        </bits>
        <bits name="Event_Id" pos="21:16" access="rw" rst="all1">
            <comment>Event to be executed when the TCU counter reaches the programmed event time.
                <br/>
            </comment>
            <options linkenum="TCU_Event">
                <default />
            </options>
        </bits>
    </reg>

</module>

</archive>
<archive relative = "timer.xml">

<module name="timer" category="System">
    <var name = "NB_INTERVAL" value="1"/>
    <var name = "INT_TIMER_NB_BITS" value="24"/>
    <var name = "WD_TIMER_NB_BITS" value="24"/>
    <var name = "HW_TIMER_NB_BITS" value="32"/>
    <var name = "TIM_MAXVAL" value="0xffffff"/>

    <reg name="OSTimer_Ctrl" protect="rw">
        <bits name="LoadVal" pos="23:0" access="rw" rst="0">
            <comment>Value loaded to OS timer.
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="Enable" pos="24" access="rw" rst="0">
            <comment>Write '1' to this bit will enable OS timer.
                <br/>When read, the value is what we have written to this bit, it changes immediately  after been written.
            </comment>
        </bits>
        <bits name="Enabled" pos="25" access="r" rst="0">
            <comment>Read this bit will get the information if OS timer is really enabled or not. This bit will change only after the next front of 16 KHz system clock.
                <br/>
                <br/>'1' indicates OS timer enabled.
                <br/>'0' indicates OS timer not enabled.
            </comment>
        </bits>
        <bits name="Cleared" pos="26" access="r" rst="0">
            <comment>Read this bit will get the information if OS timer interruption clear operation is finished or not.
                <br/>
                <br/>'1' indicates OS timer interruption clear operation is on going.
                <br/>'0' indicates no OS timer interruption clear operation is on going.
            </comment>
        </bits>
        <bits name="Repeat" pos="28" access="rw" rst="0">
            <comment>Write '1' to this bit will set OS timer to repeat mode.
                <br/>When read, get the information if OS timer is in repeat mode.
                <br/>
                <br/>'1' indicates OS timer in repeat mode.
                <br/>'0' indicates OS timer not in repeat mode.
            </comment>
        </bits>
        <bits name="Wrap" pos="29" access="rw" rst="0">
            <comment>Write '1' to this bit will set OS timer to wrap mode.
                <br/>When read, get the information if OS timer is in wrap mode.
                <br/>
                <br/>'1' indicates OS timer in wrap mode.
                <br/>'0' indicates OS timer not in wrap mode.
            </comment>
        </bits>
        <bits name="Load" pos="30" access="rw" rst="0">
            <comment>Write '1' to this bit will load the initial value to OS timer.
            </comment>
        </bits>
    </reg>
    <reg name="OSTimer_CurVal" protect="rw">
        <bits name="CurVal" pos="31:0" access="r" rst="-">
            <comment>Current value of OS timer. The value is 24 bits and the first 8 bits are sign extension of the most important bit. A negative value indicates that the timer has wraped.
            </comment>
        </bits>
    </reg>
    <reg name="WDTimer_Ctrl" protect="rw">
        <bits name="Start" pos="0" access="s" rst="0">
            <comment>Write '1' to this bit will enable watchdog timer and Load it with WDTimer_LoadVal.
            </comment>
        </bits>
        <bits name="Stop" pos="4" access="c" rst="0">
            <comment>Write '1' to this bit will stop watchdog timer.
            </comment>
        </bits>
        <bits name="ReLoad" pos="16" access="w" rst="0">
            <comment>Write '1' to this bit will load WDTimer_LoadVal value to watchdog timer.
                <br/>Use this bit to implement the watchog keep alive.
            </comment>
        </bits>

        <bits name="WDEnabled" pos="3" access="r" rst="0">
            <comment>Read this bit will get the information if watchdog timer is really enabled or not. This bit will change only after the next front of 32 KHz system clock.
                <br/>
                <br/>'1' indicates watchdog timer is enabled, if current watchdog timer value reaches 0, the system will be reseted.
                <br/>'0' indicates watchdog timer is not enabled.
            </comment>
        </bits>
    </reg>
    <reg name="WDTimer_LoadVal" protect="rw">
        <bits name="LoadVal" pos="WD_TIMER_NB_BITS-1:0" access="rw" rst="-">
            <comment>Load value of watchdog timer. Number of 32kHz Clock before Reset.
                <br/>
            </comment>
        </bits>
    </reg>
    <reg name="HWTimer_Ctrl" protect="rw">
        <bits name="Interval_En" pos="8" access="rw" rst="0">
            <comment>This bit enables interval IRQ mode.
                <br/>
                <br/>'0': hw delay timer does not generate interval IRQ.
                <br/>'1': hw delay timer generate an IRQ each interval.
            </comment>
        </bits>
        <bits name="Interval" pos="1:0" access="rw" rst="00">
            <comment> interval of generating an HwTimer IRQ. 
                <br/>
                <br/>"00": interval of 1/8 second.
                <br/>"01": interval of 1/4 second.
                <br/>"10": interval of 1/2 second.
                <br/>"11": interval of 1 second.
            </comment>
        </bits>
    </reg>
    <reg name="HWTimer_CurVal" protect="rw">
        <bits name="CurVal" pos="31:0" access="r" rst="0">
            <comment>Current value of the hardware delay timer. The value is incremented every 61 us. This timer is running all the time and wrap at value 0xFFFFFFFF.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Mask_Set" protect="rw">
        <bits name="OSTimer_Mask" pos="0" access="rs" rst="0">
            <comment>Set mask for OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Mask" pos="1" access="rs" rst="0">
            <comment>Set mask for hardwre delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Mask" pos="2" access="rs" rst="0">
            <comment>Set mask for hardwre delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Mask_Clr" protect="rw">
        <bits name="OSTimer_Mask" pos="0" access="rc" rst="0">
            <comment>Clear mask for OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Mask" pos="1" access="rc" rst="0">
            <comment>Clear mask for hardwre delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Mask" pos="2" access="rc" rst="0">
            <comment>Clear mask for hardwre delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Clr" protect="rw">
        <bits name="OSTimer_Clr" pos="0" access="c" rst="0">
            <comment>Clear OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Clr" pos="1" access="c" rst="0">
            <comment>Clear hardware delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Clr" pos="2" access="c" rst="0">
            <comment>Clear hardware delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Cause" protect="rw">
        <bits name="OSTimer_Cause" pos="0" access="r" rst="0">
            <comment>OS timer IRQ cause.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Cause" pos="1" access="r" rst="0">
            <comment>hardware delay timer wrap IRQ cause.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Cause" pos="2" access="r" rst="0">
            <comment>hardware delay timer interval IRQ cause.
            </comment>
        </bits>
        <bits name="OSTimer_Status" pos="16" access="r" rst="0">
            <comment>OS timer IRQ status.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Status" pos="17" access="r" rst="0">
            <comment>hardware delay timer wrap IRQ status.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Status" pos="18" access="r" rst="0">
            <comment>hardware delay timer interval IRQ status.
            </comment>
        </bits>
        <bitgroup name="Other_Tims_irq">
            <entry ref="HWTimer_Wrap_Cause"/>
            <entry ref="HWTimer_Itv_Cause"/>
        </bitgroup>
    </reg>
</module>

</archive>

<archive relative = "uart.xml">
<module name="uart" category="Periph">
  <var  name="UART_RX_FIFO_SIZE"    value="32"  />
  <var  name="UART_TX_FIFO_SIZE"    value="16"  />
  <var  name="NB_RX_FIFO_BITS"      value="5"   />
  <var  name="NB_TX_FIFO_BITS"      value="4"   />

  
  <reg protect="rw" name="ctrl">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Allows to turn off the UART:<br />0 = Disable<br />1 = Enable
      </comment>
    </bits>

    <bits access="rw" name="Data Bits" pos="1" rst="0">
      <options>
        <option name="7_BITS" value="0" />

        <option name="8_BITS" value="1" />

        <default />
      </options>

      <comment>Number of data bits per character (least significant bit
      first):<br />0 = 7 bits<br />1 = 8 bits </comment>
    </bits>

    <bits access="rw" name="Tx Stop Bits" pos="2" rst="0">
      <options>
        <option name="1_BIT" value="0" />

        <option name="2_BITS" value="1" />

        <default />
      </options>

      <comment>Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).<br />0 = one stop bit is
      transmitted in the serial data.<br />1 = two stop bits are generated and
      transmitted in the serial data out. </comment>
    </bits>

    <bits access="rw" name="Parity Enable" pos="3" rst="0">
      <options>
        <option name="NO" value="0" />

        <option name="YES" value="1" />

        <default />
      </options>

      <comment> Parity is enabled when this bit is set. </comment>
    </bits>

    <bits access="rw" name="Parity Select" pos="5:4" rst="0">
      <options>
        <option name="ODD" value="0" />

        <option name="EVEN" value="1" />

        <option name="SPACE" value="2" />

        <option name="MARK" value="3" />

        <default />
      </options>

      <comment> Controls the parity format when parity is enabled:<br />00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).<br />01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).<br />10 = a space is
      generated and received as parity bit.<br />11 = a mark is generated and
      received as parity bit. </comment>
    </bits>

    <bits access="rw" name="auto_enable" pos="8" rst="0">
      <comment> Controls whether enable or disable auto baud rate function. <br />0 = disable auto baud rate function 
      <br />1 = enable auto baud rate function </comment>
    </bits>

    <bits access="rw" name="sync_char_sel" pos="11" rst="0">
      <comment> Controls auto baud rate char is AT or at . <br />0 = char is AT 
      <br />1 = char is at </comment>
    </bits>

    <bits access="rw" name="Divisor Mode" pos="20" rst="0">
      <comment>Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.<br />0 =
      (BCLK = SCLK / 4)<br />1 = (BCLK = SCLK / 16) </comment>
    </bits>

    <bits access="rw" name="IrDA Enable" pos="21" rst="0">
      <comment>When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details). </comment>
    </bits>

    <bits access="rw" name="DMA Mode" pos="22" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC. </comment>
    </bits>
    
    <bits access="rw" name="Auto Flow Control" pos="23" rst="0">
      <options>
        <option name="ENABLE" value="1" />
        
        <option name="DISABLE" value="0" />
        
        <default />
      </options>
      <comment>Enables the auto flow control. Uart_RTS is controlled by the Rx
      RTS bit and the UART Auto Control Flow System. If Uart_CTS
      become inactive high, the Tx data flow is stopped. </comment>
    </bits>

    <bits access="rw" name="Loop Back Mode" pos="24" rst="0">
      <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support). </comment>
    </bits>

    <bits access="rw" name="Rx Lock Err" pos="25" rst="0">
      <comment>Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept. </comment>
    </bits>

    <bits access="rw" name="Rx Break Length" pos="31:28" rst="0xF">
      <comment>Length of a break, in number of bits. </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Rx Fifo Level" pos="NB_RX_FIFO_BITS:0" rst="0">
       <options>
            <mask/>
            <shift/>
        </options>
        <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read. </comment>
    </bits>

    <bits access="r" name="character_miscompare" pos="6" rst="0">
      <comment> character miscompare flag
            <br/> '0' = AT or at compare failed. 
            <br/> '1' = AT or at compare successfully. 
            When auto_enable is 0,this bit is cleared to 0.
       </comment>
    </bits>

    <bits access="r" name="auto_baud_locked" pos="7" rst="0">
      <comment> auto baud locked flag
            <br/> '0' = baud rate is detected failed. 
            <br/> '1' = baud rate is detected successfully. 
            When auto_enable is 0,this bit is cleared to 0.
       </comment>
    </bits>

    <bits access="r" name="Tx Fifo space" pos="NB_TX_FIFO_BITS+8:8" rst="5'h10">
        <options>
            <mask/>
            <shift/>
        </options>
        <comment>Those bits indicate the number of space available in the Tx
      Fifo. </comment>
    </bits>

    <bits access="r" name="Tx Active" pos="14" rst="0">
      <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface. </comment>
    </bits>

    <bits access="r" name="Rx Active" pos="15" rst="0">
      <comment>This bit indicates that the UART is receiving a byte.
      </comment>
    </bits>

    <bits access="r" name="Rx Overflow Err" pos="16" rst="0">
      <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Tx Overflow Err" pos="17" rst="0">
      <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when 
          the UART_STATUS register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Parity Err" pos="18" rst="0">
      <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Framing Err" pos="19" rst="0">
      <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Break Int" pos="20" rst="0">
      <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value. </comment>
    </bits>

    <bits access="r" name="DCTS" pos="24" rst="1">
      <comment>This bit is set when the Uart_CTS line changed since the last
      time this register has been written. This bit is cleared when the
      UART_STATUS register is written with any value. </comment>
    </bits>

    <bits access="r" name="CTS" pos="25" rst="0">
        <comment>current value of the Uart_CTS line. 
            <br/> '1' = Tx not allowed. 
            <br/> '0' = Tx allowed. 
      </comment>
    </bits>

    <bits access="r" name="DTR" pos="28" rst="0">
      <comment>Current value of the DTR line.
      </comment>
    </bits>
    
    <bits access="r" name="Clk Enabled" pos="31" rst="0">
      <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      RTS too early.</comment>
    </bits>
  </reg>

  <reg protect="--" name="rxtx_buffer">
    <bits access="r" name="Rx Data" pos="7:0" rst="no">
      <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur. </comment>
    </bits>

    <bits access="w" name="Tx Data" pos="7:0" rst="no">
      <comment>The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="irq_mask">
    <bits access="rw" name="Tx Modem Status" pos="0" rst="0">
      <comment>Clear to send signal change detected. </comment>
    </bits>

    <bits access="rw" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. </comment>
    </bits>

    <bits access="rw" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>Pulse detected on Uart_Dma_Tx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>Pulse detected on Uart_Dma_Rx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters
            in or out of the Rx Fifo during the last 4 character times.
        </comment>
    </bits>

    <bits access="rw" name="DTR RISE" pos="8" rst="0">
      <comment>Rising edge detected on the UART_DTR signal. 
      </comment>
    </bits>

    <bits access="rw" name="DTR FALL" pos="9" rst="0">
      <comment>Falling edge detected on the UART_DTR signal. 
      </comment>
    </bits>
  
  </reg>

  <reg protect="rw" name="irq_cause">
    <bits access="r" name="Tx Modem Status" pos="0" rst="0">
      <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level. </comment>
    </bits>

    <bits access="r" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.
      </comment>
    </bits>

    <bits access="r" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.
            Reset control: Write one in this register.
        </comment>    
    </bits>

    <bits access="rw" name="DTR RISE" pos="8" rst="0">
      <comment>This interrupt is generated when a rising edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="DTR FALL" pos="9" rst="0">
      <comment>This interrupt is generated when a falling edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.
      </comment>
    </bits>
    
    <bits access="r" name="Tx Modem Status U" pos="16" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Data Available U" pos="17" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed U" pos="18" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Timeout U" pos="19" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Line Err U" pos="20" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Dma Done U" pos="21" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Done U" pos="22" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Timeout U" pos="23" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="DTR RISE U" pos="24" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="DTR FALL U" pos="25" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
  </reg>

  <reg protect="rw" name="triggers">
    <bits access="rw" name="Rx Trigger" pos="NB_RX_FIFO_BITS-1:0" rst="0">
      <comment>Defines the empty threshold level at which the Data Available
      Interrupt will be generated. <br />The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.</comment>
    </bits>

    <bits access="rw" name="Tx Trigger" pos="NB_TX_FIFO_BITS-1+8:8" rst="0">
      <comment>Defines the empty threshold level at which the Data Needed
      Interrupt will be generated.<br />The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.</comment>
    </bits>

    <bits access="rw" name="AFC Level" pos="NB_RX_FIFO_BITS-1+16:16" rst="0">
      <comment>Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).<br />The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="CMD_Set">
    <bits access="rs" name="RI" pos="0" rst="0">
        <comment>Ring indicator. When write '1', set RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>
    
    <bits access="rs" name="DCD" pos="1" rst="0">
        <comment>Data carrier detect. When write '1', set DCD bit. When read, get DCD
            bit value.
        </comment>
    </bits>
    
    <bits access="rs" name="DSR" pos="2" rst="0">
        <comment>Data set ready. When write '1', set RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>
    
    <bits access="rs" name="Tx Break Control" pos="3" rst="0">
      <comment> Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared. </comment>
    </bits>
    
    <bits access="rs" name="Tx Finish n Wait" pos="4" rst="0">
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>  

    <bits access="rs" name="RTS" pos="5" rst="0">
        <comment>Controls the Uart_RTS output.
            <br />0 = the Uart_RTS will be inactive high (Rx not allowed).
            <br />1 = the Uart_RTS will be active low (Rx allowed).
        </comment>
    </bits>
    
    <bits access="r" name="Rx Fifo Reset" pos="6" rst="0">
      <comment> Writing a 1 to this bit resets and flushes the Receive Fifo.
      This bit does not need to be cleared. </comment>
    </bits>
    
    <bits access="r" name="Tx Fifo Reset" pos="7" rst="0">
      <comment> Writing a 1 to this bit resets and flushes the Transmit Fifo.
      This bit does not need to be cleared. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="CMD_Clr">
    <bits access="rc" name="RI" pos="0" rst="0">
        <comment>Ring indicator. When write '1', clear RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>

    <bits access="rc" name="DCD" pos="1" rst="0">
        <comment>Data carrier detect. When write '1', clear DCD bit. When read, get DCD
            bit value.
        </comment>
    </bits>

    <bits access="rc" name="DSR" pos="2" rst="0">
        <comment>Data set ready. When write '1', clear RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>

    <bits access="rc" name="Tx Break Control" pos="3" rst="0">
      <comment> Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared. </comment>
    </bits>
    
    <bits access="rc" name="Tx Finish n Wait" pos="4" rst="0">
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>  

    <bits access="rc" name="RTS" pos="5" rst="0">
        <comment>Controls the Uart_RTS output.
            <br />0 = the Uart_RTS will be inactive high.
            <br />1 = the Uart_RTS will be active low.
        </comment>
    </bits>
    
  </reg>
  
</module>


</archive>

<archive relative = "usbc.xml">
<var name="SPFIFORAM_SIZE" value="264"/>
<module name="usbc" category="Periph">
    <var name="DIEP_NUM" value="3"/>
    <var name="DOEP_NUM" value="2"/>
    
    <reg name="GOTGCTL" protect="rw">
        <bits name="SesReqScs" pos="0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SesReq" pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HstNegScs" pos="8" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HNPReq" pos="9" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HstSetHNPEn" pos="10" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DevHNPEn" pos="11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ConlDSts" pos="16" access="r" rst="1">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DbncTime" pos="17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ASesVld" pos="18" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="BSesVld" pos="19" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GOTGINT" protect="rw">
        <bits name="SesEndDet" pos="2" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SesReqSucStsChng" pos="8" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HstNegSucStsChng" pos="9" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HstNegDet" pos="17" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ADevTOUTChg" pos="18" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DbnceDone" pos="19" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        
    </reg>
    <reg name="GAHBCFG" protect="rw">
        <bits name="GlblIntrMsk" pos="0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HBstLen" pos="4:1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DMAEn" pos="5" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NPTxFEmpLvl" pos="7" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PTxFEmpLvl" pos="8" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GUSBCFG" protect="rw">
        <bits name="TOutCal" pos="2:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PHYIf" pos="3" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ULPI_UTMI_Sel" pos="4" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FSIntf" pos="5" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PHYSel" pos="6" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>        
        <bits name="DDRSel" pos="7" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>         
        <bits name="SRPCap" pos="8" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>         
        <bits name="HNPCap" pos="9" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>       
        <bits name="USBTrdTim" pos="13:10" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>            
        <bits name="PhyPwrClkSel" pos="15" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>       
        <bits name="OtgI2CSel" pos="16" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ULPIFsLs" pos="17" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ULPIAutoRes" pos="18" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ULPIClkSusM" pos="19" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ULPIExtVbusDrv" pos="20" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ULPIExtVbusIndicator" pos="21" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="TermSelDLPulse" pos="22" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ForceHstMode" pos="29" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ForceDevMode" pos="30" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="CorruptTxPacket" pos="31" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
    </reg>
    <reg name="GRSTCTL" protect="rw">
        <bits name="CSftRst" pos="0" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HSftRst" pos="1" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FrmCntrRst" pos="2" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknQFlsh" pos="3" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RxFFlsh" pos="4" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxFFlsh" pos="5" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxFNum" pos="10:6" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DMAReq" pos="30" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBIdle" pos="31" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GINTSTS" protect="rw">
        <bits name="CurMod" pos="0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ModeMis" pos="1" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OTGInt" pos="2" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Sof" pos="3" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RxFLvl" pos="4" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NPTxFEmp" pos="5" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GINNakEff" pos="6" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GOUTNakEff" pos="7" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ULPICKINT" pos="8" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="I2CINT" pos="9" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ErlySusP" pos="10" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBSusp" pos="11" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBRst" pos="12" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EnumDone" pos="13" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ISOOutDrop" pos="14" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EOPF" pos="15" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPMis" pos="17" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="IEPInt" pos="18" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OEPInt" pos="19" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="incomplSOIN" pos="20" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="incompIP" pos="21" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FetSusp" pos="22" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PrtInt" pos="24" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HChInt" pos="25" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PTxFEmp" pos="26" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ConlDStsChng" pos="28" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DisconnInt" pos="29" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SessReqInt" pos="30" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="WkUpInt" pos="31" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        
    </reg>
    <reg name="GINTMSK" protect="rw">
        <bits name="ModeMis" pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OTGInt" pos="2" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Sof" pos="3" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RxFLvl" pos="4" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NPTxFEmp" pos="5" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GINNakEff" pos="6" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GOUTNakEff" pos="7" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ULPICKINT" pos="8" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="I2CINT" pos="9" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ErlySusP" pos="10" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBSusp" pos="11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBRst" pos="12" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EnumDone" pos="13" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ISOOutDrop" pos="14" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EOPF" pos="15" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPMis" pos="17" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="IEPInt" pos="18" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OEPInt" pos="19" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="incomplSOIN" pos="20" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="incompIP" pos="21" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FetSusp" pos="22" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PrtInt" pos="24" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HChInt" pos="25" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PTxFEmp" pos="26" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ConlDStsChng" pos="28" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DisconnInt" pos="29" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SessReqInt" pos="30" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="WkUpInt" pos="31" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GRXSTSR" protect="r">
        <bits name="EPNum"  pos="3:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="BCnt"  pos="14:4" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DPID"  pos="16:15" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PktSts"  pos="20:17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FN"  pos="24:21" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GRXSTSP" protect="">
        <bits name="EPNum"  pos="3:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="BCnt"  pos="14:4" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DPID"  pos="16:15" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PktSts"  pos="20:17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FN"  pos="24:21" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GRXFSIZ" protect="rw">
        <bits name="RxFDep"  pos="15:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GNPTXFSIZ" protect="rw">
        <bits name="NPTxFStAddr"  pos="15:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NPTxFDeps"  pos="31:16" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GNPTXSTS" protect="r">
        <bits name="NPTxFSpcAvail"  pos="15:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NPTxQSpcAvail"  pos="23:16" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NPTxQTop"  pos="30:24" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GI2CCTL" protect="">
    </reg>
    <reg name="GPVNDCTL" protect="">
    </reg>
    <reg name="GGPIO" protect="">
    </reg>
    <reg name="GUID" protect="rw">
        <bits name="UserID"  pos="31:0" access="rw" rst="0xc0010000" display="hex">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GSNPSID" protect="r">
        <bits name="SynopsysID"  pos="31:0" access="r" rst="0x4f54" display="hex">
            <comment>Enable the template module
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GHWCFG1" protect="r">
        <bits name="epdir" pos="31:0" access="r" rst="0">
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GHWCFG2" protect="r">
        <bits name="OtgMode" pos="2:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OtgArch" pos="4:3" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SingPnt" pos="5" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HSPhyType" pos="7:6" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FSPhyType" pos="9:8" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NumDevEps" pos="13:10" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NumHstChnl" pos="17:14" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PerioSupport" pos="18" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DynFifoSizing" pos="19" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>        
        <bits name="NPTxQDepth" pos="23:22" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PTxQDepth" pos="25:24" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TknQDepth" pos="30:26" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GHWCFG3" protect="r">
        <bits name="XferSizeWidth" pos="3:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PktSizeWidth" pos="6:4" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OtgEn" pos="7" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="I2CIntSel" pos="8" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="VndctlSupt" pos="9" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OptFeature" pos="10" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RstType" pos="11" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DfifoDepth" pos="31:16" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GHWCFG4" protect="r">
        <bits name="NumDevPerioEps" pos="3:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EnablePwrOpt" pos="4" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AhbFreq" pos="5" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PhyDataWidth" pos="15:14" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NumCtlEps" pos="19:16" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="iddigFltr"  pos="20" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="VBusValidFltr"  pos="21" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AValidFltr"  pos="22" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="BValidFltr"  pos="23" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SessEndFltr"  pos="24" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DeFifoMode"  pos="25" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEps"  pos="29:26" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="1376" align = "0x100"/>
    <reg name="HPTXFSIZ" protect="">
    </reg>
    <struct count="DIEP_NUM" name="DIEPTXF">
    <reg name="DIEnPTXF" protect="rw">
        <bits name="IENPnTxFStAddr"  pos="15:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEPnTxFDep"  pos="31:16" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    </struct>
    <hole size="14208" align = "0x800"/>
    <reg name="DCFG" protect="rw">
        <bits name="DevSpd"  pos="1:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NZStsOUTHShk"  pos="2" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DevAddr"  pos="10:4" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PerFrInt"  pos="12:11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPMisCnt"  pos="22:18" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DCTL" protect="rw">
        <bits name="RmtWkUpSig" pos="0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SftDiscon" pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GNPINNakSts" pos="2" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GOUTNakSts" pos="3" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TstCtl" pos="6:4" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SGNPInNak" pos="7" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="CGNPInNak" pos="8" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SGOUTNak" pos="9" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="CGOUTNak" pos="10" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PWROnPrgDone" pos="11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        
    </reg>
    <reg name="DSTS" protect="r">
        <bits name="SuspSts"  pos="0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EnumSpd"  pos="2:1" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ErrticErr"  pos="3" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SOFFN"  pos="21:8" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32"/>
    <reg name="DIEPMSK" protect="rw">
        <bits name="XferComplMsk" pos="0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDisbldMsk" pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBErrMsk" pos="2" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TimeOUTMsk" pos="3" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknTXFEmpMsk" pos="4" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknEPMisMsk" pos="5" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEPNakEffMsk" pos="6" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxfifoUndrnMsk" pos="8" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DOEPMSK" protect="rw">
        <bits name="XferComplMsk" pos="0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDisbldMsk" pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBErrMsk" pos="2" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SetUPMk" pos="3" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OUTTknEPdisMsk" pos="4" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Back2BackSETup" pos="6" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OutPktErrMsk" pos="8" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>        
    </reg>
    <reg name="DAINT" protect="r">
        <bits name="InEpInt"  pos="15:0" access="r" rst="0">
            <comment>Enable the template module
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OutEpInt"  pos="31:16" access="r" rst="0">
            <comment>Enable the template module
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DAINTMSK" protect="rw">
        <bits name="InEpMsk"  pos="15:0" access="rw" rst="0">
            <comment>Enable the template module
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OutEpMsk"  pos="31:16" access="rw" rst="0">
            <comment>Enable the template module
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DTKNQR1" protect="">
    </reg>
    <reg name="DTKNQR2" protect="">
    </reg>
    <reg name="DVBUSDIS" protect="rw">
        <bits name="DVBUSDis"  pos="15:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DVBUSPULSE" protect="rw">
        <bits name="DVBUSPulse"  pos="11:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DTHRCTL" protect="rw">
        <bits name="NonISOThrEn" pos="0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ISOThrEn" pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxThrLen" pos="10:2" access="rw" rst="8">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RxThrEn" pos="16" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RxThrLen" pos="25:17" access="rw" rst="8">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ArbPrkEn" pos="27" access="rw" rst="1">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DIEPEMPMSK" protect="rw">
        <bits name="InEpTxfEmpMsk"  pos="15:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>    
   
    <hole size="1600" align = "0x900"/>
    <reg name="DIEPCTL0" protect="rw">
        <bits name="EP0_MPS" pos="1:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NextEp" pos="14:11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBActEP" pos="15" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NAKSts" pos="17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPType" pos="19:18" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Stall" pos="21" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPTxFNum" pos="25:22" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="CNAK" pos="26" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SNAK" pos="27" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDis" pos="30" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPEna" pos="31" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DIEPINT0" protect="rw">
        <bits name="XferCompl"  pos="0" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDisbld"  pos="1" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBErr"  pos="2" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TimeOut"  pos="3" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknTXFEmp"  pos="4" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknEPMis"  pos="5" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEPNakEff"  pos="6" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxFEmp"  pos="7" access="r" rst="1">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxfifoUndrn"  pos="8" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DIEPTSIZ0" protect="rw">
        <bits name="IEPXferSize0"  pos="6:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="IEPPktCnt0"  pos="20:19" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DIEPDMA0" protect="rw">
        <bits name="DMAAddr"  pos="31:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DIEPFSTS0" protect="rw">
        <bits name="INEPTxFSpcAvail"  pos="15:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    
    <hole size="32" />
    <struct count="DIEP_NUM" name="DIEPnCONFIG">
    <reg name="DIEPCTL" protect="rw">
        <bits name="EPn_MPS" pos="10:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NextEp" pos="14:11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBActEP" pos="15" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="IEP_DPID" pos="16" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NAKSts" pos="17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPType" pos="19:18" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Snp" pos="20" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Stall" pos="21" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPTxFNum" pos="25:22" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="CNAK" pos="26" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SNAK" pos="27" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SetD0PID" pos="28" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SetD1PID" pos="29" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDis" pos="30" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPEna" pos="31" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DIEPINT" protect="rw">
        <bits name="XferCompl"  pos="0" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDisbld"  pos="1" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBErr"  pos="2" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TimeOut"  pos="3" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknTXFEmp"  pos="4" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknEPMis"  pos="5" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEPNakEff"  pos="6" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxFEmp"  pos="7" access="r" rst="1">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxfifoUndrn"  pos="8" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DIEPTSIZ" protect="rw">
        <bits name="IEPXferSize"  pos="18:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="IEPPktCnt"  pos="28:19" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="MC"  pos="30:29" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

    </reg>
    <reg name="DIEPDMA" protect="rw">
        <bits name="DMAAddr"  pos="31:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DIEPFSTS" protect="rw">
        <bits name="INEPTxFSpcAvail"  pos="15:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    </struct>

    <hole size="3072" align = "0xb00"/>
    <reg name="DOEPCTL0" protect="rw">
        <bits name="EP0_MPS" pos="1:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBActEP" pos="15" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NAKSts" pos="17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPType" pos="19:18" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Snp" pos="20" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Stall" pos="21" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="CNAK" pos="26" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SNAK" pos="27" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDis" pos="30" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPEna" pos="31" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>        
    </reg>
    <hole size="32" />
    <reg name="DOEPINT0" protect="rw">
        <bits name="XferCompl"  pos="0" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDisbld"  pos="1" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBErr"  pos="2" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Setup"  pos="3" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknTXFEmp"  pos="4" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknEPMis"  pos="5" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEPNakEff"  pos="6" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxFEmp"  pos="7" access="r" rst="1">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxfifoUndrn"  pos="8" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DOEPTSIZ0" protect="rw">
        <bits name="OEPXferSize0"  pos="6:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OEPPktCnt0"  pos="19" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SUPCnt"  pos="30:29" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DOEPDMA0" protect="rw">
        <bits name="DMAAddr"  pos="31:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    
    <hole size="64" />
    <struct count="DOEP_NUM" name="DOEPnCONFIG">
    <reg name="DOEPCTL" protect="rw">
        <bits name="EPn_MPS" pos="10:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NextEp" pos="14:11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBActEP" pos="15" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OEP_DPID" pos="16" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NAKSts" pos="17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPType" pos="19:18" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Snp" pos="20" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Stall" pos="21" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPTxFNum" pos="25:22" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="CNAK" pos="26" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SNAK" pos="27" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SetD0PID" pos="28" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SetD1PID" pos="29" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDis" pos="30" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPEna" pos="31" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DOEPINT" protect="rw">
        <bits name="XferCompl"  pos="0" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDisbld"  pos="1" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBErr"  pos="2" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Setup"  pos="3" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknTXFEmp"  pos="4" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknEPMis"  pos="5" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEPNakEff"  pos="6" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxFEmp"  pos="7" access="r" rst="1">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxfifoUndrn"  pos="8" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DOEPTSIZ" protect="rw">
        <bits name="OEPXferSize"  pos="18:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OEPPktCnt"  pos="28:19" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="MC"  pos="30:29" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DOEPDMA" protect="rw">
        <bits name="DMAAddr"  pos="31:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="64" />
    </struct>
    
    <hole size="5376" align="0xe00" />
    <reg name="PCGCCTL" protect="rw">
        <bits name="StopPclk"  pos="0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GateHclk"  pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PwrClmp"  pos="2" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RstPdwnModule"  pos="3" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PhySuspended"  pos="4" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    
    <hole size="4064" align="0x1000"/>
    <struct count="DIEP_NUM+1" name="EPnFIFO">
    <reg name="TxRxData" protect="--">
        <bits name="TxData" pos="31:0" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RxData" pos="31:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32736" />
    </struct>

    <hole size="884736" align="0x20000"/>
    <struct count="SPFIFORAM_SIZE" name="SPFIFORAM">
    <reg name="RAMData" protect="r">
        <bits name="Data" pos="31:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    </struct>
    
    
</module>


</archive>


<archive relative = "vitac.xml">

<include file="globals.xml"/>

<module name="vitac" category="Baseband">
  <reg protect="rw" name="command">
    <bits access="rw" name="start_equ" pos="0" rst="0x0">
      <comment>Writing a '1' in this register triggers a Viterbi Equalization
      process. Ignored if any Viterbi process is already ongoing. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="start_dec" pos="1" rst="0x0">
      <comment>Writing a '1' in this register triggers a Viterbi Decoding
      process. Ignored if any Viterbi process is already ongoing. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="start_tb" pos="2" rst="0x0">
      <comment>Writing a '1' in this register triggers the TraceBack process.
      Ignored if any Viterbi process is already ongoing. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="int_mask" pos="3" rst="0x0">
      <comment>When this bit is set, it enables the generation of the
      VITAC_DONE_H interrupt. </comment>
    </bits>

    <bits access="rw" name="punctured" pos="4" rst="0x0">
      <comment>Indicates whether a puncturing scheme has to be used during
      decoding. If this bit is set to '0', the code is assumed unpunctured and
      no puncturing matrix is needed. </comment>
    </bits>

    <bits access="rw" name="nb_states" pos="6:5" rst="0x0">
      <comment>This field sets the number of states of the Trellis:
      <br />"00": 16 states <br />"01": 32 states <br />"10": 64 states
      <br />"11": reserved </comment>
    </bits>

    <bits access="rw" name="bkwd_trellis" pos="7" rst="0x0">
      <comment>When this bit is set, the channel symbols are treated in the
      reverse order, i.e. CH_SYMB_ADDR represents the end of the buffer and
      the symbols are read out backward. </comment>
    </bits>

    <bits access="rw" name="code_rate" pos="10:8" rst="0x0">
      <comment>This field sets the convolutional code rate for decoding:
      <br />"010": 1/2 rate <br />"011": 1/3 rate <br />"100": 1/4 rate
      <br />"101": 1/5 rate <br />"110": 1/6 rate <br />others: reserved
      </comment>
    </bits>

    <bits access="rw" name="bm_shift_lev" pos="14:11" rst="0x0">
      <comment>This field sets the amount of shift right applied at the output
      of the equalizer BM calculation: <br />"0000": BM = OUT[30:19]
      <br />"0001": BM = OUT[29:18] <br />... <br />"1111": BM = OUT[15:4]
      </comment>
    </bits>

    <bits access="rw" name="sv_shift_lev" pos="18:15" rst="0x0">
      <comment>This field sets the amount of shift right applied to the
      difference of the two metrics arriving at a node to create a Softvalue:
      <br />"0000": SoftVal = DELTA[15:9] <br />"0001": SoftVal =
      DELTA[14:8] <br />... <br />"1101": SoftVal = DELTA[2:0]&amp;"0000" <br />others:
      reserved </comment>
    </bits>

    <bits access="rw" name="nb_symbols" pos="28:20" rst="0x0">
      <comment>Number of symbols to be Equalized / Decoded. Auto decrement.
      </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="equ_pending" pos="0" rst="0x0">
      <comment>This bit is high when an equalization process is ongoing. It
      stays high when the module is stalled during operation. </comment>
    </bits>

    <bits access="r" name="dec pending" pos="1" rst="0x0">
      <comment>This bit is high when an decoding process is ongoing. It stays
      high when the module is stalled during operation. </comment>
    </bits>

    <bits access="r" name="tb_pending" pos="2" rst="0x0">
      <comment>This bit is high when an traceback process is ongoing. It stays
      high when the module is stalled during operation. </comment>
    </bits>

    <bits access="r" name="nb_rescales" pos="7:4" rst="0x0">
      <comment>After a Viterbi process, this field reports the number of
      rescaling operations that have been performed along the trellis.
      <br />This field is reset at every new Viterbi process. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch_symb_addr">
    <bits access="rw" name="addr" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>This is the start address of the channel symbols buffer in
      SRAM. For Equalization channel symbols are the sampled RF samples
      (2x12-bits packed complex values), and for Decoding channel symbols are
      a frame of softvalues (4x8-bits packed). <br />This address must be
      4-bytes aligned, bits[1:0] will be ignored. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="exp_symb_addr">
    <bits access="rw" name="addr" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>For Equalization, this is the base address of the partial sum
      terms buffer in SRAM. (2x12-bits packed complex values) <br />For
      Decoding, this is the base address of the puncturing matrix. <br />This
      address must be 4-bytes aligned, bits[1:0] will be ignored. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="pm_base_addr">
    <bits access="rw" name="addr" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>This is the base address in SRAM of the Path Metrics buffer.
      The VITAC will read and update PMs according to the scheme given in
      1.2.1.2. (2x16-bits packed values). <br />This address must be 4-bytes
      aligned, bits[1:0] will be ignored. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="out_base_addr">
    <bits access="rw" name="addr" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>This is the start address of the output buffer in SRAM. When in
      Equalizer mode, the VITAC will output the calculated Softvalues
      according to the scheme given in 1.2.1.7. When in Decoder mode, the
      VITAC will output the trace words according to the scheme given in
      1.2.2.4. <br />This address must be 4-bytes aligned, bits[1:0] will be
      ignored. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="H0_param">
    <bits access="rw" name="H0_I_part" pos="BB_SYMBOL_SIZE-1:0" rst="0x0">
      <comment>Real part of the h0 parameter of the estimated channel
      response. </comment>
    </bits>

    <bits access="rw" name="H0_Q_part" pos="BB_SYMBOL_SIZE+15:16" rst="0x0">
      <comment>Imaginary part of the h0 parameter of the estimated channel
      response. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="HL_param">
    <bits access="rw" name="HL_I_part" pos="BB_SYMBOL_SIZE-1:0" rst="0x0">
      <comment>Real part of the hL parameter of the estimated channel
      response. </comment>
    </bits>

    <bits access="rw" name="HL_Q_part" pos="BB_SYMBOL_SIZE+15:16" rst="0x0">
      <comment>Imaginary part of the hL parameter of the estimated channel
      response. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="rescale">
    <bits access="rw" name="threshold" pos="15:0" rst="0x0">
      <comment>This field indicates the threshold value to be reach by every
      PMs for triggering a rescale operation. The rescale operation consist in
      subtracting the threshold value to every PMs to avoid overflow during PM
      update. </comment>
    </bits>
  </reg>

  <reg protect="rw" count="3" name="res_poly">
    <comment>This register bank stores the less significant bit of the output
    from the coder for a particular code (see 1.2.2.1). The kth butterfly uses
    the bit k of this register. </comment>

    <bits access="rw" name="res_poly" pos="31:0" rst="0x0">
      <comment>This register stores the less significant bit of the output
      from the coder for a particular code (see 1.2.2.1). The kth butterfly
      uses the bit k of this register. </comment>
    </bits>
  </reg>

  <reg protect="r" name="int_status">
    <bits access="r" name="it_cause" pos="0" rst="0x0">
      <comment>This bit is set when the VITAC module finishes an ongoing
      operation. It can be masked by setting VITAC_CMD(IT_MASK) to '1'.
      <br />Resetting this bit is done by writing in IT_CLEAR register.
      <br />IT_CAUSE is the image of the VITAC_DONE_H interrupt line to the
      CPU. </comment>
    </bits>

    <bits access="r" name="it_status" pos="16" rst="0x0">
      <comment>This bit is the unmasked version of the IT_CAUSE bit.
      </comment>
    </bits>
  </reg>

  <reg protect="w" name="int_clear">
    <bits access="w" name="it_clear" pos="0" rst="0x0">
      <comment>Setting this bit to '1' resets the VITAC interrupt. </comment>
    </bits>
  </reg>
</module>

</archive>
<archive relative = "voc_ahb.xml">

<include file="voc_global.xml"/>

<module name="voc_ahb" category="Voc">
    <reg name="Irq_Status" protect="r">
        <bits name="XCpu_Voc_Irq_Cause" pos="0" access="r" rst="0">
            <comment>1 when Voc triggered an Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_Dma_Irq_Cause" pos="1" access="r" rst="0">
            <comment>1 when the DMA triggered an Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_DmaVoc_Irq_Cause" pos="2" access="r" rst="0">
            <comment>1 when the DMA programmed from Voc triggered an Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_Debug_Irq_Cause" pos="3" access="r" rst="0">
            <comment>1 when a VoC stall state is reached during debugging.
            </comment>
        </bits>
        <bitgroup name="XCpu_Irq_Cause">
            <entry ref="XCpu_Voc_Irq_Cause"/>
            <entry ref="XCpu_Dma_Irq_Cause"/>
            <entry ref="XCpu_DmaVoc_Irq_Cause"/>
            <entry ref="XCpu_Debug_Irq_Cause"/>
        </bitgroup>
        <bits name="BCpu_Voc_Irq_Cause" pos="8" access="r" rst="0">
            <comment>1 when Voc triggered an Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_Dma_Irq_Cause" pos="9" access="r" rst="0">
            <comment>1 when the DMA triggered an Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_DmaVoc_Irq_Cause" pos="10" access="r" rst="0">
            <comment>1 when the DMA programmed from Voc triggered an Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_Debug_Irq_Cause" pos="11" access="r" rst="0">
            <comment>1 when a VoC stall state is reached during debugging.
            </comment>
        </bits>
        <bitgroup name="BCpu_Irq_Cause">
            <entry ref="BCpu_Voc_Irq_Cause"/>
            <entry ref="BCpu_Dma_Irq_Cause"/>
            <entry ref="BCpu_DmaVoc_Irq_Cause"/>
            <entry ref="BCpu_Debug_Irq_Cause"/>
        </bitgroup>
        <bits name="XCpu_Voc_Irq_Status" pos="16" access="r" rst="0">
            <comment>1 when Voc triggered an Irq to the XCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="XCpu_Dma_Irq_Status" pos="17" access="r" rst="0">
            <comment>1 when the DMA triggered an Irq to the XCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="XCpu_DmaVoc_Irq_Status" pos="18" access="r" rst="0">
            <comment>1 when the DMA programmed from Voc triggered an Irq to the XCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="XCpu_Debug_Irq_Status" pos="19" access="r" rst="0">
            <comment>1 when a VoC stall state is reached during debugging. (not masked, status only)
            </comment>
        </bits>
        <bitgroup name="XCpu_Irq_Status">
            <entry ref="XCpu_Voc_Irq_Status"/>
            <entry ref="XCpu_Dma_Irq_Status"/>
            <entry ref="XCpu_DmaVoc_Irq_Status"/>
            <entry ref="XCpu_Debug_Irq_Status"/>
        </bitgroup>
        <bits name="BCpu_Voc_Irq_Status" pos="24" access="r" rst="0">
            <comment>1 when Voc triggered an Irq to the BCpu (not masked, status only).
            </comment>
        </bits>
        <bits name="BCpu_Dma_Irq_Status" pos="25" access="r" rst="0">
            <comment>1 when the DMA triggered an Irq to the BCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="BCpu_DmaVoc_Irq_Status" pos="26" access="r" rst="0">
            <comment>1 when the DMA programmed from Voc triggered an Irq to the BCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="BCpu_Debug_Irq_Status" pos="27" access="r" rst="0">
            <comment>1 when a VoC stall state is reached during debugging. (not masked, status only)
            </comment>
        </bits>
        <bitgroup name="BCpu_Irq_Status">
            <entry ref="BCpu_Voc_Irq_Status"/>
            <entry ref="BCpu_Dma_Irq_Status"/>
            <entry ref="BCpu_DmaVoc_Irq_Status"/>
            <entry ref="BCpu_Debug_Irq_Status"/>
        </bitgroup>
    </reg>
    <reg name="Irq_Mask_Set" protect="rs">
        <bits name="XCpu_Voc_Irq_Mask" pos="0" access="rs" rst="0">
            <comment>Write 1 to set the mask for Voc Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_Dma_Irq_Mask" pos="1" access="rs" rst="0">
            <comment>Write 1 to set the mask for DMA Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_DmaVoc_Irq_Mask" pos="2" access="rs" rst="0">
            <comment>Write 1 to set the mask for DMA Irq to the XCpu when the DMA is programmed from Voc.
            </comment>
        </bits>
        <bits name="XCpu_Debug_Irq_Mask" pos="3" access="rs" rst="0">
            <comment>Write 1 to set the mask for Debug Irq to the XCpu.
            </comment>
        </bits>
        <bitgroup name="XCpu_Irq_Mask">
            <entry ref="XCpu_Voc_Irq_Mask"/>
            <entry ref="XCpu_Dma_Irq_Mask"/>
            <entry ref="XCpu_DmaVoc_Irq_Mask"/>
            <entry ref="XCpu_Debug_Irq_Mask"/>
        </bitgroup>
        <bits name="BCpu_Voc_Irq_Mask" pos="8" access="rs" rst="0">
            <comment>Write 1 to set the mask for Voc Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_Dma_Irq_Mask" pos="9" access="rs" rst="0">
            <comment>Write 1 to set the mask for DMA Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_DmaVoc_Irq_Mask" pos="10" access="rs" rst="0">
            <comment>Write 1 to set the mask for DMA Irq to the BCpu when the DMA is programmed from Voc.
            </comment>
        </bits>
        <bits name="BCpu_Debug_Irq_Mask" pos="11" access="rs" rst="0">
            <comment>Write 1 to set the mask for Debug Irq to the BCpu.
            </comment>
        </bits>
        <bitgroup name="BCpu_Irq_Mask">
            <entry ref="BCpu_Voc_Irq_Mask"/>
            <entry ref="BCpu_Dma_Irq_Mask"/>
            <entry ref="BCpu_DmaVoc_Irq_Mask"/>
            <entry ref="BCpu_Debug_Irq_Mask"/>
        </bitgroup>
    </reg>
    <reg name="Irq_Mask_Clr" protect="rc">
        <bits name="XCpu_Voc_Irq_Mask" pos="0" access="rc" rst="0">
            <comment>Write 1 to clear the mask for Voc Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_Dma_Irq_Mask" pos="1" access="rc" rst="0">
            <comment>Write 1 to clear the mask for DMA Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_DmaVoc_Irq_Mask" pos="2" access="rc" rst="0">
            <comment>Write 1 to clear the mask for DMA Irq to the XCpu when the DMA is programmed from Voc.
            </comment>
        </bits>
        <bits name="XCpu_Debug_Irq_Mask" pos="3" access="rc" rst="0">
            <comment>Write 1 to clear the mask for Debug Irq to the XCpu.
            </comment>
        </bits>
        <bitgroup name="XCpu_Irq_Mask">
            <entry ref="XCpu_Voc_Irq_Mask"/>
            <entry ref="XCpu_Dma_Irq_Mask"/>
            <entry ref="XCpu_DmaVoc_Irq_Mask"/>
            <entry ref="XCpu_Debug_Irq_Mask"/>
        </bitgroup>
        <bits name="BCpu_Voc_Irq_Mask" pos="8" access="rc" rst="0">
            <comment>Write 1 to clear the mask for Voc Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_Dma_Irq_Mask" pos="9" access="rc" rst="0">
            <comment>Write 1 to clear the mask for DMA Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_DmaVoc_Irq_Mask" pos="10" access="rc" rst="0">
            <comment>Write 1 to clear the mask for DMA Irq to the BCpu when the DMA is programmed from Voc.
            </comment>
        </bits>
        <bits name="BCpu_Debug_Irq_Mask" pos="11" access="rc" rst="0">
            <comment>Write 1 to clear the mask for Debug Irq to the BCpu.
            </comment>
        </bits>
        <bitgroup name="BCpu_Irq_Mask">
            <entry ref="BCpu_Voc_Irq_Mask"/>
            <entry ref="BCpu_Dma_Irq_Mask"/>
            <entry ref="BCpu_DmaVoc_Irq_Mask"/>
            <entry ref="BCpu_Debug_Irq_Mask"/>
        </bitgroup>
    </reg>
    <reg name="DMA_Cfg" protect="rw">
        <bits name="DMA_SizeLow" pos="1:0" access="r" rst="0">
            <comment>Ignored on write, read as 0, so DMA_Size can be programmed in 15:0 as a byte size as long as the size in a multiple of 4.
            </comment>
        </bits>
        <bits name="DMA_WSize" pos="15:2" access="rw" rst="all1">
            <comment>Number of 32bits Words to transfer.
            </comment>
        </bits>
        <bitgroup name="DMA_Size">
            <entry ref="DMA_SizeLow"/>
            <entry ref="DMA_WSize"/>
        </bitgroup>
        <bits name="DMA_Run" pos="16" access="rw" rst="0">
            <comment>Start the DMA transfer
            </comment>
          </bits>
        <bits name="Dma_Single_cfg" pos="19" access="r" rst="0">
        </bits>          
        <bits name="DMA_Dir" pos="20" access="rw" rst="1">
            <comment>Set the DMA transfer direction
            </comment>
            <options>
                <option name="Read" value="0"><comment>Read from main memory to Voc Memory</comment></option>
                <option name="Write" value="1"><comment>Write to main memory from Voc Memory</comment></option>
            </options>
        </bits>
        <bits name="DMA_B2S_En" pos="21" access="rw" rst="1">
            <comment>Enable the byte to short mode (b2s). For read access : every byte read from the external memory is cast to short and written to the internal memory (twice as much data written than received). For write access : every short read from the internal memory is trunkated to byte and written to the external memory (twice less data written than read). In both cases the size corresponds to the number of words transfered on the AHB.
            </comment>
        </bits>
        <bits name="DMA_B2S_Sign" pos="22" access="rw" rst="1">
            <comment> For read access only (byte to short cast): define if the cast is signed or unsigned.
            </comment>
        </bits>        
        <bits name="DMA_Wrap" pos="27:24" access="rw" rst="all1">
            <comment>Set the DMA wrap mode, refer to Voc documentation for a description of Wrap transfers.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_LAddr" protect="rw">
        <bits name="DMA_LAddr" pos="16:1" access="rw" rst="0">
            <comment>DMA Local Address: Address in the Voc memory space.
            </comment>
            <options> 
                <mask/>
            </options>
        </bits>
    </reg>
    <reg name="DMA_EAddr" protect="rw">
        <bits name="DMA_EAddr" pos="AHB_NB_BITS_ADDR-1:2" access="rw" rst="0">
            <comment>DMA External Address: Address in the main memory space.
            </comment>
            <options> 
                <mask/>
            </options>
        </bits>
        <bits name="DMA_Single_B2S_En" pos="28" access="w" rst="0">
            <comment>Same as DMA_B2S_En, but  valid only when the DMA_Single bit is enabled.
            </comment>
        </bits>
        <bits name="DMA_Single_B2S_Sign" pos="29" access="w" rst="0">
            <comment> For read access only (byte to short cast): define if the cast is signed or unsigned.
            </comment>
        </bits>          
        <bits name="DMA_Write" pos="30" access="w" rst="0">
            <comment>Set the DMA transfer direction, valid only when the DMA_Single bit is enabled.
            </comment>
            <options>
                <option name="Read" value="0"><comment>Read from main memory to Voc Memory</comment></option>
                <option name="Write" value="1"><comment>Write to main memory from Voc Memory</comment></option>
            </options>
        </bits>
        <bits name="DMA_Single" pos="31" access="w" rst="0">
            <comment>When 1 start a DMA transfer in Single mode, the data is tranfered to/from the DMA_Data_Single register.
                <br/>When 0 start a regular DMA transfer using LAddr and Size.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_Status" protect="r">
        <bits name="DMA_On" pos="0" access="r" rst="0">
            <comment>1 when DMA is running.
            </comment>
        </bits>
        <bits name="DMA_Sema_Status" pos="31" access="r" rst="1">
            <comment>Read the value of the DMA Semaphore without affecting it.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_Sema" protect="w">
        <bits name="DMA_Sema" pos="1" access="w" rst="1">
            <comment>Read the value of the DMA Semaphore:
                <br/>If 1 is returned the DMA was available and is know taken.
                <br/>If 0 is returned the DMA is not available, you need to try again to get it. The software can wait on any DMA Irq before retrying if Sema is never free manually.
                <br/>Write 1 to free manually (got the semaphore and want to discard it without prgrammin a transfer.)
                <br/>The end of the DMA will also free the Semaphone.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_2D" protect="rw">
        <bits name="DMA_StrideLow" pos="1:0" access="r" rst="0">
            <comment>Ignored on write, read as 0, so DMA_Stride can be programmed as a byte size as long as the size in a multiple of 4.
            </comment>
        </bits>
        <bits name="DMA_WStride" pos="12:2" access="rw" rst="all0">
            <comment> Stride in Words (without the 2 lsb). The stride of the 2D transfer corresponds to the step from one line to another excluding the burst size (in bytes). Example : If the size is 12 bytes (3 words) and the stride is 20 bytes (5 words), starting from word position N, the DMA will transfer words at positions N, N+1, N+2, N+8, N+9, N+10, N+16, N+17, N+18, etc... If the number of lines is L this example will access a block with dimensions 3xL inside a block of size 8xL.
            </comment>
        </bits>
        <bitgroup name="DMA_Stride">
            <entry ref="DMA_StrideLow"/>
            <entry ref="DMA_WStride"/>
        </bitgroup>
        <bits name="DMA_Lines" pos="27:16" access="rw" rst="0">
            <comment>Number of lines of the 2D transfer. Example : this corresponds to the number L in the previous example.
            </comment>
        </bits>
    </reg>    
    <reg name="DMA_Stop" protect="w">
        <bits name="DMA_Stop" pos="0" access="w" rst="0">
            <comment>Write 1 to this register to cleanly stop the DMA. Note : a last burst may be on going when you requested the clean stop, and no more bursts will be executed after this last burst. Because of this potential last on going burst you need to poll the DMA_On field of the DMA_Status register to verify the completion of the DMA.
            </comment>
        </bits>
    </reg>

    
</module>

</archive>
<archive relative = "voc_cfg.xml">

<include file="voc_global.xml"/>

<module name="voc_cfg" category="Voc">
    <reg16 name="Ctrl" protect="rw">
        <bits name="Run" pos="2:0" access="w" rst="0">
            <options>
                <option name="Pause" value="0"><comment>Pause VoC (no pipe flush). When paused, all events that wake up VoC (start, soft wake up, or wake up on extern event) will resume the execution from where it was paused.</comment></option>
                <option name="SoftWakeUp0" value="1"><comment>CPU generated event with id=0 that can wake VoC if the coresponding bit in the Wakeup_Mask register is set to '1'.</comment></option>
                <option name="SoftWakeUp1" value="3"><comment>CPU generated event with id=1 that can wake VoC if the coresponding bit in the Wakeup_Mask register is set to '1'</comment></option>
                <option name="Stop" value="4"><comment>Stop VoC and flush pipe. Used when the current task is finished (because the next task will have a different PC start). The PC start change should mandatorily be preceeded by a Stop. This ensures that no previously executed code that is still in the pipe will modify the registry during the first two instructions of the new task execution.</comment></option>
                <option name="Start" value="5"><comment>Wake up VoC regardless of the Wakeup_Mask setting (force wake up)</comment></option>
            </options>
        </bits>
        <bits name="BCPU_irq" pos="4" access="w" rst="0">
            <comment>Writing '1' will generate an internal pulse recorded in the Irq_Status register of the voc_ahb interface (see voc_ahb registers). If the corresponding bit of the Irq_Mask vector is set to '1', a level interrupt will be generated to the BCPU. Should be configured by VoC_core only (not by a CPU)!
            </comment>
        </bits>
        <bits name="XCPU_irq" pos="5" access="w" rst="0">
            <comment>Writing '1' will generate an internal pulse recorded in the Irq_Status register of the voc_ahb interface (see voc_ahb registers). If the corresponding bit of the Irq_Mask vector is set to '1', a level interrupt will be generated to the XCPU. Should be configured by VoC_core only (not by a CPU)!
            </comment>
        </bits>
        <bits name="Running" pos="0" access="r" rst="0">
            <options>
                <option name="Yes" value="1"><comment>VoC is running</comment></option>
                <option name="No" value="0"><comment>VoC is paused or stopped</comment></option>
                <default/>
            </options>
        </bits>
        <bits name="Sema_Status" pos="1" access="r" rst="1">
            <comment>Status of the VoC semaphore (reading this bit will not modify the semaphore).
            </comment>
        </bits>
        <bits name="Status_spy_wr_err" pos="2" access="r" rst="0">
            <comment>
            </comment>
        </bits>
	</reg16>
	<reg16 name="DMA_Wrap" protect="">
        <comment>Should be configured by VoC_core only (not by a CPU)! If VoC DMA is used by the CPU the equivalent voc_ahb registers should be configured.
        </comment>
        <bits name="DMA_Wrap" pos="3:0" access="w" rst="all0">
            <comment>Wrap register. 0 : no wrap, wrap_val (other than 0): the wrap_val LSB bits of the Word wrap address are at '0'.
            </comment>
        </bits>
    </reg16>
    <reg16 name="DMA_Size" protect="">
        <comment>Should be configured by VoC_core only (not by a CPU)! If VoC DMA is used by the CPU the equivalent voc_ahb registers should be configured.
        </comment>
        <bits name="DMA_Size" pos="13:0" access="w" rst="all0">
            <comment>Word Size of the DMA Transfer (number of INT32 to transfer) 
            </comment>
        </bits>
    </reg16>
    <reg16 name="DMA_Laddr" protect="">        
        <comment>Should be configured by VoC_core only (not by a CPU)! If VoC DMA is used by the CPU the equivalent voc_ahb registers should be configured.
        </comment>
        <bits name="DMA_LAddr" pos="15:0" access="w" rst="all0">
            <comment>DMA Local Word Address: Address in the Voc memory space.
            </comment>
        </bits>
    </reg16>
    <reg name="DMA_EAddr" protect="">
        <comment>Should be configured by VoC_core only (not by a CPU)! If VoC DMA is used by the CPU the equivalent voc_ahb registers should be configured.
        </comment>
        <bits name="DMA_EAddr" pos="AHB_NB_BITS_ADDR-1:2" access="w" rst="0">
            <comment>DMA External Byte Address (aligned to Word address, the 2 lsb are always '0'): Address in the main memory space.
            </comment>
            <options> 
                <mask/>
            </options>
        </bits>
        <bits name="DMA_B2S_En" pos="28" access="w" rst="0">
            <comment>Enable the byte to short mode (b2s). For read access : every byte read from the external memory is cast to short and written to the internal memory (twice as much data written than received). For write access : every short read from the internal memory is trunkated to byte and written to the external memory (twice less data written than read). In both cases the size corresponds to the number of words transfered on the AHB.
            </comment>
        </bits>
        <bits name="DMA_B2S_Sign" pos="29" access="w" rst="0">
            <comment> For read access only (byte to short cast): define if the cast is signed or unsigned.
            </comment>
        </bits>        
        <bits name="DMA_Write" pos="30" access="w" rst="0">
            <comment>Set the DMA transfer direction
            </comment>
            <options>
                <option name="Read" value="0"><comment>Read from main memory to Voc Memory</comment></option>
                <option name="Write" value="1"><comment>Write to main memory from Voc Memory</comment></option>
            </options>
        </bits>
        <bits name="DMA_Single" pos="31" access="w" rst="0">
            <comment>When 1 start a DMA transfer in Single mode, the data is tranfered to/from the DMA_Data_Single register.
                <br/>When 0 start a regular DMA transfer using LAddr and Size.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_Data_Single" protect="rw">
        <bits name="DMA_Data_Single" pos="31:0" access="rw" rst="0">
            <comment>DMA Data for Single Access (source or destination depending on direction)
            </comment>
        </bits>
    </reg>
    <reg name="DMA_2D" protect="">
        <bits name="DMA_Stride" pos="12:0" access="w" rst="0">
            <comment>Stride in bytes of the 2D transfer, corresponding to the step from one line to another excluding the burst size (in bytes). Example : If the size is 12 bytes (3 words) and the stride is 20 bytes (5 words), starting from word position N, the DMA will transfer words at positions N, N+1, N+2, N+8, N+9, N+10, N+16, N+17, N+18, etc... If the number of lines is L this example will access a block with dimensions 3xL inside a block of size 8xL.
            </comment>
        </bits>
        <bits name="DMA_Lines" pos="27:16" access="w" rst="0">
            <comment>Number of lines of the 2D transfer. Example : this corresponds to the number L in the previous example.
            </comment>
        </bits>
    </reg>        
    <hole size="32"/>
    <reg16 name="DAI_Data_In" protect="r">
        <bits name="DAI_Data_In" pos="12:0" access="r" rst="0">
            <comment>Data from DAI Simple interface.
            </comment>
        </bits>
        <bits name="DAI_Data_Ready" pos="15" access="r" rst="0">
            <comment>Data ready.
            </comment>
        </bits>       
    </reg16>
    <reg16 name="DAI_Data_Out" protect="w">
        <bits name="DAI_Data_Out" pos="12:0" access="w">
            <comment>Data for DAI Simple.
            </comment>
        </bits>
    </reg16>
    <reg16 name="ROM_Page" protect="" rst="0">
        <bits name="ROM_Page" pos="15:0" access="rw" rst="0">
           <comment>Number of the ROM page when a ROM bigger than 1 page is defined in voc_cfg_pkg.vhd. Otherwise this register does not exist.
           </comment>
        </bits>
    </reg16>
    <reg16 name="Debug" protect="rw" rst="0">
        <bits name="stall_on_bkp" pos="0" access="rw" rst="0">
           <comment>Enable or disable stall on hardware breakpoint.
           </comment>
        </bits>
        <bits name="stall_on_branch_taken" pos="1" access="rw" rst="0">
           <comment>Enable or disable stall when a branch is taken in the program.
           </comment>
        </bits>
        <bits name="step" pos="2" access="rw" rst="0">
           <comment>Enable or disable step mode (execute 1 instruction and stall).
           </comment>
        </bits>
    </reg16>
    <reg name="BIST_Ctrl"  protect="rw">
       <bits name="BIST_Run" pos="0" access="w" rst="0">
            <comment>'1' : start.
            </comment>
       </bits>
       <bits name="BIST_Running" pos="0" access="r" rst="0">
            <comment>'0' : done.
            </comment>
       </bits>
       <bits name="BIST_Status" pos="1" access="r" rst="0">
            <comment>'1' : fail. '0' : succeed. Valid when BIST_Running is at '0'.
            </comment>
       </bits>        
       <bits name="BIST_CRC" pos="31:16" access="r" rst="0">
            <comment>16-bit CRC result of the ROM. Valid when BIST_Running is at '0'.
            </comment>
       </bits>        
    </reg>
    <reg16 name="Wakeup_Mask" protect="rw">
       <bits name="IFC0_Event_Mask" pos="0" access="rw" rst="0">
            <comment>Mask enabling the IFC0 half or whole buffer event.
            </comment>
       </bits>        
       <bits name="IFC1_Event_Mask" pos="1" access="rw" rst="0">
            <comment>Mask enabling the IFC1 half or whole buffer event.
            </comment>
       </bits>
       <bits name="DMAE_Event_Mask" pos="2" access="rw" rst="0">
            <comment>Mask enabling the DMAE event (DMA configured by extern master done).
            </comment>
       </bits>
       <bits name="DMAI_Event_Mask" pos="3" access="rw" rst="0">
            <comment>Mask enabling the DMAI event (DMA configured by VoC core done).
            </comment>
       </bits>
       <bits name="SOF0_Event_Mask" pos="4" access="rw" rst="0">
            <comment>Mask enabling the SOF0 event (Soft Wake Up with Id=0 generated by writing the corresponding value in the control register).
            </comment>
       </bits>
       <bits name="SOF1_Event_Mask" pos="5" access="rw" rst="0">
            <comment>Mask enabling the SOF1 event (Soft Wake Up with Id=1 generated by writing the corresponding value in the control register).
            </comment>
       </bits>
       <bitgroup name="Wakeup_Mask">
            <entry ref="IFC0_Event_Mask"/>
            <entry ref="IFC1_Event_Mask"/>
            <entry ref="DMAE_Event_Mask"/>
            <entry ref="DMAI_Event_Mask"/>
            <entry ref="SOF0_Event_Mask"/>
            <entry ref="SOF1_Event_Mask"/>
        </bitgroup>
    </reg16>
    <hole size="16"/>
    <reg16 name="Wakeup_Status" protect="rc">
       <bits name="IFC0_Event_Status" pos="0" access="rc" rst="0">
            <comment>'1': Triggered IFC0 event. Write '1' to clear.
            </comment>
       </bits>        
       <bits name="IFC1_Event_Status" pos="1" access="rc" rst="0">
            <comment>'1': Triggered IFC1 event. Write '1' to clear.
            </comment>
       </bits>
       <bits name="DMAE_Event_Status" pos="2" access="rc" rst="0">
            <comment>'1': Triggered DMAE event. Write '1' to clear.
            </comment>
       </bits>
       <bits name="DMAI_Event_Status" pos="3" access="rc" rst="0">
            <comment>'1': Triggered DMAI event. Write '1' to clear.
            </comment>
       </bits>
       <bits name="SOF0_Event_Status" pos="4" access="rc" rst="0">
            <comment>'1': Triggered SOF0 event. Write '1' to clear.
            </comment>
       </bits>
       <bits name="SOF1_Event_Status" pos="5" access="rc" rst="0">
            <comment>'1': Triggered SOF1 event. Write '1' to clear.
            </comment>
       </bits>
       <bitgroup name="Wakeup_Status">
            <entry ref="IFC0_Event_Status"/>
            <entry ref="IFC1_Event_Status"/>
            <entry ref="DMAE_Event_Status"/>
            <entry ref="DMAI_Event_Status"/>
            <entry ref="SOF0_Event_Status"/>
            <entry ref="SOF1_Event_Status"/>
        </bitgroup>
    </reg16>
    <reg16 name="Wakeup_Cause" access="r" rst="0">
       <comment>Logical AND of Wakeup_Status and Wakeup_Mask (show only the enabled events).
       </comment>
       <bits name="IFC0_Event_Cause" pos="0" access="r" rst="0">
       </bits>        
       <bits name="IFC1_Event_Cause" pos="1" access="r" rst="0">
       </bits>
       <bits name="DMAE_Event_Cause" pos="2" access="r" rst="0">
       </bits>
       <bits name="DMAI_Event_Cause" pos="3" access="r" rst="0">
       </bits>
       <bits name="SOF0_Event_Cause" pos="4" access="r" rst="0">
       </bits>
       <bits name="SOF1_Event_Cause" pos="5" access="r" rst="0">
       </bits>
    </reg16>  
    <reg16 name="Sema" protect="w">
       <bits name="Sema" pos="0" access="w" rst="1">
            <comment>VoC semaphore. If the register is read when the field = '1', the field = '0' on the next VoC clock cycle. Can write '0' or '1' in this field.
            </comment>
       </bits>
    </reg16>
    <hole size="144"/>
    <reg name="REG01" protect="rw">
        <bits name="REG0" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register REG0
            </comment>
        </bits>
        <bits name="REG1" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register REG1
            </comment>
        </bits>
        <l name="REG0"/>
        <h name="REG1"/>
    </reg>
    <reg name="REG23" protect="rw">
        <bits name="REG2" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register REG2
            </comment>
        </bits>
        <bits name="REG3" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register REG3
            </comment>
        </bits>
        <l name="REG2"/>
        <h name="REG3"/>
    </reg>
    <reg name="REG45" protect="rw">
        <bits name="REG4" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register REG4
            </comment>
        </bits>
        <bits name="REG5" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register REG5
            </comment>
        </bits>
        <l name="REG4"/>
        <h name="REG5"/>
    </reg>
    <reg name="REG67" protect="rw">
        <bits name="REG6" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register REG6
            </comment>
        </bits>
        <bits name="REG7" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register REG7
            </comment>
        </bits>
        <l name="REG6"/>
        <h name="REG7"/>
    </reg>
    <reg name="ACC0" protect="rw">
        <bits name="ACC0_LO" pos="15:0" access="rw" rst="0">
            <comment>Voc Accumulator Register ACC0 (lo)
            </comment>
        </bits>
        <bits name="ACC0_HI" pos="31:16" access="rw" rst="0">
            <comment>Voc Accumulator Register ACC0 (hi)
            </comment>
        </bits>
        <l name="ACC0_lo"/>
        <h name="ACC0_hi"/>
    </reg>
    <reg name="ACC1" protect="rw">
        <bits name="ACC1_LO" pos="15:0" access="rw" rst="0">
            <comment>Voc Accumulator Register ACC1 (lo)
            </comment>
        </bits>
        <bits name="ACC1_HI" pos="31:16" access="rw" rst="0">
            <comment>Voc Accumulator Register ACC1 (hi)
            </comment>
        </bits>
        <l name="ACC1_lo"/>
        <h name="ACC1_hi"/>
    </reg>
    <reg name="RL6" protect="rw">
        <bits name="RL6_LO" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register RL6 (lo)
            </comment>
        </bits>
        <bits name="RL6_HI" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register RL6 (hi)
            </comment>
        </bits>
        <l name="RL6_lo"/>
        <h name="RL6_hi"/>
    </reg>
    <reg name="RL7" protect="rw">
        <bits name="RL7_LO" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register RL7 (lo)
            </comment>
        </bits>
        <bits name="RL7_HI" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register RL7 (hi)
            </comment>
        </bits>
        <l name="RL7_lo"/>
        <h name="RL7_hi"/>
    </reg>
    <reg16 name="PC" protect="rw">
        <bits name="PC" pos="15:0" access="rw" rst="0">
            <comment>Voc Program Counter Register PC
            </comment>
        </bits>
    </reg16>
    <reg16 name="RA" protect="rw">
        <bits name="RA" pos="15:0" access="rw" rst="0">
            <comment>Voc Return Address Register RA
            </comment>
        </bits>
    </reg16>
    <reg16 name="SP16" protect="rw">
        <bits name="SP16" pos="15:0" access="rw" rst="0">
            <comment>Voc Stack Register SP16
            </comment>
        </bits>
    </reg16>
    <reg16 name="SP32" protect="rw">
        <bits name="SP32" pos="15:0" access="rw" rst="0">
            <comment>Voc Stack Register SP32
            </comment>
        </bits>
    </reg16>
    <hole size="64"/>
    <reg16 name="BKP" protect="rw">
        <bits name="BKP" pos="15:0" access="rw" rst="0">
            <comment>Voc Program Breakpoint Register. Valid when the Dbg_On mode in the Ctrl register is set to '1'
            </comment>
        </bits>
    </reg16>
    <hole size="16"/>
    <reg16 name="PC_PREV" protect="r">
        <bits name="PC_PREV" pos="15:0" access="r" rst="0">
            <comment>Previous PC value. Used to track the source PC of a branch when the stall_on_branch_taken bit in the Debug register is enabled
            </comment>
        </bits>
    </reg16>
    <reg16 name="LOOP" protect="r">
        <bits name="LOOP0" pos="7:0" access="r" rst="0">
            <comment>Loop 0 counter value
            </comment>
        </bits>
        <bits name="LOOP1" pos="15:8" access="r" rst="0">
            <comment>Loop 1 counter value
            </comment>
        </bits>
    </reg16>
    
</module>

</archive>
<archive relative = "voc_ram.xml">
<module name="voc_ram" category="Voc">

    <var name="VOC_RAM_X_SIZE" value="0x5000"/>
    <var name="VOC_RAM_Y_SIZE" value="0x5000"/>
    <var name="VOC_ROM_Z_SIZE" value="0x0000"/>
    <var name="VOC_RAM_I_SIZE" value="0x5000"/>

    <var name="VOC_RAM_X_SPACE" value="0x8000"/>
    <var name="VOC_RAM_Y_SPACE" value="0x8000"/>
    <var name="VOC_ROM_Z_SPACE" value="0x10000"/>
    <var name="VOC_RAM_I_SPACE" value="0x20000"/>
    
    <memory name="voc_ram_x_base" size="VOC_RAM_X_SIZE">
        <comment>VoC RAM X space. 
        </comment>
    </memory>
    <memory name="voc_ram_x_hole" size="VOC_RAM_X_SPACE - VOC_RAM_X_SIZE">
        <comment>VoC RAM X whole. 
        </comment>
    </memory>
    <memory name="voc_ram_y_base" size="VOC_RAM_Y_SIZE">
        <comment>VoC RAM Y space. 
        </comment>
    </memory>
    <memory name="voc_ram_y_hole" size="VOC_RAM_Y_SPACE - VOC_RAM_Y_SIZE">
        <comment>VoC RAM Y whole. 
        </comment>
    </memory>
    <memory name="voc_rom_z_hole" size="VOC_ROM_Z_SPACE - VOC_ROM_Z_SIZE">
        <comment>VoC ROM Y whole. 
        </comment>
    </memory>
    <memory name="voc_ram_i_base" size="VOC_RAM_I_SIZE">
        <comment>VoC RAM I space. 
        </comment>
    </memory>
    <memory name="voc_ram_i_hole" size="VOC_RAM_I_SPACE - VOC_RAM_I_SIZE">
        <comment>VoC RAM I whole. 
        </comment>
    </memory>

</module>

</archive>


<archive relative = "xcor.xml">

<include file="globals.xml"/>

<module name="xcor" category="Baseband">
  <var name="XCOR_SYMBOL_SIZE" value="VITAC_MULT_SIZE" />

  <var name="XCOR_SADDER_SIZE" value="XCOR_SYMBOL_SIZE+1 +6" />

  <reg name="command" protect="rw">
    <bits access="rw" name="biterr_en" pos="0" rst="0x0">
      <comment>Enables the Biterror calculation mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="dco1p_en" pos="1" rst="0x0">
      <comment>Enables the DC Offset Correction (1st pass) mode. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="dco2p_en" pos="2" rst="0x0">
      <comment>Enables the DC Offset Correction (2nd pass) mode. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="dco3p_en" pos="3" rst="0x0">
      <comment>Enables the DC Offset Correction (3rd pass) mode. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="tscxc_en" pos="4" rst="0x0">
      <comment>Enables the Training Sequence Cross-Correlation mode.
      Auto-reset. </comment>
    </bits>

    <bits access="rw" name="srec_en" pos="5" rst="0x0">
      <comment>Enables the Symbol Re-Construction mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="bext_en" pos="6" rst="0x0">
      <comment>Enables the Bit Extraction mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="sproc_en" pos="7" rst="0x0">
      <comment>Enables the Sum Of PROduCt mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="chest_en" pos="8" rst="0x0">
      <comment>Enables the Channel Estimation mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="fchxc_en" pos="9" rst="0x0">
      <comment>Enables the FCH Xcorrelation mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="sldwin_en" pos="10" rst="0x0">
      <comment>Enables the Sliding window mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="it_mask" pos="11" rst="0x0">
      <comment>Mask of the end of processing interrupt.</comment>
    </bits>

    <bits access="rw" name="pack_IQ" pos="12" rst="0x0">
      <comment>Data path setting. Pack I and Q on a single 32-bits word.
      </comment>
    </bits>

    <bits access="rw" name="derotation_en" pos="13" rst="0x0">
      <comment>Data path setting. Enables derotation for DCOC 3pass.
      </comment>
    </bits>

    <bits access="rw" name="nb_iloop" pos="23:16" rst="0x0">
      <comment>Control setting. Number of internal loop iteration. </comment>
    </bits>

    <bits access="rw" name="nb_symb" pos="31:24" rst="0x0">
      <comment>Control setting. Number of symbols to process. </comment>
    </bits>
  </reg>

  <reg name="status" protect="rw">
    <bits access="r" name="op_pending" pos="0" rst="0x0">
      <comment>This bit is high when an operation is ongoing.</comment>
    </bits>
    <bits access="r" name="it_cause" pos="16" rst="0x0">
      <comment>Masked version of it_status that goes to Interrupt controller.</comment>
    </bits>
    <bits access="rw" name="it_status" pos="31" rst="0x0">
        <comment>This bit is set high when an operation is finished. It must be reset before lauching a new operation if Xcor interrupt is enabled.</comment>
    </bits>
  </reg>

  <reg name="hv0" protect="rw">
    <comment>Multipurpose Data Register. <br /> Store Training Sequence in
    TSXC mode. <br /> Store SUM in DCOC 3rd pass mode. <br /> Store bit
    sequence in SREC mode. <br /> Store SUM in SPROC mode. <br /> Store I SUM
    in CHEST mode. <br /> Store R(k-1) in FCHXC mode. </comment>

    <bits access="rw" name="hv0" pos="31:0" rst="0x0">
      <comment>Multipurpose. </comment>
    </bits>
  </reg>

  <reg name="hv1" protect="rw">
    <comment>Multipurpose Data Register. <br /> Store Training Sequence in
    TSXC mode. <br /> Store bit sequence in SREC mode. <br /> Store Q SUM in
    CHEST mode. </comment>

    <bits access="rw" name="hv1" pos="31:0" rst="0x0">
      <comment>Multipurpose. </comment>
    </bits>
  </reg>

  <reg count="6" name="data" protect="rw">
    <comment>Multipurpose Data Registers. <br />D0 stores
    symbols/softvalues/channel taps depending on mode. Not readable. <br />D1
    stores decoded bits/IQ threshols/IQ Offsets/A terms depending on mode. Not
    readable. <br />D2 (aka A1) serves as Rd address (decoded bits, A or B
    terms) / Wr address register (I or packed IQ results, Symbols) / event
    counter depending on mode. <br />D3 (aka A2) serves as Wr address (Q
    results) / event counter depending on mode. <br />D4 stores results from
    VITAC / extracted HardValues depending on mode. Not readable.<br />D5 (aka
    A3) serves as Wr address (CQ results) Not readable. </comment>

    <bits access="rw" name="data" pos="31:0" rst="0x0">
      <comment>Multipurpose. </comment>
    </bits>
  </reg>

  <reg name="accuI" protect="r">
    <bits access="r" name="accuI" pos="XCOR_SADDER_SIZE-1:0" rst="0x0">
      <comment>I part accumulator register.</comment>
    </bits>
  </reg>

  <reg name="accuQ" protect="r">
    <bits access="r" name="accuQ" pos="XCOR_SADDER_SIZE-1:0" rst="0x0">
      <comment>I part accumulator register.</comment>
    </bits>
  </reg>

  <reg name="addr0" protect="rw">
    <comment>Address 0 Register. <br />Stores Rd address for symbols /
    SoftValues / A terms depending on mode. <br /> Auto
    increment/decrement/reset. </comment>

    <bits access="rw" name="addr0" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>32-bit word address (bits 0 and 1 disregarded). </comment>
    </bits>
  </reg>
  
  <reg count="6" name="data_e" protect="rw">
    <comment>Multipurpose Data Edge Registers. </comment>

    <bits access="rw" name="data" pos="31:0" rst="0x0">
      <comment>Multipurpose. </comment>
    </bits>
  </reg>
  
</module>

</archive>
<archive relative = "xcpu.xml">
<module name="xcpu" category="Debug">
    <hole size="32"/>
    <reg name="rf0_addr" protect="r">
        <bits name="rf0_addr" pos="31:0" access="r" rst="0">
            <comment>program counter for the RF stage.
            </comment>
        </bits>
    </reg>
    <hole size="3104"/>
    <reg name="cp0_adr_BadVAddr" protect="r">
        <bits name="cp0_adr_BadVAddr" pos="31:0" access="r" rst="0"/>
    </reg>
    <reg name="cp0_Cause" protect="r">
        <bits name="cp0_Cause_ExcCode" pos="5:2" access="r" rst="0">
            <options>
                <option value="0" name="Int"><comment>Interrupt</comment></option>
                <option value="1" name="Mod"><comment>TLB modification exception</comment></option>
                <option value="2" name="TLBL"><comment>TLB exception (load or instruction fetch)</comment></option>
                <option value="3" name="TLBS"><comment>TLB exception (store)</comment></option>
                <option value="4" name="AdEL"><comment>Address error exception (load or instruction fetch)</comment></option>
                <option value="5" name="AdES"><comment>Address error exception (store)</comment></option>
                <option value="6" name="IBE"><comment>Bus error exception (instruction fetch)</comment></option>
                <option value="7" name="DBE"><comment>Bus error exception (data reference: load or store)</comment></option>
                <option value="8" name="Sys"><comment>Syscall exception</comment></option>
                <option value="9" name="Pb"><comment>Breakpoint exception</comment></option>
                <option value="10" name="Ri"><comment>Reserved instruction exception</comment></option>
                <option value="11" name="CpU"><comment>Coprocessor Unusable exception</comment></option>
                <option value="12" name="Ov"><comment>Arithmetic Overflow exception</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Cause_IP_soft" pos="9:8" access="r" rst="0">
            <comment>Theses interrupt lines are software interrupts (the cpu can write in the CP0 bits to trigger and clear them).
            </comment>
            <options>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Cause_IP_ext" pos="15:10" access="r" rst="0">
            <comment>Theses interrupt lines maps to the hardware interrupt lines from the corresponding irq module.
            </comment>
            <options>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bitgroup name="cp0_Cause_IP">
            <entry ref="cp0_Cause_IP_soft"/>
            <entry ref="cp0_Cause_IP_ext"/>
        </bitgroup>
        <bits name="cp0_Cause_CE" pos="29:28" access="r" rst="0">
            <comment>The Coprocessor Error (CE) field indicate the coprocessor unit number referenced when a Coprocessor Unusable exception is taken.
            </comment>
            <options>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Cause_BD" pos="31" access="r" rst="0">
            <comment>The Branch Delay (BD) bit indicate whether the last exception was taken while executing in a branch delay slot.
            </comment>
            <options>
                <option value="0" name="Normal"/>
                <option value="1" name="Delay_slot"/>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name="cp0_Status" protect="r">
        <bits name="cp0_Status_IEc" pos="0" access="r" rst="0">
            <comment>Current Interrupt Enable
            </comment>
            <options>
                <option value="0" name="disable"/>
                <option value="1" name="enable"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Status_KUc" pos="1" access="r" rst="0">
            <comment>Current Kernel/User mode
            </comment>
            <options>
                <option value="0" name="kernel"/>
                <option value="1" name="user"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Status_IEp" pos="2" access="r" rst="0">
            <comment>Previous Interrupt Enable
            </comment>
            <options>
                <option value="0" name="disable"/>
                <option value="1" name="enable"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Status_KUp" pos="3" access="r" rst="0">
            <comment>Previous Kernel/User mode
            </comment>
            <options>
                <option value="0" name="kernel"/>
                <option value="1" name="user"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Status_IEo" pos="4" access="r" rst="0">
            <comment>Old Interrupt Enable
            </comment>
            <options>
                <option value="0" name="disable"/>
                <option value="1" name="enable"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Status_KUo" pos="5" access="r" rst="0">
            <comment>Old Kernel/User mode
            </comment>
            <options>
                <option value="0" name="kernel"/>
                <option value="1" name="user"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Status_KUi" pos="6" access="r" rst="0">
        </bits>
        <bits name="cp0_Status_IntMask" pos="15:8" access="r" rst="0">
            <comment>Interrupt Mask control the enabling of each of the external and software interrupts. (See Cause for more information on interruptions).
            </comment>
        </bits>
        <bits name="cp0_Streaming_Disable" pos="16" access="r" rst="0">
            <comment>This bit control handling of non-cached instruction fetch requests. By default, the system block reads multiple words of data from the AMBA bus in burst transactions and saves them in the Streaming Buffer. Non cached instruction fetch requests get their data directly from the Streaming Buffer.
            When "1" the cpu does not use the streaming buffer and does not ask for burst requests on the AMBA bus for non-cache instruction fetch requests.
            </comment>
        </bits>
        <bits name="cp0_Status_CM" pos="19" access="r" rst="0">
            <comment>Cache Miss
            <br/>Signals that the most recent access to the cachable space resulted in cache miss.
            </comment>
        </bits>
        <bits name="cp0_Status_TS" pos="21" access="r" rst="0">
            <comment>Signals that 2 entries in the TLB matched the virtual address. This is an error condition but the processor takes no action other than signalling it via this bit in the Status Register.
            </comment>
        </bits>
        <bits name="cp0_Status_BEV" pos="22" access="r" rst="1">
            <comment>Select the location of the exception vectors in ROM or in DRAM.
            </comment>
        </bits>
        <bits name="cp0_Status_RE" pos="25" access="r" rst="0">
            <comment>Reverse Endian in User mode. <font color="red">(probably unused in xcpu)</font></comment>
        </bits>
        <bits name="cp0_Status_CU_0" pos="28" access="r" rst="0" cut="1">
            <comment>Control the Usability of the corresponding Coprocessor Unit. (CP0 is always usable when in Kernel mode, regardless of the setting of the CU_0 bit.
            </comment>
        </bits>
        <bits name="cp0_Status_CU_123" pos="31:29" access="r" rst="0" cut="1" cutprefix="cp0_Status_CU" cutstart="1">
            <comment>Control the Usability of the corresponding Coprocessor Unit.
            </comment>
        </bits>
        <bitgroup name="cp0_Status_CU">
            <entry ref="cp0_Status_CU_0"/>
            <entry ref="cp0_Status_CU_123"/>
        </bitgroup>
    </reg>
    <reg name="cp0_EPC" protect="r">
        <bits name="cp0_EPC" pos="31:0" access="r" rst="0">
            <comment>Exception Program Counter. Saves the value of the program counter for the instruction
                that caused the exception.
            </comment>
        </bits>
    </reg>
    <hole size="160"/>
    <reg name="cp0_BadVAddr" protect="r">
        <bits name="cp0_BadVAddr" pos="31:0" access="r" rst="0">
            <comment>Bad virtual address. Saves the address that caused the address exception.
            </comment>
        </bits>
    </reg>
    <hole size="608"/>
    <reg name="rf0_data" protect="r">
        <bits name="rf0_data" pos="31:0" access="r" rst="0"/>
    </reg>
    <hole size="160"/>
    <reg name="dc0_result" protect="r">
        <bits name="dc0_result" pos="31:0" access="r" rst="0"/>
    </reg>
    <hole size="2848"/>
    
    <hole size="32"/> 

    <reg name="Regfile_AT" protect="r">
        <bits name="AT" pos="31:0" access="r" rst="no">
            <comment>assembler temporary register;
                their values are not preserved across procedure calls.
            </comment>  
        </bits>    
    </reg>
    <reg name="Regfile_V0" protect="r">
        <bits name="V0" pos="31:0" access="r" rst="no">
            <comment>Used for expression evaluations and for hold integer function results.
            <br/> Also used to pass the statuc link when calling nested procedure.
            </comment>
        </bits>    
    </reg>
    <reg name="Regfile_V1" protect="r">
        <bits name="V1" pos="31:0" access="r" rst="no">
            <comment>Used for expression evaluations and for hold integer function results.
            <br/> Also used to pass the statuc link when calling nested procedure.
            </comment>      
        </bits>    
    </reg>
    <reg name="Regfile_A0" protect="r">
        <bits name="A0" pos="31:0" access="r" rst="no">
            <comment>register A0 to A3 is used to pass the first 4 words of integer type actual arguments;
                their values are not preserved across procedure calls.
            </comment>      
        </bits>              
    </reg>
    <reg name="Regfile_A1" protect="r">
        <bits name="A1" pos="31:0" access="r" rst="no">
            <comment>register A0 to A3 is used to pass the first 4 words of integer type actual arguments;
                their values are not preserved across procedure calls.
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_A2" protect="r">
        <bits name="A2" pos="31:0" access="r" rst="no">
            <comment>register A0 to A3 is used to pass the first 4 words of integer type actual arguments;
                their values are not preserved across procedure calls.
            </comment> 
        </bits>              
    </reg>
    <reg name="Regfile_A3" protect="r">
        <bits name="A3" pos="31:0" access="r" rst="no">
            <comment>register A0 to A3 is used to pass the first 4 words of integer type actual arguments;
                their values are not preserved across procedure calls.
            </comment>         
        </bits>              
    </reg>
    <reg name="Regfile_T0" protect="r">
        <bits name="T0" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_T1" protect="r">
        <bits name="T1" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_T2" protect="r">
        <bits name="T2" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_T3" protect="r">
        <bits name="T3" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_T4" protect="r">
        <bits name="T4" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_T5" protect="r">
        <bits name="T5" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_T6" protect="r">
        <bits name="T6" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_T7" protect="r">
        <bits name="T7" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_S0" protect="r">
        <bits name="S0" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_S1" protect="r">
        <bits name="S1" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_S2" protect="r">
        <bits name="S2" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_S3" protect="r">
        <bits name="S3" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_S4" protect="r">
        <bits name="S4" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_S5" protect="r">
        <bits name="S5" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_S6" protect="r">
        <bits name="S6" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_S7" protect="r">
        <bits name="S7" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_T8" protect="r">
        <bits name="T8" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_T9" protect="r">
        <bits name="T9" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_K0" protect="r">
        <bits name="K0" pos="31:0" access="r" rst="no">
            <comment>reserved for the operating system kernal.
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_K1" protect="r">
        <bits name="K1" pos="31:0" access="r" rst="no">
            <comment>reserved for the operating system kernal.
            </comment>         
        </bits>              
    </reg>
    <reg name="Regfile_GP" protect="r">
        <bits name="GP" pos="31:0" access="r" rst="no">
            <comment>contains the global pointer.
            </comment>         
        </bits>              
    </reg>
    <reg name="Regfile_SP" protect="r">
        <bits name="SP" pos="31:0" access="r" rst="no">
            <comment>contains the stack pointer.
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_S8" protect="r">
        <bits name="S8" pos="31:0" access="r" rst="no">
            <comment>a saved register (like s0-s7).
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_RA" protect="r">
        <bits name="RA" pos="31:0" access="r" rst="no">
            <comment>contains the return address; used for expression evaluation.
            </comment>             
        </bits>              
    </reg>
    <hole size="512"/>
    <reg name="Debug_Page_Address" protect="rw">
        <bits name="Debug_Page_Address" pos="3:0" access="rw" rst="0">
            <comment>Debug Page Address Register Is a 4 bit register used for extending the address of
the debug to enable full access to the cache RAMs.
                <br/>bit 3 is used when accessing the TAGs to select between Instruction TAG (0) or Data TAG (1).
            </comment>
            <options>
                <option name="ITag" value="0"/>
                <option name="DTag" value="8"/>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    <reg name="Cache_Control" protect="rw">
        <bits name="Dcache_Inhibit" pos="0" access="rw" rst="no">
            <comment>when "ON" all accesses for data are treated as non cache. Data is fetched directly from main memory. The content of the Data Cache is not altered.
            </comment>
        </bits>
        <bits name="Icache_Inhibit" pos="1" access="rw" rst="no">
            <comment>when "ON" all accesses for instructions are treated as non cache. Data is fetched directly from main memory. The content of the cache is not altered.
            </comment>
        </bits>
        <bits name="Cache Hit Disable" pos="2" access="rw" rst="no">
            <comment>when "ON" all accesses to either Instruction or data caches result in a cache miss and a cache refill. This is a quick way to initialize the caches.
            </comment>
        </bits>
    </reg>
</module>
</archive>
<archive relative = "xcpu_cache.xml">
<module name="xcpu_cache" category="Debug">

    <struct name="Line" count="exp2(8)">
        <reg name="Data" protect="rw" count="4">
        <comment>The XCpu cache is accessible only when it is disabled or the cpu is stalled.
            <br/>The bits "3:0" of the address select the Data in the line.
            <br/>The bits "13:4" of the address select the line.
            <br/>If the Tag at the corresponding line is valid, the bits "25:14" of the tag are the corresponding address bits.
        </comment>
            <bits name="data" pos="31:0" access="rw" rst="0">
            </bits>
        </reg>
    </struct>
</module>
</archive>
<archive relative = "xcpu_pmem.xml">
    <module name="xcpu_pmem" category="System">
        <var name="PMEM_SRAM_SIZE"  value="32768"/>
        <memory name="sram_array" size="PMEM_SRAM_SIZE">
            <comment>XCPU Proxy memory space
            </comment>
        </memory>
    </module>
</archive>
<archive relative = "xcpu_tag.xml">
<module name="xcpu_tag" category="Debug">

    <reg name="Line" protect="rw" count="exp2(8)">
        <comment>The XCpu tags are accessible only when the corresponding cache is disabled or the cpu is stalled.
            <br/>The bits "13:4" of the address select the line
        </comment>
        <bits name="Tag" pos="25:14" access="rw" rst="0">
            <comment>The Tag represents the bits "25:14" of the address present in the corresponding cache Line.
            </comment>
            <options><default/><shift/><mask/></options>
        </bits>
        <bits name="Valid" pos="29" access="rw" rst="0">
            <comment>When 1 the Tag is valid
            </comment>
            <options><default/><shift/><mask/></options>
        </bits>
    </reg>
</module>
</archive>
<archive relative = "xcv.xml" relative = "xcv.xml" >
<module name="xcv_8809z_reg" category="Analog">
    <reg name="revision_id_00H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="rx_gain_settings_01H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="rx_gain_table_enable" pos="17" access="rw" rst="0">
        </bits>
        <bits name="rx_gain_table_pointer" pos="16:14" access="rw" rst="0">
            <comment>rx_gain_table_pointer [2:0]
            </comment>
        </bits>
        <bits name="rx_gain_blocker_cmp" pos="13:10" access="rw" rst="0">
            <comment>rx_gain_blocker_cmp [3:0]
            </comment>
        </bits>
        <bits name="gain1_ct" pos="9:8" access="rw" rst="0">
            <comment>gain1_ct [1:0]
            </comment>
        </bits>
        <bits name="gain2_ct_reg" pos="7:0" access="rw" rst="0">
            <comment>gain2_ct_reg [7:0]
            </comment>
        </bits>
    </reg>
    <reg name="tx_gain_settings_02H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="r2_reserved" pos="17:11" access="rw" rst="0">
            <comment>r2_reserved [6:0]
            </comment>
        </bits>
        <bits name="tx_block_bb_send_data_flag" pos="10" access="rw" rst="0">
        </bits>
        <bits name="digrf_stream_mode_enable" pos="9" access="rw" rst="0">
        </bits>
        <bits name="txlpf_gain_bit" pos="8:0" access="rw" rst="0">
            <comment>txlpf_gain_bit [8:0]
            </comment>
        </bits>
    </reg>
    <reg name="tx_ramp_setting_for_curve_0_03H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:15" access="rw" rst="0">
        </bits>
        <bits name="multi_slot_sel" pos="14:13" access="rw" rst="0">
            <comment>multi_slot_sel [1:0]
            </comment>
        </bits>
        <bits name="ramp_curve_sel_0" pos="12:10" access="rw" rst="0">
            <comment>ramp_curve_sel_0 [2:0]
            </comment>
        </bits>
        <bits name="ramp_mult_factor_0" pos="9:0" access="rw" rst="0">
            <comment>ramp_mult_factor_0 [9:0]
            </comment>
        </bits>
    </reg>
    <reg name="tx_gain_setting_for_slot_0_04H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:5" access="rw" rst="0">
        </bits>
        <bits name="gain3_ct_0" pos="4:0" access="rw" rst="0">
            <comment>gain3_ct_0 [4:0]
            </comment>
        </bits>
    </reg>
    <reg name="rxpll_frequency_setting_05H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="dcdc_1p2_disable" pos="17" access="rw" rst="0">
        </bits>
        <bits name="dcdc_1p2_ldo_disable" pos="16" access="rw" rst="1">
        </bits>
        <bits name="dcdc_2p4_enable" pos="15" access="rw" rst="1">
        </bits>
        <bits name="NC" pos="14" access="rw" rst="1">
        </bits>
        <bits name="freq_synthesize" pos="13:0" access="rw" rst="0">
            <comment>freq_synthesize [31:18]
            </comment>
        </bits>
    </reg>
    <reg name="rxpll_frequency_setting_06H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="freq_synthesize" pos="17:0" access="rw" rst="0">
            <comment>freq_synthesize [17:0]
            </comment>
        </bits>
    </reg>
    <reg name="freq_compensation_register_and_rampdac_settings_07H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="ramp_gain_bit" pos="17:13" access="rw" rst="0">
            <comment>ramp_gain_bit [4:0]
            </comment>
        </bits>
        <bits name="pd_dac_ramp_dr" pos="12" access="rw" rst="0">
        </bits>
        <bits name="ramp_din_dr" pos="11" access="rw" rst="0">
        </bits>
        <bits name="pd_dac_ramp_reg" pos="10" access="rw" rst="0">
        </bits>
        <bits name="ramp_din_reg" pos="9:0" access="rw" rst="0">
            <comment>ramp_din_reg [9:0]
            </comment>
        </bits>
    </reg>
    <reg name="rfrequency_channel_number_08H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="mdll_div_reg" pos="15:14" access="rw" rst="0">
            <comment>mdll_div_reg [1:0]
            </comment>
        </bits>
        <bits name="band_sel" pos="13:12" access="rw" rst="0">
            <comment>band_sel [1:0]
            </comment>
        </bits>
        <bits name="rxon_arfcn" pos="11" access="rw" rst="0">
        </bits>
        <bits name="txon_arfcn" pos="10" access="rw" rst="0">
        </bits>
        <bits name="arfcn" pos="9:0" access="rw" rst="0">
            <comment>arfcn [9:0]
            </comment>
        </bits>
    </reg>
    <reg name="ldo_setting_09H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="xen_dr" pos="17" access="rw" rst="0">
        </bits>
        <bits name="xen_reg" pos="16" access="rw" rst="0">
        </bits>
        <bits name="xen_bt_dr" pos="15" access="rw" rst="0">
        </bits>
        <bits name="xen_bt_reg" pos="14" access="rw" rst="0">
        </bits>
        <bits name="resrved" pos="13:10" access="rw" rst="0">
            <comment>resrved [3:0]
            </comment>
        </bits>
        <bits name="test_bit" pos="9:8" access="rw" rst="0">
            <comment>test_bit [1:0]
            </comment>
        </bits>
        <bits name="ldo_adc_vbit" pos="7:5" access="rw" rst="0">
            <comment>ldo_adc_vbit [2:0]
            </comment>
        </bits>
        <bits name="ldo_adc_bypass" pos="4" access="rw" rst="0">
        </bits>
        <bits name="ldo_xtal_vbit" pos="3:1" access="rw" rst="0">
            <comment>ldo_xtal_vbit [2:0]
            </comment>
        </bits>
        <bits name="ldo_xtal_bypass" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="calibration_result_of_tuning_and_filter_0AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:1" access="rw" rst="0">
        </bits>
        <bits name="pdn_arfcn" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="calibration_result_of_mixer_and_filter_0BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0">
        </bits>
        <bits name="filter_dac2_bit_dr" pos="16" access="rw" rst="0">
        </bits>
        <bits name="filter_dac2_bit_i_reg" pos="15:8" access="rw" rst="0">
            <comment>filter_dac2_bit_i_reg [7:0]
            </comment>
        </bits>
        <bits name="filter_dac2_bit_q_reg" pos="7:0" access="rw" rst="0">
            <comment>filter_dac2_bit_q_reg [7:0]
            </comment>
        </bits>
    </reg>
    <reg name="rxpll_vco_calibration_0CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0">
        </bits>
        <bits name="rfvco_vcom_var_bit" pos="16:14" access="rw" rst="0">
            <comment>rfvco_vcom_var_bit [2:0]
            </comment>
        </bits>
        <bits name="rfvco_bit_dr" pos="13" access="rw" rst="0">
        </bits>
        <bits name="rfvco_bit_reg" pos="12:0" access="rw" rst="0">
            <comment>rfvco_bit_reg [12:0]
            </comment>
        </bits>
    </reg>
    <reg name="calibration_bits_0DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:8" access="rw" rst="0">
            <comment>reserved [9:0]
            </comment>
        </bits>
        <bits name="adc_digi_pwr_bit_dr" pos="7" access="rw" rst="0">
        </bits>
        <bits name="adc_cal_refi_bit_dr" pos="6" access="rw" rst="0">
        </bits>
        <bits name="adc_digi_pwr_bit_reg" pos="5:3" access="rw" rst="0">
            <comment>adc_digi_pwr_bit_reg [2:0]
            </comment>
        </bits>
        <bits name="adc_cal_refi_bit_reg" pos="2:0" access="rw" rst="0">
            <comment>adc_cal_refi_bit_reg [2:0]
            </comment>
        </bits>
    </reg>
    <reg name="rxpll_settings_0EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="thermo_4bit_3_dr" pos="17" access="rw" rst="0">
        </bits>
        <bits name="thermo_4bit_3_reg" pos="16:13" access="rw" rst="0">
            <comment>thermo_4bit_3_reg [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_1_dr" pos="12" access="rw" rst="0">
        </bits>
        <bits name="thermo_7bit_1_dr" pos="11" access="rw" rst="0">
        </bits>
        <bits name="thermo_4bit_1_reg" pos="10:7" access="rw" rst="0">
            <comment>thermo_4bit_1_reg [3:0]
            </comment>
        </bits>
        <bits name="thermo_7bit_1_reg" pos="6:0" access="rw" rst="0">
            <comment>thermo_7bit_1_reg [6:0]
            </comment>
        </bits>
    </reg>
    <reg name="rxpll_setting_0FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="rfvco_varcom_bit" pos="17:16" access="rw" rst="0">
            <comment>rfvco_varcom_bit [1:0]
            </comment>
        </bits>
        <bits name="rxpll_lpf_gain" pos="15:12" access="rw" rst="0">
            <comment>rxpll_lpf_gain [3:0]
            </comment>
        </bits>
        <bits name="rxpll_sink_mode" pos="11:9" access="rw" rst="0">
            <comment>rxpll_sink_mode [2:0]
            </comment>
        </bits>
        <bits name="reserved" pos="8:4" access="rw" rst="0">
            <comment>reserved [4:0]
            </comment>
        </bits>
        <bits name="vco_txbuf_en_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="vco_txbuf_en_reg" pos="2" access="rw" rst="0">
        </bits>
        <bits name="band_sel_vco_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="band_sel_vco_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="rxpll_settings_10H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="rxpll_lock" pos="17" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="16" access="rw" rst="0">
        </bits>
        <bits name="rxpll_reg_digi_bit" pos="15:12" access="rw" rst="0">
            <comment>rxpll_reg_digi_bit [3:0]
            </comment>
        </bits>
        <bits name="rxpll_reg_flt_bit" pos="11:8" access="rw" rst="0">
            <comment>rxpll_reg_flt_bit [3:0]
            </comment>
        </bits>
        <bits name="rxpll_reg_div2_bit" pos="7:4" access="rw" rst="0">
            <comment>rxpll_reg_div2_bit [3:0]
            </comment>
        </bits>
        <bits name="rxpll_reg_presc_bit" pos="3:0" access="rw" rst="0">
            <comment>rxpll_reg_presc_bit [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="rxpll_settings_11H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="rxpll_refmulti2_en" pos="17" access="rw" rst="0">
        </bits>
        <bits name="rxpll_cal_clk_sel" pos="16" access="rw" rst="0">
        </bits>
        <bits name="rxpll_open_en" pos="15" access="rw" rst="0">
        </bits>
        <bits name="rxpll_xfer_aux_en" pos="14" access="rw" rst="0">
        </bits>
        <bits name="rxpll_bypass_notch" pos="13" access="rw" rst="0">
        </bits>
        <bits name="rxpll_pfd_res_bit" pos="12:7" access="rw" rst="0">
            <comment>rxpll_pfd_res_bit [5:0]
            </comment>
        </bits>
        <bits name="rxpll_phase_ctrl_dly" pos="6:5" access="rw" rst="0">
            <comment>rxpll_phase_ctrl_dly [1:0]
            </comment>
        </bits>
        <bits name="rxpll_fbc_sel" pos="4:2" access="rw" rst="0">
            <comment>rxpll_fbc_sel [2:0]
            </comment>
        </bits>
        <bits name="rxpll_cal_bit" pos="1:0" access="rw" rst="0">
            <comment>rxpll_cal_bit [1:0]
            </comment>
        </bits>
    </reg>
    <reg name="rxpll_settings_12H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="filter_cal1_enable" pos="17" access="rw" rst="0">
        </bits>
        <bits name="filter_tuning_bit" pos="16:13" access="rw" rst="0">
            <comment>filter_tuning_bit [3:0]
            </comment>
        </bits>
        <bits name="filter_ctrl_bit" pos="12:0" access="rw" rst="0">
            <comment>filter_ctrl_bit [12:0]
            </comment>
        </bits>
    </reg>
    <reg name="rxpll_settings_13H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="diag_dac_sine" pos="17" access="rw" rst="0">
        </bits>
        <bits name="iq_swap" pos="16" access="rw" rst="0">
        </bits>
        <bits name="ctrl_ext" pos="15:0" access="rw" rst="0">
            <comment>ctrl_ext [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="rxpll_settings_14H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="dac_mux_en" pos="17:16" access="rw" rst="0">
            <comment>dac_mux_en [1:0]
            </comment>
        </bits>
        <bits name="dac_core_bit" pos="15:13" access="rw" rst="0">
            <comment>dac_core_bit [2:0]
            </comment>
        </bits>
        <bits name="dac_iout_enable" pos="12" access="rw" rst="0">
        </bits>
        <bits name="dac_vtr_sel" pos="11" access="rw" rst="0">
        </bits>
        <bits name="dac_cm_bit" pos="10:9" access="rw" rst="0">
            <comment>dac_cm_bit [1:0]
            </comment>
        </bits>
        <bits name="dac_range_bit" pos="8:7" access="rw" rst="0">
            <comment>dac_range_bit [1:0]
            </comment>
        </bits>
        <bits name="dac_bias_sel" pos="6:4" access="rw" rst="0">
            <comment>dac_bias_sel [2:0]
            </comment>
        </bits>
        <bits name="aux_dac_out_enable" pos="3" access="rw" rst="0">
        </bits>
        <bits name="dac_low_bit" pos="2:0" access="rw" rst="0">
            <comment>dac_low_bit [2:0]
            </comment>
        </bits>
    </reg>
    <reg name="rxpll_settings_15H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="former_fifo_en" pos="17" access="rw" rst="0">
        </bits>
        <bits name="former_dem_inv" pos="16" access="rw" rst="0">
        </bits>
        <bits name="former_ctsample" pos="15:12" access="rw" rst="0">
            <comment>former_ctsample [3:0]
            </comment>
        </bits>
        <bits name="former_start_th" pos="11:6" access="rw" rst="0">
            <comment>former_start_th [5:0]
            </comment>
        </bits>
        <bits name="former_clk_edge" pos="5" access="rw" rst="0">
        </bits>
        <bits name="former_wt_ct" pos="4:1" access="rw" rst="0">
            <comment>former_wt_ct [3:0]
            </comment>
        </bits>
        <bits name="dc_out_en" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="analog_mode_settings_16H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="pll_resgister_pointer_dr" pos="17" access="rw" rst="0">
        </bits>
        <bits name="pll_register_pointer_reg" pos="16:15" access="rw" rst="0">
            <comment>pll_register_pointer_reg [1:0]
            </comment>
        </bits>
        <bits name="sdm_clk_sel_pll_cal_en" pos="14" access="rw" rst="0">
        </bits>
        <bits name="sdm_clk_sel_pll_cal_nen" pos="13" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="12:11" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
        <bits name="filter_cal_mode" pos="10" access="rw" rst="0">
        </bits>
        <bits name="filter_rstn_dr" pos="9" access="rw" rst="0">
        </bits>
        <bits name="div_grp_highband_dr" pos="8" access="rw" rst="0">
        </bits>
        <bits name="imgrej_dsp_dr" pos="7" access="rw" rst="0">
        </bits>
        <bits name="filter_lp_mode_dr" pos="6" access="rw" rst="0">
        </bits>
        <bits name="filter_if200k_mode_dr" pos="5" access="rw" rst="0">
        </bits>
        <bits name="filter_rstn_reg" pos="4" access="rw" rst="0">
        </bits>
        <bits name="div_grp_highband_reg" pos="3" access="rw" rst="0">
        </bits>
        <bits name="imgrej_dsp_reg" pos="2" access="rw" rst="0">
        </bits>
        <bits name="filter_lp_mode_reg" pos="1" access="rw" rst="0">
        </bits>
        <bits name="filter_if200k_mode_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="rx_path_settings_17H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="adc_reset_dr" pos="17" access="rw" rst="0">
        </bits>
        <bits name="adc_reset_reg" pos="16" access="rw" rst="0">
        </bits>
        <bits name="adc_reset_mode" pos="15:14" access="rw" rst="0">
            <comment>adc_reset_mode [1:0]
            </comment>
        </bits>
        <bits name="adc_iq_swap" pos="13" access="rw" rst="0">
        </bits>
        <bits name="adc_isel" pos="12:11" access="rw" rst="0">
            <comment>adc_isel [1:0]
            </comment>
        </bits>
        <bits name="reserved" pos="10" access="rw" rst="0">
        </bits>
        <bits name="dac_rstn_time_sel" pos="9:8" access="rw" rst="0">
            <comment>dac_rstn_time_sel [1:0]
            </comment>
        </bits>
        <bits name="pd_dac" pos="7" access="rw" rst="0">
        </bits>
        <bits name="dac_rstn_dr" pos="6" access="rw" rst="0">
        </bits>
        <bits name="dac_rstn_reg" pos="5" access="rw" rst="0">
        </bits>
        <bits name="thermo_4bit_2_dr" pos="4" access="rw" rst="0">
        </bits>
        <bits name="thermo_4bit_2_reg" pos="3:0" access="rw" rst="0">
            <comment>thermo_4bit_2_reg [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="adc_settings_18H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="adc_reset_dsp" pos="15" access="rw" rst="0">
        </bits>
        <bits name="timer_sel_dsp_reset_ms" pos="14:13" access="rw" rst="0">
            <comment>timer_sel_dsp_reset_ms [1:0]
            </comment>
        </bits>
        <bits name="timer_filter_rstn_sel" pos="12:11" access="rw" rst="0">
            <comment>timer_filter_rstn_sel [1:0]
            </comment>
        </bits>
        <bits name="Dc_calib_sel_rg" pos="10" access="rw" rst="1">
        </bits>
        <bits name="Rx_delta_ld_st_i" pos="9" access="rw" rst="0">
        </bits>
        <bits name="reset_adc_delay" pos="8:0" access="rw" rst="0">
            <comment>reset_adc_delay [8:0]
            </comment>
        </bits>
    </reg>
    <reg name="dac_crystal_setting_19H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="cap_bank_bit_nor" pos="17:10" access="rw" rst="0">
            <comment>cap_bank_bit_nor [7:0]
            </comment>
        </bits>
        <bits name="osc_cfix_nor" pos="9" access="rw" rst="0">
        </bits>
        <bits name="ibit_xosc_nor" pos="8:5" access="rw" rst="0">
            <comment>ibit_xosc_nor [3:0]
            </comment>
        </bits>
        <bits name="fix_ibit_xosc_nor" pos="4:0" access="rw" rst="0">
            <comment>fix_ibit_xosc_nor [4:0]
            </comment>
        </bits>
    </reg>
    <reg name="crystal_setting_1AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="xdrv_aux_sw_bit" pos="17:16" access="rw" rst="0">
            <comment>xdrv_aux_sw_bit [1:0]
            </comment>
        </bits>
        <bits name="xdrv_aux_sw_bypass" pos="15" access="rw" rst="0">
        </bits>
        <bits name="xdrv_aux_reg_bit" pos="14:12" access="rw" rst="0">
            <comment>xdrv_aux_reg_bit [2:0]
            </comment>
        </bits>
        <bits name="xdrv_aux_step_en" pos="11:8" access="rw" rst="0">
            <comment>xdrv_aux_step_en [3:0]
            </comment>
        </bits>
        <bits name="reserved" pos="7" access="rw" rst="0">
        </bits>
        <bits name="xtal_rdac_hlsel" pos="6:5" access="rw" rst="0">
            <comment>xtal_rdac_hlsel [1:0]
            </comment>
        </bits>
        <bits name="xtal_reserved" pos="4:3" access="rw" rst="0">
            <comment>xtal_reserved [1:0]
            </comment>
        </bits>
        <bits name="xtal_reg_bit" pos="2:0" access="rw" rst="0">
            <comment>xtal_reg_bit [2:0]
            </comment>
        </bits>
    </reg>
    <reg name="crystal_xdrv_setting_1BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="thmt_dac_ref" pos="17:16" access="rw" rst="0">
            <comment>thmt_dac_ref [1:0]
            </comment>
        </bits>
        <bits name="thmt_gain" pos="15:14" access="rw" rst="0">
            <comment>thmt_gain [1:0]
            </comment>
        </bits>
        <bits name="pkdtc_en_dr" pos="13" access="rw" rst="0">
        </bits>
        <bits name="pkdtc_en_reg" pos="12" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="11:10" access="rw" rst="0">
            <comment>reserved [2:1]
            </comment>
        </bits>
        <bits name="clk26m_adc_enable_dr" pos="9" access="rw" rst="0">
        </bits>
        <bits name="clk26m_adc_enable_reg" pos="8" access="rw" rst="0">
        </bits>
        <bits name="clk26m_dsp_enable_dr" pos="7" access="rw" rst="0">
        </bits>
        <bits name="clk26m_dsp_enable_reg" pos="6" access="rw" rst="0">
        </bits>
        <bits name="clk26m_intf_enable_dr" pos="5" access="rw" rst="0">
        </bits>
        <bits name="clk26m_intf_enable_reg" pos="4" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="3" access="rw" rst="0">
        </bits>
        <bits name="clk26m_pkd_enable" pos="2" access="rw" rst="0">
        </bits>
        <bits name="clk26m_pll_enable_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="clk26m_pll_enable_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="thermometer_calibration_result_1CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="thmt_curr_sw" pos="17" access="rw" rst="0">
        </bits>
        <bits name="thmt_ptat_var" pos="16:13" access="rw" rst="0">
            <comment>thmt_ptat_var [3:0]
            </comment>
        </bits>
        <bits name="thermo_pulse_restrain_ct" pos="12:11" access="rw" rst="0">
            <comment>thermo_pulse_restrain_ct [1:0]
            </comment>
        </bits>
        <bits name="thermo_cal_cnt" pos="10:7" access="rw" rst="0">
            <comment>thermo_cal_cnt [3:0]
            </comment>
        </bits>
        <bits name="thermo_cal_bit_dr" pos="6" access="rw" rst="0">
        </bits>
        <bits name="thermo_cal_bit_reg" pos="5:0" access="rw" rst="0">
            <comment>thermo_cal_bit_reg [5:0]
            </comment>
        </bits>
    </reg>
    <reg name="vga_settings_1DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="agc_table_reg" pos="17:0" access="rw" rst="0">
            <comment>agc_table_reg [17:0]
            </comment>
        </bits>
    </reg>
    <reg name="tx_path_settings_1EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved_dsp" pos="17:0" access="rw" rst="0">
            <comment>reserved_dsp [17:0]
            </comment>
        </bits>
    </reg>
    <reg name="bgap_afc_setting_1FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
            <comment>reserved [3:0]
            </comment>
        </bits>
        <bits name="digi_afc_bit" pos="13:0" access="rw" rst="0">
            <comment>digi_afc_bit [13:0]
            </comment>
        </bits>
    </reg>
    <reg name="digital_power_20H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="pu_xtal_dr" pos="17" access="rw" rst="0">
        </bits>
        <bits name="pu_xtal_reg" pos="16" access="rw" rst="0">
        </bits>
        <bits name="pd_mdll_dr" pos="15" access="rw" rst="0">
        </bits>
        <bits name="pd_mdll_reg" pos="14" access="rw" rst="0">
        </bits>
        <bits name="pd_padrv_dr" pos="13" access="rw" rst="0">
        </bits>
        <bits name="pd_padrv_reg" pos="12" access="rw" rst="0">
        </bits>
        <bits name="sel_bg" pos="11" access="rw" rst="0">
        </bits>
        <bits name="digital_power_lp_en" pos="10" access="rw" rst="0">
        </bits>
        <bits name="digital_power_lp_mode" pos="9" access="rw" rst="0">
        </bits>
        <bits name="digital_power_test_en" pos="8" access="rw" rst="0">
        </bits>
        <bits name="digital_power_iref_bit" pos="7:5" access="rw" rst="0">
            <comment>digital_power_iref_bit [2:0]
            </comment>
        </bits>
        <bits name="dvdd_ref_dsp" pos="4:2" access="rw" rst="0">
            <comment>dvdd_ref_dsp [2:0]
            </comment>
        </bits>
        <bits name="pd_digital_power_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="pd_digital_power_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="ldo_registers_21H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="pd_ldo_dr" pos="17" access="rw" rst="0">
        </bits>
        <bits name="pd_ldo_reg" pos="16" access="rw" rst="0">
        </bits>
        <bits name="ldo_ana_vbit" pos="15:13" access="rw" rst="0">
            <comment>ldo_ana_vbit [2:0]
            </comment>
        </bits>
        <bits name="ldo_ana_bypass" pos="12" access="rw" rst="0">
        </bits>
        <bits name="ldo_vco_vbit" pos="11:9" access="rw" rst="0">
            <comment>ldo_vco_vbit [2:0]
            </comment>
        </bits>
        <bits name="ldo_vco_bypass" pos="8" access="rw" rst="0">
        </bits>
        <bits name="ldo_padrv_vbit" pos="7:5" access="rw" rst="0">
            <comment>ldo_padrv_vbit [2:0]
            </comment>
        </bits>
        <bits name="ldo_padrv_bypass" pos="4" access="rw" rst="0">
        </bits>
        <bits name="ldo_pdt_vbit" pos="3:1" access="rw" rst="0">
            <comment>ldo_pdt_vbit [2:0]
            </comment>
        </bits>
        <bits name="ldo_pdt_bypass" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="ldo_pd_setting_22H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:7" access="rw" rst="0">
            <comment>reserved [10:0]
            </comment>
        </bits>
        <bits name="pd_rxvco_txbuf" pos="6" access="rw" rst="0">
        </bits>
        <bits name="pd_rxvco_rxbuf" pos="5" access="rw" rst="0">
        </bits>
        <bits name="pd_rxvco" pos="4" access="rw" rst="0">
        </bits>
        <bits name="pd_rxpll_presc" pos="3" access="rw" rst="0">
        </bits>
        <bits name="pd_rxpll_peri" pos="2" access="rw" rst="0">
        </bits>
        <bits name="pd_rxpll_gro" pos="1" access="rw" rst="0">
        </bits>
        <bits name="pd_rxpll_rdac" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="pd_settings_23H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="pd_lna_grp" pos="17" access="rw" rst="0">
        </bits>
        <bits name="sel_lna850" pos="16" access="rw" rst="0">
        </bits>
        <bits name="sel_lna900" pos="15" access="rw" rst="0">
        </bits>
        <bits name="sel_lna1800" pos="14" access="rw" rst="0">
        </bits>
        <bits name="sel_lna1900" pos="13" access="rw" rst="0">
        </bits>
        <bits name="sel_lna_single_lb" pos="12" access="rw" rst="0">
        </bits>
        <bits name="sel_lna_single_hb" pos="11" access="rw" rst="0">
        </bits>
        <bits name="pd_mixer_grp" pos="10" access="rw" rst="0">
        </bits>
        <bits name="sel_mixer_l" pos="9" access="rw" rst="0">
        </bits>
        <bits name="sel_mixer_h" pos="8" access="rw" rst="0">
        </bits>
        <bits name="pd_filter" pos="7" access="rw" rst="0">
        </bits>
        <bits name="pd_adc" pos="6" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="5:2" access="rw" rst="0">
            <comment>reserved [3:0]
            </comment>
        </bits>
        <bits name="pd_bgiverf" pos="1" access="rw" rst="0">
        </bits>
        <bits name="pd_thermo" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="timer_gpio_setting_24H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="timer_txpower_start_delay" pos="17:16" access="rw" rst="0">
            <comment>timer_txpower_start_delay [1:0]
            </comment>
        </bits>
        <bits name="rx_wait_pll_stable_timer_on" pos="15" access="rw" rst="0">
        </bits>
        <bits name="tx_wait_pll_stable_timer_on" pos="14" access="rw" rst="0">
        </bits>
        <bits name="rx_wait_pll_stable_timer" pos="13:12" access="rw" rst="0">
            <comment>rx_wait_pll_stable_timer [1:0]
            </comment>
        </bits>
        <bits name="tx_wait_pll_stable_timer" pos="11:10" access="rw" rst="0">
            <comment>tx_wait_pll_stable_timer [1:0]
            </comment>
        </bits>
        <bits name="reserved" pos="9:7" access="rw" rst="0">
            <comment>reserved [2:0]
            </comment>
        </bits>
        <bits name="aux_buf_delay" pos="6" access="rw" rst="0">
        </bits>
        <bits name="gpio_auxclk_en_dr" pos="5" access="rw" rst="0">
        </bits>
        <bits name="gpio_auxclk_en_reg" pos="4" access="rw" rst="0">
        </bits>
        <bits name="gpio_paon_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="timer_vga_on_over_dr" pos="2" access="rw" rst="0">
        </bits>
        <bits name="gpio_paon_reg" pos="1" access="rw" rst="0">
        </bits>
        <bits name="timer_vga_on_ower_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="sdm_settings_25H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="former_clk_edge_sdm" pos="17" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="16:15" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
        <bits name="tri_wave_bypass" pos="14" access="rw" rst="0">
        </bits>
        <bits name="tri_wave_step" pos="13:12" access="rw" rst="0">
            <comment>tri_wave_step [1:0]
            </comment>
        </bits>
        <bits name="int_dec_sel" pos="11:10" access="rw" rst="0">
            <comment>int_dec_sel [1:0]
            </comment>
        </bits>
        <bits name="offset_enable" pos="9" access="rw" rst="0">
        </bits>
        <bits name="square_wave_in" pos="8" access="rw" rst="0">
        </bits>
        <bits name="nphase" pos="7:4" access="rw" rst="0">
            <comment>nphase [3:0]
            </comment>
        </bits>
        <bits name="offset_select_wave" pos="3:1" access="rw" rst="0">
            <comment>offset_select_wave [2:0]
            </comment>
        </bits>
        <bits name="shift_more" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="sdm_settings_26H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="mdll_dither_en" pos="17" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="16:12" access="rw" rst="0">
            <comment>reserved [4:0]
            </comment>
        </bits>
        <bits name="dither_bypass" pos="11" access="rw" rst="0">
        </bits>
        <bits name="former_bypass_dr" pos="10" access="rw" rst="0">
        </bits>
        <bits name="sdm_resetn_dr" pos="9" access="rw" rst="0">
        </bits>
        <bits name="resetn_dsp_dr" pos="8" access="rw" rst="0">
        </bits>
        <bits name="tx_rx_dr" pos="7" access="rw" rst="0">
        </bits>
        <bits name="if_mode_dr" pos="6" access="rw" rst="0">
        </bits>
        <bits name="former_bypass_reg" pos="5" access="rw" rst="0">
        </bits>
        <bits name="sdm_resetn_reg" pos="4" access="rw" rst="0">
        </bits>
        <bits name="resetn_dsp_reg" pos="3" access="rw" rst="0">
        </bits>
        <bits name="tx_rx_reg" pos="2" access="rw" rst="0">
        </bits>
        <bits name="if_mode_reg" pos="1:0" access="rw" rst="0">
            <comment>if_mode_reg [1:0]
            </comment>
        </bits>
    </reg>
    <reg name="sdm_settings_27H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="mdll_dither_mode" pos="17" access="rw" rst="0">
        </bits>
        <bits name="mdll_dihter_bit" pos="16:14" access="rw" rst="0">
            <comment>mdll_dihter_bit [2:0]
            </comment>
        </bits>
        <bits name="mdll_cp_ibit" pos="13:11" access="rw" rst="0">
            <comment>mdll_cp_ibit [2:0]
            </comment>
        </bits>
        <bits name="mdll_startup_v" pos="10:8" access="rw" rst="0">
            <comment>mdll_startup_v [2:0]
            </comment>
        </bits>
        <bits name="mdll_vctrl_test_en" pos="7" access="rw" rst="0">
        </bits>
        <bits name="mdll_band_sel_dr" pos="6" access="rw" rst="0">
        </bits>
        <bits name="mdll_band_sel_reg" pos="5" access="rw" rst="0">
        </bits>
        <bits name="mdll_band_dr" pos="4" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="3" access="rw" rst="0">
        </bits>
        <bits name="mdll_band_reg" pos="2:0" access="rw" rst="0">
            <comment>mdll_band_reg [2:0]
            </comment>
        </bits>
    </reg>
    <reg name="sdm_settings_28H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="dec_numerator" pos="17:15" access="rw" rst="0">
            <comment>dec_numerator [2:0]
            </comment>
        </bits>
        <bits name="edge_polar_mode" pos="14" access="rw" rst="0">
        </bits>
        <bits name="pn9_en" pos="13" access="rw" rst="0">
        </bits>
        <bits name="dac_fix_en" pos="12" access="rw" rst="0">
        </bits>
        <bits name="dac_fix" pos="11:0" access="rw" rst="0">
            <comment>dac_fix [11:0]
            </comment>
        </bits>
    </reg>
    <reg name="dsp_setting_29H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="lpfil_bypass" pos="17" access="rw" rst="0">
        </bits>
        <bits name="dccancel1_bypass" pos="16" access="rw" rst="0">
        </bits>
        <bits name="dccancel2_bypass" pos="15" access="rw" rst="0">
        </bits>
        <bits name="compfil_mode" pos="14" access="rw" rst="0">
        </bits>
        <bits name="bw_sel" pos="13:11" access="rw" rst="0">
            <comment>bw_sel [2:0]
            </comment>
        </bits>
        <bits name="gain2_delay_bypass" pos="10" access="rw" rst="0">
        </bits>
        <bits name="gain2_delay_ct" pos="9:4" access="rw" rst="0">
            <comment>gain2_delay_ct [5:0]
            </comment>
        </bits>
        <bits name="ts_mode" pos="3:0" access="rw" rst="0">
            <comment>ts_mode [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="ramp_setting_for_slot_1_2AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="gain3_ct_1" pos="17:13" access="rw" rst="0">
            <comment>gain3_ct_1 [4:0]
            </comment>
        </bits>
        <bits name="ramp_curve_sel_1" pos="12:10" access="rw" rst="0">
            <comment>ramp_curve_sel_1 [2:0]
            </comment>
        </bits>
        <bits name="ramp_mult_factor_1" pos="9:0" access="rw" rst="0">
            <comment>ramp_mult_factor_1 [9:0]
            </comment>
        </bits>
    </reg>
    <reg name="tx_gain_setting_for_slot_1_2BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="rmx_offset_range_bit" pos="17:16" access="rw" rst="0">
            <comment>rmx_offset_range_bit [1:0]
            </comment>
        </bits>
        <bits name="Filter_lpwr_enb" pos="15" access="rw" rst="0">
        </bits>
        <bits name="pga_bw_cbit" pos="14:13" access="rw" rst="0">
            <comment>pga_bw_cbit [1:0]
            </comment>
        </bits>
        <bits name="pga_bw_rbit" pos="12:11" access="rw" rst="0">
            <comment>pga_bw_rbit [1:0]
            </comment>
        </bits>
        <bits name="pga_ctrl_bit" pos="10:0" access="rw" rst="0">
            <comment>pga_ctrl_bit [10:0]
            </comment>
        </bits>
    </reg>
    <reg name="ramp_setting_for_slot_2_2CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="gain3_ct_2" pos="17:13" access="rw" rst="0">
            <comment>gain3_ct_2 [4:0]
            </comment>
        </bits>
        <bits name="ramp_curve_sel_2" pos="12:10" access="rw" rst="0">
            <comment>ramp_curve_sel_2 [2:0]
            </comment>
        </bits>
        <bits name="ramp_mult_factor_2" pos="9:0" access="rw" rst="0">
            <comment>ramp_mult_factor_2 [9:0]
            </comment>
        </bits>
    </reg>
    <reg name="tx_gain_setting_for_slot_2_2DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="lna_i_bit" pos="17:15" access="rw" rst="0">
            <comment>lna_i_bit [2:0]
            </comment>
        </bits>
        <bits name="lna_freq_lb" pos="14:12" access="rw" rst="0">
            <comment>lna_freq_lb [2:0]
            </comment>
        </bits>
        <bits name="lna_freq_hb" pos="11:9" access="rw" rst="0">
            <comment>lna_freq_hb [2:0]
            </comment>
        </bits>
        <bits name="lna_ctrl_bit" pos="8" access="rw" rst="0">
        </bits>
        <bits name="lna_notch_lband_dr" pos="7" access="rw" rst="0">
        </bits>
        <bits name="lna_notch_lband_reg" pos="6" access="rw" rst="0">
        </bits>
        <bits name="lna_notch_hband_dr" pos="5" access="rw" rst="0">
        </bits>
        <bits name="lna_notch_hband_reg" pos="4" access="rw" rst="0">
        </bits>
        <bits name="lna_powdet_lband_en_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="lna_powdet_lband_en_reg" pos="2" access="rw" rst="0">
        </bits>
        <bits name="lna_powdet_hband_en_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="lna_powdet_hband_en_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="dsp_setting_2EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="dll_mode_dr" pos="17" access="rw" rst="0">
        </bits>
        <bits name="dll_mode_reg" pos="16:15" access="rw" rst="0">
            <comment>dll_mode_reg [1:0]
            </comment>
        </bits>
        <bits name="mdll_startup_dr" pos="14" access="rw" rst="0">
        </bits>
        <bits name="mdll_startup_reg" pos="13" access="rw" rst="0">
        </bits>
        <bits name="pga_op_ibit" pos="12:11" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
        <bits name="mdll_on_xen_bt" pos="10" access="rw" rst="0">
        </bits>
        <bits name="mdll_startup_delay" pos="9:8" access="rw" rst="0">
            <comment>mdll_startup_delay [1:0]
            </comment>
        </bits>
        <bits name="reserved_sdm" pos="7:0" access="rw" rst="0">
            <comment>reserved_sdm [7:0]
            </comment>
        </bits>
    </reg>
    <reg name="misc_2FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="mixer_power_psr_en" pos="17" access="rw" rst="0">
        </bits>
        <bits name="mixer_power_ana_en" pos="16" access="rw" rst="0">
        </bits>
        <bits name="reserved_analog" pos="15:0" access="rw" rst="0">
            <comment>reserved_analog [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="system_control_setting_30H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="single_lna_mode" pos="17" access="rw" rst="0">
        </bits>
        <bits name="rx_blocker_mode_dr" pos="16" access="rw" rst="0">
        </bits>
        <bits name="rx_blocker_mode_reg" pos="15" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="14:13" access="rw" rst="0">
            <comment>reserved [2:0]
            </comment>
        </bits>
        <bits name="Direct_reg_thero" pos="12" access="rw" rst="0">
        </bits>
        <bits name="digrf_test_en" pos="11" access="rw" rst="0">
        </bits>
        <bits name="gsm_mode" pos="10" access="rw" rst="0">
        </bits>
        <bits name="digrf_enable" pos="9" access="rw" rst="0">
        </bits>
        <bits name="zf_mode" pos="8" access="rw" rst="0">
        </bits>
        <bits name="if_200k_mode" pos="7" access="rw" rst="0">
        </bits>
        <bits name="freq_mode" pos="6" access="rw" rst="0">
        </bits>
        <bits name="direct_reg" pos="5" access="rw" rst="0">
        </bits>
        <bits name="mdll_keep_on" pos="4" access="rw" rst="0">
        </bits>
        <bits name="imgrej" pos="3" access="rw" rst="0">
        </bits>
        <bits name="mdll_div_dr" pos="2" access="rw" rst="0">
        </bits>
        <bits name="chip_self_cal_enable" pos="1" access="rw" rst="0">
        </bits>
        <bits name="soft_resetn" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="equfil_setting_31H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="equfil_tx_g_gsm_d8" pos="15:0" access="rw" rst="0">
            <comment>equfil_tx_g_gsm_d8 [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="equfil_setting_32H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:15" access="rw" rst="0">
        </bits>
        <bits name="reset_dsp_delay" pos="14:7" access="rw" rst="0">
            <comment>reset_dsp_delay [7:0]
            </comment>
        </bits>
        <bits name="reset_sdm_delay" pos="6:0" access="rw" rst="0">
            <comment>reset_sdm_delay [6:0]
            </comment>
        </bits>
    </reg>
    <reg name="equfil_setting_33H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="former_ct_shift_gsm_lb" pos="17:15" access="rw" rst="0">
            <comment>former_ct_shift_gsm_lb [2:0]
            </comment>
        </bits>
        <bits name="former_ct_shift_gsm_hb" pos="14:12" access="rw" rst="0">
            <comment>former_ct_shift_gsm_hb [2:0]
            </comment>
        </bits>
        <bits name="r33_reserved" pos="11:0" access="rw" rst="0">
            <comment>r33_reserved [11:0]
            </comment>
        </bits>
    </reg>
    <reg name="ramp_setting_for_slot_3_34H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="gain3_ct_3" pos="17:13" access="rw" rst="0">
            <comment>gain3_ct_3 [4:0]
            </comment>
        </bits>
        <bits name="ramp_curve_sel_3" pos="12:10" access="rw" rst="0">
            <comment>ramp_curve_sel_3 [2:0]
            </comment>
        </bits>
        <bits name="ramp_mult_factor_3" pos="9:0" access="rw" rst="0">
            <comment>ramp_mult_factor_3 [9:0]
            </comment>
        </bits>
    </reg>
    <reg name="tx_gain_setting_for_slot_3_35H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
        <bits name="freq_comp" pos="15:0" access="rw" rst="0">
            <comment>freq_comp [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="ramp_curve_setting_for_gsm_in_special_use_36H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="dc_cal_one_time" pos="17" access="rw" rst="0">
        </bits>
        <bits name="dc_table_full_mode" pos="16" access="rw" rst="0">
        </bits>
        <bits name="dc_table_pointer_dr" pos="15" access="rw" rst="0">
        </bits>
        <bits name="dc_table_pointer_reg" pos="14:12" access="rw" rst="0">
            <comment>dc_table_pointer_reg [2:0]
            </comment>
        </bits>
        <bits name="reserved" pos="11:4" access="rw" rst="0">
            <comment>reserved [7:0]
            </comment>
        </bits>
        <bits name="time_sel_after_rampd" pos="3:2" access="rw" rst="0">
            <comment>time_sel_after_rampd [1:0]
            </comment>
        </bits>
        <bits name="time_sel_digrf_txen" pos="1:0" access="rw" rst="0">
            <comment>time_sel_digrf_txen [1:0]
            </comment>
        </bits>
    </reg>
    <reg name="tx_block_setting_37H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="slot_number_dr" pos="17" access="rw" rst="0">
        </bits>
        <bits name="slot_number_reg" pos="16:15" access="rw" rst="0">
            <comment>slot_number_reg [1:0]
            </comment>
        </bits>
        <bits name="txclkpolarity" pos="14" access="rw" rst="0">
        </bits>
        <bits name="tx_block_flr" pos="13" access="rw" rst="0">
        </bits>
        <bits name="txdata_out_timer" pos="12:5" access="rw" rst="0">
            <comment>txdata_out_timer [7:0]
            </comment>
        </bits>
        <bits name="slot_length_delta" pos="4:0" access="rw" rst="0">
            <comment>slot_length_delta [4:0]
            </comment>
        </bits>
    </reg>
    <reg name="rx_block_setting_38H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="rxclkpolarity" pos="17" access="rw" rst="0">
        </bits>
        <bits name="rx_delay_counter" pos="16:13" access="rw" rst="0">
            <comment>rx_delay_counter [3:0]
            </comment>
        </bits>
        <bits name="rx_iq_order" pos="12" access="rw" rst="0">
        </bits>
        <bits name="sample_mode" pos="11:10" access="rw" rst="0">
            <comment>sample_mode [1:0]
            </comment>
        </bits>
        <bits name="r38_reserved" pos="9:3" access="rw" rst="0">
            <comment>r38_reserved [6:0]
            </comment>
        </bits>
        <bits name="resetn_rx_data_mode" pos="2:1" access="rw" rst="0">
            <comment>resetn_rx_data_mode [1:0]
            </comment>
        </bits>
        <bits name="resetn_rx_data_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="equfil_parameter_1_39H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="gpio_slew_bit" pos="17:16" access="rw" rst="0">
            <comment>gpio_slew_bit [1:0]
            </comment>
        </bits>
        <bits name="digrf_slew_bit_test" pos="15:14" access="rw" rst="0">
            <comment>digrf_slew_bit_test [1:0]
            </comment>
        </bits>
        <bits name="reserved" pos="13:12" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
        <bits name="gpio_bs_gsm850_rx" pos="11:9" access="rw" rst="0">
            <comment>gpio_bs_gsm850_rx [2:0]
            </comment>
        </bits>
        <bits name="gpio_bs_gsm900_rx" pos="8:6" access="rw" rst="0">
            <comment>gpio_bs_gsm900_rx [2:0]
            </comment>
        </bits>
        <bits name="gpio_bs_dcs1800_rx" pos="5:3" access="rw" rst="0">
            <comment>gpio_bs_dcs1800_rx [2:0]
            </comment>
        </bits>
        <bits name="gpio_bs_pcs1900_rx" pos="2:0" access="rw" rst="0">
            <comment>gpio_bs_pcs1900_rx [2:0]
            </comment>
        </bits>
    </reg>
    <reg name="tx_block_setting_3AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:12" access="rw" rst="0">
            <comment>reserved [5:0]
            </comment>
        </bits>
        <bits name="gpio_bs_gsm850_tx" pos="11:9" access="rw" rst="0">
            <comment>gpio_bs_gsm850_tx [2:0]
            </comment>
        </bits>
        <bits name="gpio_bs_gsm900_tx" pos="8:6" access="rw" rst="0">
            <comment>gpio_bs_gsm900_tx [2:0]
            </comment>
        </bits>
        <bits name="gpio_bs_dcs1800_tx" pos="5:3" access="rw" rst="0">
            <comment>gpio_bs_dcs1800_tx [2:0]
            </comment>
        </bits>
        <bits name="gpio_bs_pcs1900_tx" pos="2:0" access="rw" rst="0">
            <comment>gpio_bs_pcs1900_tx [2:0]
            </comment>
        </bits>
    </reg>
    <reg name="equfil_parameter_2_3BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:11" access="rw" rst="0">
            <comment>reserved [6:0]
            </comment>
        </bits>
        <bits name="dc_ct1" pos="10:0" access="rw" rst="0">
            <comment>dc_ct1 [10:0]
            </comment>
        </bits>
    </reg>
    <reg name="dc_cancel_3CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="ldo_cur_lmt" pos="17:11" access="rw" rst="0">
            <comment>ldo_cur_lmt [6:0]
            </comment>
        </bits>
        <bits name="dc_ct2" pos="10:0" access="rw" rst="0">
            <comment>dc_ct2 [10:0]
            </comment>
        </bits>
    </reg>
    <reg name="pa_ramp_array_program_register_3DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="array_data" pos="17:8" access="rw" rst="0">
        </bits>
        <bits name="array_addr" pos="7:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="tx_timer_control_3EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="switch_on_delay" pos="17:12" access="rw" rst="0">
            <comment>switch_on_delay [5:0]
            </comment>
        </bits>
        <bits name="pa_on_delay" pos="11:6" access="rw" rst="0">
            <comment>pa_on_delay [5:0]
            </comment>
        </bits>
        <bits name="vga_on_delay" pos="5:0" access="rw" rst="0">
            <comment>vga_on_delay [5:0]
            </comment>
        </bits>
    </reg>
    <reg name="page_setting_3FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:3" access="rw" rst="0">
        </bits>
        <bits name="page" pos="2:0" access="rw" rst="0">
            <comment>page [2:0]
            </comment>
        </bits>
    </reg>
    <reg name="page_setting_40H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="rxpll_settings_41H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="rfpll_bit_850" pos="17:10" access="rw" rst="0">
            <comment>rfpll_bit_850 [7:0]
            </comment>
        </bits>
        <bits name="rfpll_r_bit_850" pos="9:8" access="rw" rst="0">
            <comment>rfpll_r_bit_850 [1:0]
            </comment>
        </bits>
        <bits name="rfpll_cp_bit_850" pos="7:4" access="rw" rst="0">
            <comment>rfpll_cp_bit_850 [3:0]
            </comment>
        </bits>
        <bits name="rfpll_vco_gain_bit_850" pos="3:0" access="rw" rst="0">
            <comment>rfpll_vco_gain_bit_850 [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="rxpll_settings_42H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="rfpll_bit_900" pos="17:0" access="rw" rst="0">
            <comment>rfpll_bit_900 [17:0]
            </comment>
        </bits>
    </reg>
    <reg name="rxpll_settings_43H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="rfpll_bit_1800" pos="17:0" access="rw" rst="0">
            <comment>rfpll_bit_1800 [17:0]
            </comment>
        </bits>
    </reg>
    <reg name="rxpll_settings_44H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="rfpll_bit_1900" pos="17:0" access="rw" rst="0">
            <comment>rfpll_bit_1900 [17:0]
            </comment>
        </bits>
    </reg>
    <reg name="rx_gain_settings_45H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="Lna_ibit_0" pos="17" access="rw" rst="1">
        </bits>
        <bits name="Filter_lp_pwr_enb_0" pos="16" access="rw" rst="1">
        </bits>
        <bits name="Pga_op_ibit_0" pos="15" access="rw" rst="1">
        </bits>
        <bits name="Rfvco_buff_ibit_0" pos="14:12" access="rw" rst="010">
        </bits>
        <bits name="lna_gain_bit_0" pos="11:10" access="rw" rst="01">
        </bits>
        <bits name="lna_gain2_bit_0" pos="9:8" access="rw" rst="0">
        </bits>
        <bits name="tia_gain_bit_0" pos="7:6" access="rw" rst="0">
        </bits>
        <bits name="pga_gain_bit_0" pos="5:4" access="rw" rst="0">
        </bits>
        <bits name="filter_gain_bit_0" pos="3:2" access="rw" rst="0">
        </bits>
        <bits name="adc_gain_bit_0" pos="1:0" access="rw" rst="0">
        </bits>
    </reg>

    <reg name="rx_gain_settings_46H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="Lna_ibit_1" pos="17" access="rw" rst="1">
        </bits>
        <bits name="Filter_lp_pwr_enb_1" pos="16" access="rw" rst="1">
        </bits>
        <bits name="Pga_op_ibit_1" pos="15" access="rw" rst="1">
        </bits>
        <bits name="Rfvco_buff_ibit_1" pos="14:12" access="rw" rst="010">
        </bits>
        <bits name="lna_gain_bit_1" pos="11:10" access="rw" rst="01">
        </bits>
        <bits name="lna_gain2_bit_1" pos="9:8" access="rw" rst="0">
        </bits>
        <bits name="tia_gain_bit_1" pos="7:6" access="rw" rst="0">
        </bits>
        <bits name="pga_gain_bit_1" pos="5:4" access="rw" rst="0">
        </bits>
        <bits name="filter_gain_bit_1" pos="3:2" access="rw" rst="0">
        </bits>
        <bits name="adc_gain_bit_1" pos="1:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="rx_gain_settings_47H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="Lna_ibit_2" pos="17" access="rw" rst="1">
        </bits>
        <bits name="Filter_lp_pwr_enb_2" pos="16" access="rw" rst="1">
        </bits>
        <bits name="Pga_op_ibit_2" pos="15" access="rw" rst="1">
        </bits>
        <bits name="Rfvco_buff_ibit_2" pos="14:12" access="rw" rst="010">
        </bits>
        <bits name="lna_gain_bit_2" pos="11:10" access="rw" rst="01">
        </bits>
        <bits name="lna_gain2_bit_2" pos="9:8" access="rw" rst="0">
        </bits>
        <bits name="tia_gain_bit_2" pos="7:6" access="rw" rst="0">
        </bits>
        <bits name="pga_gain_bit_2" pos="5:4" access="rw" rst="0">
        </bits>
        <bits name="filter_gain_bit_2" pos="3:2" access="rw" rst="0">
        </bits>
        <bits name="adc_gain_bit_2" pos="1:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="rx_gain_settings_48H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="Lna_ibit_3" pos="17" access="rw" rst="1">
        </bits>
        <bits name="Filter_lp_pwr_enb_3" pos="16" access="rw" rst="1">
        </bits>
        <bits name="Pga_op_ibit_3" pos="15" access="rw" rst="1">
        </bits>
        <bits name="Rfvco_buff_ibit_3" pos="14:12" access="rw" rst="010">
        </bits>
        <bits name="lna_gain_bit_3" pos="11:10" access="rw" rst="01">
        </bits>
        <bits name="lna_gain2_bit_3" pos="9:8" access="rw" rst="0">
        </bits>
        <bits name="tia_gain_bit_3" pos="7:6" access="rw" rst="0">
        </bits>
        <bits name="pga_gain_bit_3" pos="5:4" access="rw" rst="0">
        </bits>
        <bits name="filter_gain_bit_3" pos="3:2" access="rw" rst="0">
        </bits>
        <bits name="adc_gain_bit_3" pos="1:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="rx_gain_settings_49H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="Lna_ibit_4" pos="17" access="rw" rst="1">
        </bits>
        <bits name="Filter_lp_pwr_enb_4" pos="16" access="rw" rst="1">
        </bits>
        <bits name="Pga_op_ibit_4" pos="15" access="rw" rst="1">
        </bits>
        <bits name="Rfvco_buff_ibit_4" pos="14:12" access="rw" rst="010">
        </bits>
        <bits name="lna_gain_bit_4" pos="11:10" access="rw" rst="01">
        </bits>
        <bits name="lna_gain2_bit_4" pos="9:8" access="rw" rst="0">
        </bits>
        <bits name="tia_gain_bit_4" pos="7:6" access="rw" rst="0">
        </bits>
        <bits name="pga_gain_bit_4" pos="5:4" access="rw" rst="0">
        </bits>
        <bits name="filter_gain_bit_4" pos="3:2" access="rw" rst="0">
        </bits>
        <bits name="adc_gain_bit_4" pos="1:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="rx_gain_settings_4AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="Lna_ibit_5" pos="17" access="rw" rst="1">
        </bits>
        <bits name="Filter_lp_pwr_enb_5" pos="16" access="rw" rst="1">
        </bits>
        <bits name="Pga_op_ibit_5" pos="15" access="rw" rst="1">
        </bits>
        <bits name="Rfvco_buff_ibit_5" pos="14:12" access="rw" rst="010">
        </bits>
        <bits name="lna_gain_bit_5" pos="11:10" access="rw" rst="01">
        </bits>
        <bits name="lna_gain2_bit_5" pos="9:8" access="rw" rst="0">
        </bits>
        <bits name="tia_gain_bit_5" pos="7:6" access="rw" rst="0">
        </bits>
        <bits name="pga_gain_bit_5" pos="5:4" access="rw" rst="0">
        </bits>
        <bits name="filter_gain_bit_5" pos="3:2" access="rw" rst="0">
        </bits>
        <bits name="adc_gain_bit_5" pos="1:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="thermo_map_to_rfvco_current_registers_4BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="Lna_ibit_6" pos="17" access="rw" rst="1">
        </bits>
        <bits name="Filter_lp_pwr_enb_6" pos="16" access="rw" rst="1">
        </bits>
        <bits name="Pga_op_ibit_6" pos="15" access="rw" rst="1">
        </bits>
        <bits name="Rfvco_buff_ibit_6" pos="14:12" access="rw" rst="010">
        </bits>
        <bits name="lna_gain_bit_6" pos="11:10" access="rw" rst="01">
        </bits>
        <bits name="lna_gain2_bit_6" pos="9:8" access="rw" rst="0">
        </bits>
        <bits name="tia_gain_bit_6" pos="7:6" access="rw" rst="0">
        </bits>
        <bits name="pga_gain_bit_6" pos="5:4" access="rw" rst="0">
        </bits>
        <bits name="filter_gain_bit_6" pos="3:2" access="rw" rst="0">
        </bits>
        <bits name="adc_gain_bit_6" pos="1:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="thermo_map_to_rfvco_current_registers_4CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="Lna_ibit_7" pos="17" access="rw" rst="1">
        </bits>
        <bits name="Filter_lp_pwr_enb_7" pos="16" access="rw" rst="1">
        </bits>
        <bits name="Pga_op_ibit_7" pos="15" access="rw" rst="1">
        </bits>
        <bits name="Rfvco_buff_ibit_7" pos="14:12" access="rw" rst="010">
        </bits>
        <bits name="lna_gain_bit_7" pos="11:10" access="rw" rst="01">
        </bits>
        <bits name="lna_gain2_bit_7" pos="9:8" access="rw" rst="0">
        </bits>
        <bits name="tia_gain_bit_7" pos="7:6" access="rw" rst="0">
        </bits>
        <bits name="pga_gain_bit_7" pos="5:4" access="rw" rst="0">
        </bits>
        <bits name="filter_gain_bit_7" pos="3:2" access="rw" rst="0">
        </bits>
        <bits name="adc_gain_bit_7" pos="1:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="thermo_map_to_rfvco_div_ibit_registers_4DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="thermo_4bit_8" pos="17:14" access="rw" rst="0">
            <comment>thermo_4bit_8 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_7" pos="13:10" access="rw" rst="0">
            <comment>thermo_4bit_7 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_6" pos="9:6" access="rw" rst="0">
            <comment>thermo_4bit_6 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_5" pos="5:2" access="rw" rst="0">
            <comment>thermo_4bit_5 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_4" pos="1:0" access="rw" rst="0">
            <comment>thermo_4bit_4 [3:2]
            </comment>
        </bits>
    </reg>
    <reg name="thermo_map_to_rfvco_div_ibit_registers_4EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="thermo_4bit_4" pos="17:16" access="rw" rst="0">
            <comment>thermo_4bit_4 [1:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_3" pos="15:12" access="rw" rst="0">
            <comment>thermo_4bit_3 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_2" pos="11:8" access="rw" rst="0">
            <comment>thermo_4bit_2 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_1" pos="7:4" access="rw" rst="0">
            <comment>thermo_4bit_1 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_0" pos="3:0" access="rw" rst="0">
            <comment>thermo_4bit_0 [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="thermo_map_to_div_grp_tx_ibit_registers_4FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="thermo_7bit_1_8" pos="17:11" access="rw" rst="0">
            <comment>thermo_7bit_1_8 [6:0]
            </comment>
        </bits>
        <bits name="thermo_7bit_1_7" pos="10:4" access="rw" rst="0">
            <comment>thermo_7bit_1_7 [6:0]
            </comment>
        </bits>
        <bits name="thermo_7bit_1_6" pos="3:0" access="rw" rst="0">
            <comment>thermo_7bit_1_6 [6:3]
            </comment>
        </bits>
    </reg>
    <reg name="thermo_map_to_div_grp_tx_ibit_registers_50H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="thermo_7bit_1_6" pos="17:15" access="rw" rst="0">
            <comment>thermo_7bit_1_6 [2:0]
            </comment>
        </bits>
        <bits name="thermo_7bit_1_5" pos="14:8" access="rw" rst="0">
            <comment>thermo_7bit_1_5 [6:0]
            </comment>
        </bits>
        <bits name="thermo_7bit_1_4" pos="7:1" access="rw" rst="0">
            <comment>thermo_7bit_1_4 [6:0]
            </comment>
        </bits>
        <bits name="thermo_off_idle" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="thermo_map_to_rxpll_reg_gro_bit_registers_51H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="mdll_div_num_abn_lb" pos="15:12" access="rw" rst="0">
            <comment>mdll_div_num_abn_lb [3:0]
            </comment>
        </bits>
        <bits name="mdll_div_num_abn_dcs" pos="11:8" access="rw" rst="0">
            <comment>mdll_div_num_abn_dcs [3:0]
            </comment>
        </bits>
        <bits name="mdll_div_num_abn_pcs" pos="7:4" access="rw" rst="0">
            <comment>mdll_div_num_abn_pcs [3:0]
            </comment>
        </bits>
        <bits name="mdll_div_num_normal" pos="3:0" access="rw" rst="0">
            <comment>mdll_div_num_normal [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="thermo_map_to_rxpll_reg_gro_bit_registers_52H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
            <comment>reserved [3:0]
            </comment>
        </bits>
        <bits name="pk_det_time_sel" pos="13:10" access="rw" rst="0">
            <comment>pk_det_time_sel [3:0]
            </comment>
        </bits>
        <bits name="pk_det_out_polarity" pos="9" access="rw" rst="0">
        </bits>
        <bits name="pk_sar_clk_freq_sel" pos="8:7" access="rw" rst="0">
            <comment>pk_sar_clk_freq_sel [1:0]
            </comment>
        </bits>
        <bits name="pk_sar_clk_inv" pos="6" access="rw" rst="0">
        </bits>
        <bits name="pk_det_lpf_bw" pos="5:2" access="rw" rst="0">
            <comment>pk_det_lpf_bw [3:0]
            </comment>
        </bits>
        <bits name="peak_detect_resetn_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="peak_detect_resetn_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="thermo_map_to_rxpll_reg_pres_bit_registers_53H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="pk_out" pos="17:12" access="rw" rst="0">
            <comment>pk_out [5:0]
            </comment>
        </bits>
        <bits name="pk_high_th" pos="11:6" access="rw" rst="0">
            <comment>pk_high_th [5:0]
            </comment>
        </bits>
        <bits name="pk_low_th" pos="5:0" access="rw" rst="0">
            <comment>pk_low_th [5:0]
            </comment>
        </bits>
    </reg>
    <reg name="thermo_map_to_rxpll_reg_pres_bit_registers_54H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="pk_last_time_sel" pos="17:10" access="rw" rst="0">
            <comment>pk_last_time_sel [7:0]
            </comment>
        </bits>
        <bits name="pk_low_counter_th" pos="9:0" access="rw" rst="0">
            <comment>pk_low_counter_th [9:0]
            </comment>
        </bits>
    </reg>
    <reg name="thermo_map_to_rxpll_reg_pres_bit_registers_55H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
        </bits>
        <bits name="rfvco_current_ht_lb_blk" pos="13:10" access="rw" rst="0">
            <comment>rfvco_current_ht_lb_blk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_current_lt_lb_blk" pos="9:6" access="rw" rst="0">
            <comment>rfvco_current_lt_lb_blk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_current_th_lb_blk" pos="5:0" access="rw" rst="0">
            <comment>rfvco_current_th_lb_blk [5:0]
            </comment>
        </bits>
    </reg>
    <reg name="thermo_map_to_rxpll_reg_pres_bit_registers_56H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
        </bits>
        <bits name="rfvco_current_ht_hb_blk" pos="13:10" access="rw" rst="0">
            <comment>rfvco_current_ht_hb_blk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_current_lt_hb_blk" pos="9:6" access="rw" rst="0">
            <comment>rfvco_current_lt_hb_blk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_current_th_hb_blk" pos="5:0" access="rw" rst="0">
            <comment>rfvco_current_th_hb_blk [5:0]
            </comment>
        </bits>
    </reg>
    <reg name="thermo_map_to_rxpll_reg_rdac_bit_registers_57H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="vco_cp_bit_fine_gsm850_rx" pos="17:13" access="rw" rst="0">
        </bits>
        <bits name="vco_cp_bit_fine_gsm900_rx" pos="12:8" access="rw" rst="0">
        </bits>
        <bits name="vco_cp_bit_fine_dcs1800_rx" pos="7:3" access="rw" rst="0">
        </bits>
        <bits name="vco_cp_bit_fine_pcs1900_rx" pos="2:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="thermo_map_to_rxpll_reg_rdac_bit_registers_58H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:2" access="rw" rst="0">
        </bits>
        <bits name="vco_cp_bit_fine_pcs1900_rx" pos="1:0" access="rw" rst="0">
            <comment>vco_cp_bit_fine_pcs1900_rx [1:0]
            </comment>
        </bits>
    </reg>
    <reg name="vco_cp_bit_compensation_1_59H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="vco_cp_bit_factor_gsm850" pos="17:12" access="rw" rst="0">
            <comment>vco_cp_bit_factor_gsm850 [5:0]
            </comment>
        </bits>
        <bits name="vco_cp_bit_factor_gsm900" pos="11:6" access="rw" rst="0">
            <comment>vco_cp_bit_factor_gsm900 [5:0]
            </comment>
        </bits>
        <bits name="vco_cp_bit_factor_dcs1800" pos="5:0" access="rw" rst="0">
            <comment>vco_cp_bit_factor_dcs1800 [5:0]
            </comment>
        </bits>
    </reg>
    <reg name="vco_cp_bit_compensation_2_5AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="r5a_reserved" pos="17" access="rw" rst="0">
        </bits>
        <bits name="cpbit_lpfgain_sel" pos="16" access="rw" rst="0">
        </bits>
        <bits name="cpbit_lpfgain_unnuse" pos="15:11" access="rw" rst="0">
            <comment>cpbit_lpfgain_unnuse [4:0]
            </comment>
        </bits>
        <bits name="vco_cp_bit_factor_pcs1900" pos="10:5" access="rw" rst="0">
            <comment>vco_cp_bit_factor_pcs1900 [5:0]
            </comment>
        </bits>
        <bits name="vco_cp_bit_fine_pcs1900_tx" pos="4:0" access="rw" rst="0">
            <comment>vco_cp_bit_fine_pcs1900_tx [4:0]
            </comment>
        </bits>
    </reg>
    <reg name="vco_cp_bit_compensation_3_5BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="r5b_reserved" pos="17:15" access="rw" rst="0">
            <comment>r5b_reserved [2:0]
            </comment>
        </bits>
        <bits name="vco_cp_bit_fine_gsm850_tx" pos="14:10" access="rw" rst="0">
            <comment>vco_cp_bit_fine_gsm850_tx [4:0]
            </comment>
        </bits>
        <bits name="vco_cp_bit_fine_gsm900_tx" pos="9:5" access="rw" rst="0">
            <comment>vco_cp_bit_fine_gsm900_tx [4:0]
            </comment>
        </bits>
        <bits name="vco_cp_bit_fine_dcs1800_tx" pos="4:0" access="rw" rst="0">
            <comment>vco_cp_bit_fine_dcs1800_tx [4:0]
            </comment>
        </bits>
    </reg>
    <reg name="thermo_map_to_rmx_lo_div_ibit_5CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="thermo_4bit_2_8" pos="17:14" access="rw" rst="0">
            <comment>thermo_4bit_2_8 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_2_7" pos="13:10" access="rw" rst="0">
            <comment>thermo_4bit_2_7 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_2_6" pos="9:6" access="rw" rst="0">
            <comment>thermo_4bit_2_6 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_2_5" pos="5:2" access="rw" rst="0">
            <comment>thermo_4bit_2_5 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_2_4" pos="1:0" access="rw" rst="0">
            <comment>thermo_4bit_2_4 [3:2]
            </comment>
        </bits>
    </reg>
    <reg name="thermo_map_to_rmx_lo_div_ibit_5DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="thermo_4bit_2_4" pos="17:16" access="rw" rst="0">
            <comment>thermo_4bit_2_4 [1:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_2_3" pos="15:12" access="rw" rst="0">
            <comment>thermo_4bit_2_3 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_2_2" pos="11:8" access="rw" rst="0">
            <comment>thermo_4bit_2_2 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_2_1" pos="7:4" access="rw" rst="0">
            <comment>thermo_4bit_2_1 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_2_0" pos="3:0" access="rw" rst="0">
            <comment>thermo_4bit_2_0 [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="sub_module_control_signals_5EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
            <comment>reserved [3:0]
            </comment>
        </bits>
        <bits name="thermo_7bit_1_3" pos="13:7" access="rw" rst="0">
            <comment>thermo_7bit_1_3 [6:0]
            </comment>
        </bits>
        <bits name="thermo_7bit_1_2" pos="6:0" access="rw" rst="0">
            <comment>thermo_7bit_1_2 [6:0]
            </comment>
        </bits>
    </reg>
    <reg name="dsp_signal_5FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
            <comment>reserved [3:0]
            </comment>
        </bits>
        <bits name="thermo_7bit_1_1" pos="13:7" access="rw" rst="0">
            <comment>thermo_7bit_1_1 [6:0]
            </comment>
        </bits>
        <bits name="thermo_7bit_1_0" pos="6:0" access="rw" rst="0">
            <comment>thermo_7bit_1_0 [6:0]
            </comment>
        </bits>
    </reg>
    <reg name="dsp_signal_60H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
            <comment>reserved [17:0]
            </comment>
        </bits>
    </reg>
    <reg name="dsp_signal_61H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
        </bits>
        <bits name="rfvco_vcobuf_ibit_ht_lb_blk" pos="13:10" access="rw" rst="0">
            <comment>rfvco_vcobuf_ibit_ht_lb_blk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_vcobuf_ibit_lt_lb_blk" pos="9:6" access="rw" rst="0">
            <comment>rfvco_vcobuf_ibit_lt_lb_blk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_vcobuf_ibit_th_lb_blk" pos="5:0" access="rw" rst="0">
            <comment>rfvco_vcobuf_ibit_th_lb_blk [5:0]
            </comment>
        </bits>
    </reg>
    <reg name="dsp_signal_for_read_only_62H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
        </bits>
        <bits name="rfvco_vcobuf_ibit_ht_hb_blk" pos="13:10" access="rw" rst="0">
            <comment>rfvco_vcobuf_ibit_ht_hb_blk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_vcobuf_ibit_lt_hb_blk" pos="9:6" access="rw" rst="0">
            <comment>rfvco_vcobuf_ibit_lt_hb_blk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_vcobuf_ibit_th_hb_blk" pos="5:0" access="rw" rst="0">
            <comment>rfvco_vcobuf_ibit_th_hb_blk [5:0]
            </comment>
        </bits>
    </reg>
    <reg name="dsp_signal_63H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
        <bits name="dc_cal_dig_time_sel" pos="15:14" access="rw" rst="0">
            <comment>dc_cal_dig_time_sel [1:0]
            </comment>
        </bits>
        <bits name="offset_init_delay" pos="13:12" access="rw" rst="0">
            <comment>offset_init_delay [1:0]
            </comment>
        </bits>
        <bits name="dc_cal__mode" pos="11:10" access="rw" rst="0">
            <comment>dc_cal__mode [1:0]
            </comment>
        </bits>
        <bits name="tx_dc_cal_en_gsm" pos="9" access="rw" rst="0">
        </bits>
        <bits name="rxpll_cal_mode" pos="8" access="rw" rst="0">
        </bits>
        <bits name="rxpll_init_delay" pos="7:5" access="rw" rst="0">
            <comment>rxpll_init_delay [2:0]
            </comment>
        </bits>
        <bits name="rxpll_open_close_sel" pos="4" access="rw" rst="0">
        </bits>
        <bits name="rxpll_vcobit_msb_fix" pos="3" access="rw" rst="0">
        </bits>
        <bits name="rxpll_cal_opt" pos="2" access="rw" rst="0">
        </bits>
        <bits name="rxpll_cnt_delay_sel" pos="1:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="dsp_signal_64H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="thermo_4bit_3_8" pos="17:14" access="rw" rst="0">
            <comment>thermo_4bit_3_8 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_3_7" pos="13:10" access="rw" rst="0">
            <comment>thermo_4bit_3_7 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_3_6" pos="9:6" access="rw" rst="0">
            <comment>thermo_4bit_3_6 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_3_5" pos="5:2" access="rw" rst="0">
            <comment>thermo_4bit_3_5 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_3_4" pos="1:0" access="rw" rst="0">
            <comment>thermo_4bit_3_4 [3:2]
            </comment>
        </bits>
    </reg>
    <reg name="dsp_signal_65H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="thermo_4bit_3_4" pos="17:16" access="rw" rst="0">
            <comment>thermo_4bit_3_4 [1:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_3_3" pos="15:12" access="rw" rst="0">
            <comment>thermo_4bit_3_3 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_3_2" pos="11:8" access="rw" rst="0">
            <comment>thermo_4bit_3_2 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_3_1" pos="7:4" access="rw" rst="0">
            <comment>thermo_4bit_3_1 [3:0]
            </comment>
        </bits>
        <bits name="thermo_4bit_3_0" pos="3:0" access="rw" rst="0">
            <comment>thermo_4bit_3_0 [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="dsp_signal_66H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="dsp_signal_67H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="equfil_tx_g_gsm_d7" pos="15:0" access="rw" rst="0">
            <comment>equfil_tx_g_gsm_d7 [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="dsp_signal_68H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="equfil_tx_g_gsm_d9" pos="15:0" access="rw" rst="0">
            <comment>equfil_tx_g_gsm_d9 [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="dsp_signal_69H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="coef_b_f" pos="17:16" access="rw" rst="0">
            <comment>coef_b_f [1:0]
            </comment>
        </bits>
        <bits name="equfil_tx_g_gsm_d10" pos="15:0" access="rw" rst="0">
            <comment>equfil_tx_g_gsm_d10 [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="polarity_setting_6AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:15" access="rw" rst="0">
            <comment>reserved [2:0]
            </comment>
        </bits>
        <bits name="filter_dac1_cal_iq_swap" pos="14" access="rw" rst="0">
        </bits>
        <bits name="filter_dac2_cal_iq_swap" pos="13" access="rw" rst="0">
        </bits>
        <bits name="clk_rxpll_cal_inv_reg" pos="12" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="11:10" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
        <bits name="clk_dsp_invert_reg" pos="9" access="rw" rst="0">
        </bits>
        <bits name="clk_gating_always_on" pos="8" access="rw" rst="0">
        </bits>
        <bits name="tx_path_dc_cal_polarity" pos="7" access="rw" rst="0">
        </bits>
        <bits name="thermo_cal_polarity" pos="6" access="rw" rst="0">
        </bits>
        <bits name="adc_cal_refi_polarity" pos="5" access="rw" rst="0">
        </bits>
        <bits name="adc_cal_reg_polarity" pos="4" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="3:2" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
        <bits name="filter_dac1_cal_polarity" pos="1" access="rw" rst="0">
        </bits>
        <bits name="filter_dac2_cal_polarity" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="dsp_signal_6BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:10" access="rw" rst="0">
            <comment>reserved [7:0]
            </comment>
        </bits>
        <bits name="self_cal_ready_dr" pos="9" access="rw" rst="0">
        </bits>
        <bits name="adc_cal_reg_resetn_dr" pos="8" access="rw" rst="0">
        </bits>
        <bits name="rxpll_cal_resetn_dr" pos="7" access="rw" rst="0">
        </bits>
        <bits name="thermo_cal_resetn_dr" pos="6" access="rw" rst="0">
        </bits>
        <bits name="dc_offset_cal_fsm_resetn_dr" pos="5" access="rw" rst="0">
        </bits>
        <bits name="self_cal_ready_reg" pos="4" access="rw" rst="0">
        </bits>
        <bits name="adc_cal_reg_resetn_reg" pos="3" access="rw" rst="0">
        </bits>
        <bits name="rxpll_cal_resetn_reg" pos="2" access="rw" rst="0">
        </bits>
        <bits name="thermo_cal_resetn_reg" pos="1" access="rw" rst="0">
        </bits>
        <bits name="dc_offset_cal_fsm_resetn" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="compensation_setting_6CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
            <comment>reserved [17:0]
            </comment>
        </bits>
    </reg>
    <reg name="compensation_setting_6DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
            <comment>reserved [17:0]
            </comment>
        </bits>
    </reg>
    <reg name="compensation_setting_6EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
            <comment>reserved [17:0]
            </comment>
        </bits>
    </reg>
    <reg name="compensation_setting_6FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
            <comment>reserved [17:0]
            </comment>
        </bits>
    </reg>
    <reg name="compensation_setting_70H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="thermo_diff_8" pos="17:14" access="rw" rst="0">
            <comment>thermo_diff_8 [3:0]
            </comment>
        </bits>
        <bits name="thermo_diff_7" pos="13:10" access="rw" rst="0">
            <comment>thermo_diff_7 [3:0]
            </comment>
        </bits>
        <bits name="thermo_diff_6" pos="9:6" access="rw" rst="0">
            <comment>thermo_diff_6 [3:0]
            </comment>
        </bits>
        <bits name="thermo_diff_5" pos="5:2" access="rw" rst="0">
            <comment>thermo_diff_5 [3:0]
            </comment>
        </bits>
        <bits name="thermo_diff_4" pos="1:0" access="rw" rst="0">
            <comment>thermo_diff_4 [3:2]
            </comment>
        </bits>
    </reg>
    <reg name="compensation_setting_71H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="thermo_diff_4" pos="17:16" access="rw" rst="0">
            <comment>thermo_diff_4 [1:0]
            </comment>
        </bits>
        <bits name="thermo_diff_3" pos="15:12" access="rw" rst="0">
            <comment>thermo_diff_3 [3:0]
            </comment>
        </bits>
        <bits name="thermo_diff_2" pos="11:8" access="rw" rst="0">
            <comment>thermo_diff_2 [3:0]
            </comment>
        </bits>
        <bits name="thermo_diff_1" pos="7:4" access="rw" rst="0">
            <comment>thermo_diff_1 [3:0]
            </comment>
        </bits>
        <bits name="thermo_diff_0" pos="3:0" access="rw" rst="0">
            <comment>thermo_diff_0 [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="strobe_timer_72H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
        </bits>
        <bits name="rfvco_current_ht_lb_nblk" pos="13:10" access="rw" rst="0">
            <comment>rfvco_current_ht_lb_nblk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_current_lt_lb_nblk" pos="9:6" access="rw" rst="0">
            <comment>rfvco_current_lt_lb_nblk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_current_th_lb_nblk" pos="5:0" access="rw" rst="0">
            <comment>rfvco_current_th_lb_nblk [5:0]
            </comment>
        </bits>
    </reg>
    <reg name="strobe_timer_73H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
        </bits>
        <bits name="rfvco_current_ht_hb_nblk" pos="13:10" access="rw" rst="0">
            <comment>rfvco_current_ht_hb_nblk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_current_lt_hb_nblk" pos="9:6" access="rw" rst="0">
            <comment>rfvco_current_lt_hb_nblk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_current_th_hb_nblk" pos="5:0" access="rw" rst="0">
            <comment>rfvco_current_th_hb_nblk [5:0]
            </comment>
        </bits>
    </reg>
    <reg name="strobe_timer_74H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
        </bits>
        <bits name="rfvco_vcobuf_ibit_ht_lb_nblk" pos="13:10" access="rw" rst="0">
            <comment>rfvco_vcobuf_ibit_ht_lb_nblk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_vcobuf_ibit_lt_lb_nblk" pos="9:6" access="rw" rst="0">
            <comment>rfvco_vcobuf_ibit_lt_lb_nblk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_vcobuf_ibit_th_lb_nblk" pos="5:0" access="rw" rst="0">
            <comment>rfvco_vcobuf_ibit_th_lb_nblk [5:0]
            </comment>
        </bits>
    </reg>
    <reg name="digital_interface_setting_75H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
        </bits>
        <bits name="rfvco_vcobuf_ibit_ht_hb_nblk" pos="13:10" access="rw" rst="0">
            <comment>rfvco_vcobuf_ibit_ht_hb_nblk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_vcobuf_ibit_lt_hb_nblk" pos="9:6" access="rw" rst="0">
            <comment>rfvco_vcobuf_ibit_lt_hb_nblk [3:0]
            </comment>
        </bits>
        <bits name="rfvco_vcobuf_ibit_th_hb_nblk" pos="5:0" access="rw" rst="0">
            <comment>rfvco_vcobuf_ibit_th_hb_nblk [5:0]
            </comment>
        </bits>
    </reg>
    <reg name="reserved_register_76H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:6" access="rw" rst="0">
            <comment>reserved [11:0]
            </comment>
        </bits>
        <bits name="thermo_diff_enable" pos="5" access="rw" rst="0">
        </bits>
        <bits name="thermo_diff_dr" pos="4" access="rw" rst="0">
        </bits>
        <bits name="thermo_diff_reg" pos="3:0" access="rw" rst="0">
            <comment>thermo_diff_reg [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="compensate_setting_77H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:12" access="rw" rst="0">
            <comment>reserved [5:0]
            </comment>
        </bits>
        <bits name="mismatch_diff_enable" pos="11" access="rw" rst="0">
        </bits>
        <bits name="thermo_diff_enable" pos="10" access="rw" rst="0">
        </bits>
        <bits name="thermo_diff_dr" pos="9" access="rw" rst="0">
        </bits>
        <bits name="mismatch_diff_dr" pos="8" access="rw" rst="0">
        </bits>
        <bits name="thermo_diff_reg" pos="7:4" access="rw" rst="0">
            <comment>thermo_diff_reg [3:0]
            </comment>
        </bits>
        <bits name="mismatch_diff_reg" pos="3:0" access="rw" rst="0">
            <comment>mismatch_diff_reg [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="compensate_setting_78H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:13" access="rw" rst="0">
            <comment>reserved [4:0]
            </comment>
        </bits>
        <bits name="tx_dac_cal_en" pos="12" access="rw" rst="0">
        </bits>
        <bits name="tx_dac_bit_i" pos="11:0" access="rw" rst="0">
            <comment>tx_dac_bit_i [11:0]
            </comment>
        </bits>
    </reg>
    <reg name="compensate_setting_79H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:12" access="rw" rst="0">
        </bits>
        <bits name="tx_dac_bit_q" pos="11:0" access="rw" rst="0">
            <comment>tx_dac_bit_q [11:0]
            </comment>
        </bits>
    </reg>
    <reg name="dc_cancel_1_7AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="offset_value" pos="17:6" access="rw" rst="0">
            <comment>offset_value [23:12]
            </comment>
        </bits>
        <bits name="reserved" pos="5:3" access="rw" rst="0">
            <comment>reserved [2:0]
            </comment>
        </bits>
        <bits name="dc_in_i_rx_reg" pos="2:0" access="rw" rst="0">
            <comment>dc_in_i_rx_reg [9:7]
            </comment>
        </bits>
    </reg>
    <reg name="dc_cancel_2_7BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="dc_in_rx_dr" pos="17" access="rw" rst="0">
        </bits>
        <bits name="dc_in_i_rx_reg" pos="16:10" access="rw" rst="0">
            <comment>dc_in_i_rx_reg [6:0]
            </comment>
        </bits>
        <bits name="dc_in_q_rx_reg" pos="9:0" access="rw" rst="0">
            <comment>dc_in_q_rx_reg [9:0]
            </comment>
        </bits>
    </reg>
    <reg name="dc_cancel_3_7CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="dc_tx_cal_en" pos="17" access="rw" rst="0">
        </bits>
        <bits name="dc_in_i_tx_reg" pos="16:10" access="rw" rst="0">
            <comment>dc_in_i_tx_reg [6:0]
            </comment>
        </bits>
        <bits name="dc_in_q_tx_reg" pos="9:0" access="rw" rst="0">
            <comment>dc_in_q_tx_reg [9:0]
            </comment>
        </bits>
    </reg>
    <reg name="former_settings_7DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="offset_value" pos="17:6" access="rw" rst="0">
            <comment>offset_value [11:0]
            </comment>
        </bits>
        <bits name="reserved" pos="5:3" access="rw" rst="0">
            <comment>reserved [2:0]
            </comment>
        </bits>
        <bits name="dc_in_i_tx" pos="2:0" access="rw" rst="0">
            <comment>dc_in_i_tx [9:7]
            </comment>
        </bits>
    </reg>
    <reg name="xcv_8809z_7EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_7FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_80H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_81H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="reserved0_agc_lna" pos="15:0" access="rw" rst="0">
            <comment>reserved0_agc_lna [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_82H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="reserved1_agc_lna" pos="15:0" access="rw" rst="0">
            <comment>reserved1_agc_lna [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_83H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="reserved2_agc_lna" pos="15:0" access="rw" rst="0">
            <comment>reserved2_agc_lna [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_84H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="reserved3_agc_lna" pos="15:0" access="rw" rst="0">
            <comment>reserved3_agc_lna [15:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_85H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
            <comment>reserved [17:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_86H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="freq_tx_offset" pos="17:0" access="rw" rst="0">
            <comment>freq_tx_offset [17:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_87H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:12" access="rw" rst="0">
            <comment>reserved [5:0]
            </comment>
        </bits>
        <bits name="equfil_tx_b1" pos="11:0" access="rw" rst="0">
            <comment>equfil_tx_b1 [11:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_88H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:12" access="rw" rst="0">
            <comment>reserved [5:0]
            </comment>
        </bits>
        <bits name="equfil_tx_b2" pos="11:0" access="rw" rst="0">
            <comment>equfil_tx_b2 [11:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_89H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:12" access="rw" rst="0">
            <comment>reserved [5:0]
            </comment>
        </bits>
        <bits name="equfil_tx_a1" pos="11:0" access="rw" rst="0">
            <comment>equfil_tx_a1 [11:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_8AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:12" access="rw" rst="0">
            <comment>reserved [5:0]
            </comment>
        </bits>
        <bits name="equfil_tx_a2" pos="11:0" access="rw" rst="0">
            <comment>equfil_tx_a2 [11:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_8BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:15" access="rw" rst="0">
        </bits>
        <bits name="equfil_tx_k" pos="14:0" access="rw" rst="0">
            <comment>equfil_tx_k [14:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_8CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
        </bits>
        <bits name="freq_low_gsm850" pos="13:7" access="rw" rst="0">
            <comment>freq_low_gsm850 [6:0]
            </comment>
        </bits>
        <bits name="freq_high_gsm850" pos="6:0" access="rw" rst="0">
            <comment>freq_high_gsm850 [6:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_8DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
        </bits>
        <bits name="freq_low_gsm900" pos="13:7" access="rw" rst="0">
            <comment>freq_low_gsm900 [6:0]
            </comment>
        </bits>
        <bits name="freq_high_gsm900" pos="6:0" access="rw" rst="0">
            <comment>freq_high_gsm900 [6:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_8EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
        </bits>
        <bits name="freq_low_dcs1800" pos="13:7" access="rw" rst="0">
            <comment>freq_low_dcs1800 [6:0]
            </comment>
        </bits>
        <bits name="freq_high_dcs1800" pos="6:0" access="rw" rst="0">
            <comment>freq_high_dcs1800 [6:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_8FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
        </bits>
        <bits name="freq_low_pcs1900" pos="13:7" access="rw" rst="0">
            <comment>freq_low_pcs1900 [6:0]
            </comment>
        </bits>
        <bits name="freq_high_pcs1900" pos="6:0" access="rw" rst="0">
            <comment>freq_high_pcs1900 [6:0]
            </comment>
        </bits>
    </reg>
    <reg name="edge_dsp_setting_90H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:4" access="rw" rst="0">
        </bits>
        <bits name="Digrf_test_en" pos="3" access="rw" rst="0">
        </bits>
        <bits name="Digrf_mode_mux" pos="2" access="rw" rst="0">
        </bits>
        <bits name="mode_spi" pos="1" access="rw" rst="0">
        </bits>
        <bits name="pdn_test_en" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_91H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_92H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_93H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_94H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_95H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_96H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_97H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_98H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_99H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_9AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_9BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_9CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_9DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_9EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="edge_dsp_setting_9FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="digital_pll_setting_A0H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="digital_pll_setting_A1H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="digital_pll_setting_A2H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="digital_pll_setting_A3H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="digital_pll_setting_A4H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="digital_pll_setting_A5H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="digital_pll_setting_A6H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="digital_pll_setting_A7H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="digital_pll_setting_A8H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="digital_pll_setting_A9H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="digital_pll_setting_AAH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="digital_pll_setting_ABH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_ACH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_ADH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_AEH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_AFH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_B0H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_B1H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_B2H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_B3H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_B4H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_B5H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_B6H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_B7H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_B8H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_B9H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_BAH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_BBH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_BCH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_BDH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_BEH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_BFH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="rtc_setting_C0H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="cap_bank_bit_lp" pos="17:10" access="rw" rst="0">
            <comment>cap_bank_bit_lp [7:0]
            </comment>
        </bits>
        <bits name="osc_cfix_lp" pos="9" access="rw" rst="0">
        </bits>
        <bits name="ibit_xosc_lp" pos="8:5" access="rw" rst="0">
            <comment>ibit_xosc_lp [3:0]
            </comment>
        </bits>
        <bits name="fix_ibit_xosc_lp" pos="4:0" access="rw" rst="0">
            <comment>fix_ibit_xosc_lp [4:0]
            </comment>
        </bits>
    </reg>
    <reg name="xcv_8809z_C1H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0">
            <comment>reserved [3:0]
            </comment>
        </bits>
        <bits name="ldo_pwr_time_sel" pos="13:11" access="rw" rst="0">
            <comment>ldo_pwr_time_sel [2:0]
            </comment>
        </bits>
        <bits name="xtal_reg_time_sel" pos="10:8" access="rw" rst="0">
            <comment>xtal_reg_time_sel [2:0]
            </comment>
        </bits>
        <bits name="pd_ldo_dr" pos="7" access="rw" rst="0">
        </bits>
        <bits name="pd_ldo_reg" pos="6:5" access="rw" rst="0">
        </bits>
        <bits name="enable_clk_6p5m_reg" pos="4" access="rw" rst="0">
        </bits>
        <bits name="lp_mode_en_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="lp_mode_en_reg" pos="2" access="rw" rst="0">
        </bits>
        <bits name="lp_mode_h_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="lp_mode_h_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="rtc_setting_C2H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="step_offset_normal" pos="15:8" access="rw" rst="0">
            <comment>step_offset_normal [7:0]
            </comment>
        </bits>
        <bits name="step_offset_lp" pos="7:0" access="rw" rst="0">
            <comment>step_offset_lp [7:0]
            </comment>
        </bits>
    </reg>
    <reg name="rtc_setting_C3H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:1" access="rw" rst="0">
        </bits>
        <bits name="step_offset_update" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="rtc_setting_C4H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="clk32k_26mxtal_en_pmu" pos="17" access="rw" rst="0">
        </bits>
        <bits name="clk32k_lpo_en_pmu" pos="16" access="rw" rst="0">
        </bits>
        <bits name="clk32k_xtal_en_pmu" pos="15" access="rw" rst="0">
        </bits>
        <bits name="lpo_32k_pu_pmu" pos="14" access="rw" rst="0">
        </bits>
        <bits name="pu_xtal32k_pmu" pos="13" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="12:1" access="rw" rst="0">
            <comment>reserved [11:0]
            </comment>
        </bits>
        <bits name="xen_bt_enable" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_C5H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_C6H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_C7H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_C8H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_C9H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_CAH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_CBH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_CCH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_CDH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_CEH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="rtc_setting_CFH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:1" access="rw" rst="0">
        </bits>
        <bits name="soft_resetn_rtc" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_D0H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_D1H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_D2H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_D3H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_D4H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_D5H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_D6H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_D7H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_D8H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_D9H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_DAH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_DBH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_DCH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_DDH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_DEH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_DFH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_E0H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_E1H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_E2H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_E3H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_E4H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_E5H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_E6H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_E7H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_E8H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_E9H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_EAH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_EBH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_ECH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_EDH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_EEH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_EFH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_F0H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_F1H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_F2H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_F3H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_F4H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_F5H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_F6H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_F7H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_F8H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_F9H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_FAH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_FBH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_FCH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_FDH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_FEH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_FFH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_100H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_101H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="pll_clkout_en" pos="15:12" access="rw" rst="0">
            <comment>pll_clkout_en [3:0]
            </comment>
        </bits>
        <bits name="pll_cpaux_bit" pos="11:9" access="rw" rst="0">
            <comment>pll_cpaux_bit [2:0]
            </comment>
        </bits>
        <bits name="pll_filter_ibit" pos="8:6" access="rw" rst="0">
            <comment>pll_filter_ibit [2:0]
            </comment>
        </bits>
        <bits name="pll_cp_bit" pos="5:3" access="rw" rst="0">
            <comment>pll_cp_bit [2:0]
            </comment>
        </bits>
        <bits name="pll_int_mode" pos="2" access="rw" rst="0">
        </bits>
        <bits name="pll_sdm_clk_sel_rst" pos="1" access="rw" rst="0">
        </bits>
        <bits name="pll_sdm_clk_sel_nor" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_102H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="pll_lock" pos="15" access="rw" rst="0">
        </bits>
        <bits name="pll_sdm_clk_test_en" pos="14" access="rw" rst="0">
        </bits>
        <bits name="pll_refmulti2" pos="13" access="rw" rst="0">
        </bits>
        <bits name="pll_vco_high_test" pos="12" access="rw" rst="0">
        </bits>
        <bits name="pll_vco_low_test" pos="11" access="rw" rst="0">
        </bits>
        <bits name="pll_test_en" pos="10" access="rw" rst="0">
        </bits>
        <bits name="pll_vreg_bit" pos="9:6" access="rw" rst="0">
            <comment>pll_vreg_bit [3:0]
            </comment>
        </bits>
        <bits name="pd_pll_dr" pos="5" access="rw" rst="0">
        </bits>
        <bits name="pd_pll_reg" pos="4" access="rw" rst="0">
        </bits>
        <bits name="pll_reset_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="pll_reset_reg" pos="2" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="1:0" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
    </reg>
    <reg name="xcv_8809z_103H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_104H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_105H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_freq" pos="15:0" access="rw" rst="0">
            <comment>bbpll_sdm1_freq [27:12]
            </comment>
        </bits>
    </reg>
    <reg name="xcv_8809z_106H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_freq" pos="15:4" access="rw" rst="0">
            <comment>bbpll_sdm1_freq [11:0]
            </comment>
        </bits>
        <bits name="reserved" pos="3:0" access="rw" rst="0">
            <comment>reserved [3:0]
            </comment>
        </bits>
    </reg>
    <reg name="xcv_8809z_107H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_int_dec_sel" pos="15:13" access="rw" rst="0">
            <comment>bbpll_sdm1_int_dec_sel [2:0]
            </comment>
        </bits>
        <bits name="bbpll_sdm1_dither_bypass" pos="12" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_ss_en" pos="11" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_ss_squre_tri_sel" pos="10" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_dcdc2_output_inv" pos="9" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_dcdc3_output_inv" pos="8" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_reserved" pos="7" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_dcdc4_one_more_div2" pos="6" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_dcdc3_one_more_div2" pos="5" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_dcdc2_one_more_div2" pos="4" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_dcdc1_one_more_div2" pos="3" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_clk_fbc_inv" pos="2" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_resetn_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_resetn_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_108H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm1_ss_devi_ct" pos="15:8" access="rw" rst="0">
            <comment>bbpll_sdm1_ss_devi_ct [7:0]
            </comment>
        </bits>
        <bits name="bbpll_sdm1_ss_peri_ct" pos="7:0" access="rw" rst="0">
            <comment>bbpll_sdm1_ss_peri_ct [7:0]
            </comment>
        </bits>
    </reg>
    <reg name="xcv_8809z_109H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="bbpll_sdm2_freq" pos="15:0" access="rw" rst="0">
            <comment>bbpll_sdm2_freq [27:12]
            </comment>
        </bits>
    </reg>
    <reg name="xcv_8809z_10AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_10BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_10CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_10DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:14" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
        <bits name="dcdc_clkgen1_clk_sel" pos="13" access="rw" rst="0">
        </bits>
        <bits name="dcdc_clkgen1_dither_ct" pos="12:10" access="rw" rst="0">
            <comment>dcdc_clkgen1_dither_ct [2:0]
            </comment>
        </bits>
        <bits name="dcdc_clkgen1_div_basebuck1" pos="9:2" access="rw" rst="0">
            <comment>dcdc_clkgen1_div_basebuck1 [7:0]
            </comment>
        </bits>
        <bits name="dcdc_clkgen1_resetn_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="dcdc_clkgen1_resetn_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_10EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:14" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
        <bits name="dcdc_clkgen2_clk_sel" pos="13" access="rw" rst="0">
        </bits>
        <bits name="dcdc_clkgen2_dither_ct" pos="12:10" access="rw" rst="0">
            <comment>dcdc_clkgen2_dither_ct [2:0]
            </comment>
        </bits>
        <bits name="dcdc_clkgen2_div_basebuck2_and_boost" pos="9:2" access="rw" rst="0">
            <comment>dcdc_clkgen2_div_basebuck2_and_boost [7:0]
            </comment>
        </bits>
        <bits name="dcdc_clkgen2_resetn_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="dcdc_clkgen2_resetn_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_10FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_110H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:14" access="rw" rst="0">
            <comment>reserved [1:0]
            </comment>
        </bits>
        <bits name="sdm_reset_time_sel" pos="13:12" access="rw" rst="0">
            <comment>sdm_reset_time_sel [1:0]
            </comment>
        </bits>
        <bits name="sdm_aux_reset_time_sel" pos="11:10" access="rw" rst="0">
            <comment>sdm_aux_reset_time_sel [1:0]
            </comment>
        </bits>
        <bits name="sdmclk_sel_time_sel" pos="9:8" access="rw" rst="0">
            <comment>sdmclk_sel_time_sel [1:0]
            </comment>
        </bits>
        <bits name="pll_reset_time_sel" pos="7:6" access="rw" rst="0">
            <comment>pll_reset_time_sel [1:0]
            </comment>
        </bits>
        <bits name="dcdc1_resetn_time_sel" pos="5:4" access="rw" rst="0">
            <comment>dcdc1_resetn_time_sel [1:0]
            </comment>
        </bits>
        <bits name="dcdc2_resetn_time_sel" pos="3:2" access="rw" rst="0">
            <comment>dcdc2_resetn_time_sel [1:0]
            </comment>
        </bits>
        <bits name="dcdc3_resetn_time_sel" pos="1:0" access="rw" rst="0">
            <comment>dcdc3_resetn_time_sel [1:0]
            </comment>
        </bits>
    </reg>
    <reg name="xcv_8809z_111H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:12" access="rw" rst="0">
            <comment>reserved [3:0]
            </comment>
        </bits>
        <bits name="ldo_bypass" pos="11" access="rw" rst="0">
        </bits>
        <bits name="ldo_test_bit" pos="10:9" access="rw" rst="0">
            <comment>ldo_test_bit [1:0]
            </comment>
        </bits>
        <bits name="ldo_test_enable" pos="8" access="rw" rst="0">
        </bits>
        <bits name="ldo_vbit" pos="7:5" access="rw" rst="0">
            <comment>ldo_vbit [2:0]
            </comment>
        </bits>
        <bits name="sel_bg" pos="4" access="rw" rst="0">
        </bits>
        <bits name="pd_bg_dr" pos="3" access="rw" rst="0">
        </bits>
        <bits name="pd_bg_reg" pos="2" access="rw" rst="0">
        </bits>
        <bits name="pd_ldo_dr" pos="1" access="rw" rst="0">
        </bits>
        <bits name="pd_ldo_reg" pos="0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_112H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_113H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_114H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_115H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_116H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_117H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_118H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_119H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_11AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_11BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_11CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_11DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_11EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_11FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_120H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_121H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_122H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_123H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_124H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_125H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_126H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_127H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_128H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_129H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_12AH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_12BH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_12CH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_12DH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_12EH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_12FH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="xcv_8809z_130H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0">
        </bits>
        <bits name="reserved" pos="15:2" access="rw" rst="0">
        </bits>
        <bits name="register_resetn_pll" pos="1" access="rw" rst="0">
        </bits>
        <bits name="soft_resetn_pll" pos="0" access="rw" rst="0">
        </bits>
    </reg>
</module>
</archive>




<archive relative = "gallite.xml">

  <include file="globals.xml"/>
  <include file="global_macros.xml"/>
  <include file="gallite_generic_config.xml"/>

  

  <include file="bb_cp2.xml" />
  <include file="bb_ifc.xml" />
  <include file="sys_ifc2.xml" />
  <include file="bb_irq.xml" />
  <include file="bb_sram.xml" />
  <include file="comregs.xml" />
  <include file="bcpu_cache.xml" />
  <include file="bcpu_tag.xml" />
  <include file="cipher.xml" />
  <include file="cipher_a53.xml" />
  <include file="debug_host.xml" />
  <include file="debug_host_internals.xml" />
  <include file="pmu.xml" />
  <include file="abb.xml" />
  <include file="xcv.xml" />
  <include file="debug_uart.xml" />
  <include file="dma.xml" />
  <include file="spi_flash.xml" />
  <include file="mem_bridge.xml" />
  <include file="gpio.xml" />
  <include file="i2c_master.xml" />
  <include file="itlv.xml" />
  <include file="page_spy.xml" />
  <include file="rf_if.xml" />
  <include file="rf_spi.xml" />
  <include file="sci.xml" />
  <include file="spi.xml" />
  <include file="sys_ctrl.xml" />
  <include file="sys_ifc.xml" />
  <include file="sys_irq.xml" />
  <include file="tcu.xml" />
  <include file="timer.xml" />
  <include file="uart.xml" />
  <include file="iomux.xml" />
  <include file="vitac.xml" />
  <include file="xcor.xml" />
  <include file="cp0.xml" />
  <include file="regdef.xml" />
  <include file="xcpu_cache.xml" />
  <include file="xcpu_tag.xml" />
  <include file="xcpu.xml" />
  <include file="pwm.xml" />
  <include file="calendar.xml" />
  <include file="usbc.xml" />
  <include file="sdmmc.xml" />
  <include file='cfg_regs.xml' />
  <include file="cordic.xml" />
  <include file="keypad.xml" />
  <include file="excor.xml" />
  <include file="gouda.xml" />
  <include file="aif.xml" />
  <include file="camera.xml" />
  <include file="voc_ram.xml" />
  <include file="voc_ahb.xml" />
  <include file="voc_cfg.xml" />
  <include file="seg_scan.xml" />
  <include file="psram8_ctrl.xml" />
  <include file="cholk.xml" />
  <include file="fmd.xml" />


  
  <instance address="0x00000000" type="debug_host_internal_registers" name="INT_REG_DBG_HOST" />
  
  
  <instance address="0x08000000" type="ebc_cs0" name="CS0" />
  <instance address="0x02000000" type="ebc_cs1" name="CS1" />

  <instance address="0x01c00000" type="int_sram" name="INT_SRAM" />
  <instance address="0x01d00000" type="bb_patch" name="BB_PATCH" />
  <instance address="0x01e80000" type="bcpu_rom" name="BCPU_ROM" />
  <instance address="0x0191f100" type="cipher_a53_spram" name="CIPHER_A53_SPRAM" />
  <instance address="0x01e00000" type="int_rom" name="INT_ROM" />
  <instance address="0x01a80000" type="usbc" name="USBC" />
  <instance address="0x01ae0000" type="gouda_sram" name="GOUDA_SRAM" />
  <instance address="0x07fff000" type="spi_flash" name="SPI_FLASH" />

  
  <var name="REG_VOC_BASE" value="0x01940000"><comment>VOC AHB base</comment></var>

  <instance address="REG_VOC_BASE+0x00000000" type="voc_ram" name="VOC_RAM" />
  <instance address="REG_VOC_BASE+0x0001ff80" type="voc_cfg" name="VOC_CFG" />
  <instance address="REG_VOC_BASE+0x00030000" type="voc_ahb" name="VOC_AHB" />


  
  <var name="REG_SYS_APB_BASE" value="0x01a00000"><comment>System APB base</comment></var>

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SYS_CTRL" type="sys_ctrl" name="SYS_CTRL" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_IRQ" type="sys_irq" name="SYS_IRQ" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_TIMER" type="timer" name="TIMER" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_GPIO" type="gpio" name="GPIO" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_EBC" type="psram8_ctrl" name="PSRAM8_CTRL" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_KEYPAD" type="keypad" name="KEYPAD" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_PWM" type="pwm" name="PWM" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_I2C" type="i2c_master" name="I2C_MASTER" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_DMA" type="dma" name="DMA" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_IFC" type="sys_ifc" name="SYS_IFC" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_CALENDAR" type="calendar" name="CALENDAR" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_COMREGS" type="comregs" name="SYS_COMREGS" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_PAGE_SPY" type="page_spy" name="PAGE_SPY" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SEG_SCAN" type="seg_scan" name="SEG_SCAN" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_RF_SPI" type="rf_spi" name="RF_SPI" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_TCU" type="tcu" name="TCU" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SCI" type="sci" name="SCI" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SPI1" type="spi" name="SPI1" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SPI2" type="spi" name="SPI2" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SPI3" type="spi" name="SPI3" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_DEBUG_UART" type="debug_uart" name="DEBUG_UART" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_UART" type="uart" name="UART" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_UART2" type="uart" name="UART2" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SDMMC" type="sdmmc" name="SDMMC" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_CAMERA" type="camera" name="CAMERA" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_XCPU_TAG" type="xcpu_tag" name="XCPU_TAG" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_XCPU_IDATA" type="xcpu_cache" name="XCPU_IDATA" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_XCPU_DDATA" type="xcpu_cache" name="XCPU_DDATA" />



  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_GOUDA" type="gouda" name="GOUDA" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_I2C2" type="i2c_master" name="I2C_MASTER2" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_I2C3" type="i2c_master" name="I2C_MASTER3" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_EXT_APB" type="cfg_regs" name="CONFIG_REGS" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_IOMUX" type="iomux" name="IOMUX" />
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_XCPU_REG" type="xcpu" name="XCPU" />



  
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_DEBUG_HOST" type="debug_host" name="DEBUG_HOST" />


  
  <var name="REG_SYS_APB2_BASE" value="0x01920000"><comment>System APB2 base</comment></var>

  <instance address="REG_SYS_APB2_BASE + SYS_APB_STEP * BB_ID_IFC" type="sys_ifc2" name="SYS_IFC2" />
  <instance address="REG_SYS_APB2_BASE + SYS_APB_STEP * BB_ID_AIF" type="aif" name="AIF" />


  
  <instance address="0x0191f000" type="cipher_a53" name="CIPHER_A53" />
  <instance address="0x01980000" type="bb_sram" name="BB_SRAM" />

  
  <var name="REG_BB_APB_BASE" value="0x01900000"><comment>Baseband APB base</comment></var>

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_XCOR" type="xcor" name="XCOR" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_IFC" type="bb_ifc" name="BB_IFC" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_IRQ" type="bb_irq" name="BB_IRQ" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_ITLV" type="itlv" name="ITLV" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_VITERBI" type="vitac" name="VITAC" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_A5" type="cipher" name="CIPHER" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_RF" type="rf_if" name="RF_IF" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_CP2" type="bb_cp2" name="BB_CP2" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BCPU_REG" type="xcpu" name="BCPU" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BCPU_TAG" type="bcpu_tag" name="BCPU_TAG" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BCPU_IDATA" type="bcpu_cache" name="BCPU_IDATA" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BCPU_DDATA" type="bcpu_cache" name="BCPU_DDATA" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_COMREGS" type="comregs" name="BB_COMREGS" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_EXCOR" type="excor" name="EXCOR" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_CHOLK" type="cholk" name="CHOLK" /> -->
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_CORDIC" type="cordic" name="CORDIC" />
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_MEMBRIDGE" type="mem_bridge" name="BB_MEM_BRIDGE" />




  
  <instance address="0xa2000500" type="abb" name="ABB" />

  
  <instance address="0xa2000840" type="pmu" name="PMU" />

  
  <instance address="0xa2000000" type="xcv_8809z_reg" name="XCV" />   

  
  <instance address="0xa2000640" type="fmd" name="FMD" />






</archive>

</bigarchive>
